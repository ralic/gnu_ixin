<?xml version="1.0"?>
<!DOCTYPE texinfo PUBLIC "-//GNU//DTD TexinfoML V5.00//EN" "http://www.gnu.org/software/texinfo/dtd/5.00/texinfo.dtd">
<texinfo xml:lang="en">
<filename file="serveez.xml"></filename>
<preamble>\input texinfo
</preamble><!-- c %**start of header -->
<setfilename file="serveez.info" spaces=" ">serveez.info</setfilename>
<documentencoding encoding="UTF-8" spaces=" ">UTF-8</documentencoding>
<settitle spaces=" ">GNU Serveez</settitle>
<exampleindent value="2" line=" 2"></exampleindent>
<syncodeindex from="vr" to="cp" line=" vr cp"></syncodeindex>
<syncodeindex from="fn" to="cp" line=" fn cp"></syncodeindex>
<set name="txideftypefnnl" line=" txideftypefnnl"></set>
<!-- c %** end of header -->

<set name="UPDATED" line=" UPDATED 31 December 2012">31 December 2012</set>
<set name="UPDATED-MONTH" line=" UPDATED-MONTH December 2012">December 2012</set>
<set name="EDITION" line=" EDITION 0.1.7">0.1.7</set>
<set name="VERSION" line=" VERSION 0.1.7">0.1.7</set>
<copying endspaces=" ">
<para>This manual documents GNU Serveez 0.1.7,
released 31 December 2012.
</para>
<para>Copyright &copyright; 2011, 2012 Thien-Thi Nguyen&linebreak;
Copyright &copyright; 2000&textndash;2002 Stefan Jahn &lt;stefan&arobase;lkcc.org&gt;&linebreak;
Copyright &copyright; 2000&textndash;2002 Raimund Jacob &lt;raimi&arobase;lkcc.org&gt;&linebreak;
Copyright &copyright; 1999 Martin Grabmueller &lt;mgrabmue&arobase;cs.tu-berlin.de&gt;
</para>
<quotation endspaces=" ">
<para>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation.
A copy of the license is included in the section entitled &textldquo;GNU
Free Documentation License&textrdquo;.
</para></quotation>
</copying>

<set name="PACKAGE" line=" PACKAGE Serveez">Serveez</set>
<set name="s_PACKAGE" line=" s_PACKAGE serveez">serveez</set>

<dircategory spaces=" ">Serveez - A server framework.</dircategory>
<direntry endspaces=" ">
<menuentry leadingtext="* "><menutitle separator=": ">Serveez</menutitle><menunode separator=".           ">(serveez)</menunode><menudescription><pre xml:space="preserve">Serveez Documentation.
</pre></menudescription></menuentry></direntry>

<macro name="PROC" line=" PROC">Scheme Procedure
</macro>

<titlepage endspaces=" ">
<title spaces=" ">GNU Serveez</title>
<subtitle spaces=" ">A server framework</subtitle>
<subtitle spaces=" ">Edition 0.1.7, 31 December 2012</subtitle>
<author spaces=" ">Stefan Jahn</author>
<author spaces=" ">Raimund Jacob</author>
<author spaces=" ">Thien-Thi Nguyen</author>

<page></page>
<vskip> 0pt plus 1filll</vskip>
<insertcopying></insertcopying>
</titlepage>

<contents></contents>

<node name="Top" spaces=" "><nodename>Top</nodename><nodenext automatic="on">Using Serveez</nodenext><nodeup automatic="on">(dir)</nodeup></node>
<top spaces=" "><sectiontitle>GNU Serveez</sectiontitle>

<para>This manual documents GNU Serveez 0.1.7,
released 31 December 2012.
</para>
<!-- c blurb.texi - standard GNU Serveez description -->
<!-- c -->
<!-- c Copyright (C) 2011, 2012 Thien-Thi Nguyen -->
<!-- c Copyright (C) 2000, 2001, 2002 Stefan Jahn <stefan@lkcc.org> -->
<!-- c Copyright (C) 2000, 2001, 2002 Raimund Jacob <raimi@lkcc.org> -->
<!-- c Copyright (C) 1999 Martin Grabmueller <mgrabmue@cs.tu-berlin.de> -->
<!-- c -->
<!-- c Permission is granted to copy, distribute and/or modify this document -->
<!-- c under the terms of the GNU Free Documentation License, Version 1.1 -->
<!-- c or any later version published by the Free Software Foundation. -->
<!-- c A copy of the license is included in the section entitled "GNU -->
<!-- c Free Documentation License". -->
<!-- c -->
<!-- c - -->
<!-- c The following text is found in various places, not only in texinfo -->
<!-- c documentation, so we keep it simple (don't include any markup). -->
<!-- c -->
<para>GNU Serveez is a server framework.  It provides routines and help
for implementing IP-based servers (currently TCP, UDP and ICMP).
It supports named pipes for all connection-oriented protocols.
</para>
<para>We think it is worth the effort because many people need server
functionality within their applications.  However, many people
experience problems with select(2) or poll(2) loops, and with
non-blocking operations.
</para>
<para>GNU Serveez demonstrates various aspects of advanced network
programming in a portable manner.  It is known to compile and
run on GNU/Linux systems, as well as on other 32-bit and 64-bit
flavours of Unix and on Microsoft Windows (9x/ME/NT/2000/XP).
</para>
<para>You can use it for implementing your own servers or for
understanding how certain network services and operations work.
</para>
<para>The package includes a number of servers that work already: an
HTTP server, an IRC server, a Gnutella spider and some others.
One of the highlights is that you can run all protocols on the
same port.  The application itself is single threaded but it uses
helper processes for concurrent name resolution and ident lookups.
</para>
<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::         ">Using Serveez</menunode><menudescription><pre xml:space="preserve">Startup and command line options
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::               ">Concept</menunode><menudescription><pre xml:space="preserve">Conceptual thoughts
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::                ">Server</menunode><menudescription><pre xml:space="preserve">Server implementation
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::              ">Coserver</menunode><menudescription><pre xml:space="preserve">Coserver implementation
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::             ">Embedding</menunode><menudescription><pre xml:space="preserve">Using libserveez in your own program
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::        ">Porting issues</menunode><menudescription><pre xml:space="preserve">Support of different platforms and operating systems
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::          ">Bibliography</menunode><menudescription><pre xml:space="preserve">Useful documents we refer to
</pre></menudescription></menuentry><menucomment><pre xml:space="preserve">
</pre></menucomment><menuentry leadingtext="* "><menunode separator="::">GNU Free Documentation License</menunode><menudescription><pre xml:space="preserve">
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::">Index</menunode><menudescription><pre xml:space="preserve">
</pre></menudescription></menuentry></menu>

</top>
<node name="Using-Serveez" spaces=" "><nodename>Using Serveez</nodename><nodenext automatic="on">Concept</nodenext><nodeprev automatic="on">Top</nodeprev><nodeup automatic="on">Top</nodeup></node>
<chapter spaces=" "><sectiontitle>Using Serveez</sectiontitle>

<para>We know, you usually don&textrsquo;t read the documentation.  Who does.  But
please, read at the very least this chapter.  It contains information on
the basic concepts.  Larger parts of the manual can be used as a
reference manual for the various servers.
</para>
<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::     ">Build and install</menunode><menudescription><pre xml:space="preserve">Making Serveez a part of your system
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator=":: ">Environment variables</menunode><menudescription><pre xml:space="preserve">Hints for the dynamic module loader
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::      ">Starting Serveez</menunode><menudescription><pre xml:space="preserve">The moment of truth
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::  ">Command line options</menunode><menudescription><pre xml:space="preserve">Specifying the config file and other params
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::       ">The config file</menunode><menudescription><pre xml:space="preserve">Defining servers, ports, and how they relate
</pre></menudescription></menuentry></menu>

<node name="Build-and-install" spaces=" "><nodename>Build and install</nodename><nodenext automatic="on">Environment variables</nodenext><nodeup automatic="on">Using Serveez</nodeup></node>
<section spaces=" "><sectiontitle>Building and installing</sectiontitle>

<subsection spaces=" "><sectiontitle>Rebuild the package from the sources</sectiontitle>
<para>You can skip this section if you are familiar with the GNU&textrsquo;ish way of
configuring, compiling and installing a GNU package.
</para>
<subsubsection spaces=" "><sectiontitle>Getting the source</sectiontitle>
<para>Serveez can be found on <uref><urefurl>http://ftp.gnu.org/gnu/serveez/</urefurl></uref>, on one
of the mirrors (<uref><urefurl>http://www.gnu.org/prep/ftp.html</urefurl></uref>) or at its
original location <uref><urefurl>http://www.lkcc.org/~ela/download/</urefurl></uref>.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Requirements</sectiontitle>
<para>Serveez needs GNU Guile (Ubiquitous Intelligent Language for Extensions).
The current version of Serveez is known to work with Guile 1.3 and later.
Guile can be downloaded at <uref><urefurl>http://ftp.gnu.org/gnu/guile/</urefurl></uref>.
</para>
<para>When installing Guile, consider specifying to its <file>configure</file>
script options along the lines of:
</para>
<example endspaces=" ">
<pre xml:space="preserve">--enable-static --disable-shared
--disable-debug-freelist
--disable-debug-malloc
--disable-guile-debug
--disable-arrays --disable-posix
--enable-networking --disable-regex
--without-threads --enable-ltdl-convenience
</pre></example>

<para>This option set is tuned for Guile 1.4 and may or may not work for your
particular installation; you may need to experiment a bit.
Most important is that the program <samp>guile-config</samp> be findable
in a directory named in the <code>PATH</code> environment variable.
If not, configuration will fail with message &textldquo;Guile not found&textrdquo;.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Installation</sectiontitle>
<table commandarg="asis" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="asis">Unpack the distribution tarball:</itemformat></item>
</tableterm><tableitem><example endspaces=" ">
<pre xml:space="preserve">sleepless ~&gt; gzip -cd serveez-0.1.7.tar.gz | tar xvf -
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Change into the source directory:</itemformat></item>
</tableterm><tableitem><example endspaces=" ">
<pre xml:space="preserve">sleepless ~&gt; cd serveez-0.1.7
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Configure the source package for your system:</itemformat></item>
</tableterm><tableitem><para>Normally, this is done by running the <file>configure</file> script in the
top-level directory.
GNU Serveez needs a reasonably conformant C99 compiler to build.
If the <file>configure</file> script is not able to automatically find
and enable such a compiler, you can specify it directly using
the <samp>CC</samp> command-line option.  For example:
</para><example endspaces=" ">
<pre xml:space="preserve">sleepless ~&gt; ./configure --prefix /gnu CC='/gnu/bin/gcc'
</pre></example>
<para>Note that in this example you can achieve the same results by
making sure <file>/gnu/bin</file> is in the <code>PATH</code> env var.
</para>
<para>In previous Serveez releases, the <file>configure</file> script had some
builtin compiler flags for warnings and optimizations, conveniently
exposed via command-line options.  These are no longer available;
instead, you can use <code>CFLAGS</code> for such purposes (see below).
Here is a complete list of the <file>configure</file> script
options.  The list of known options can the obtained via
<samp>./configure --help</samp>.
</para>
<table commandarg="samp" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-debug</itemformat></item>
</tableterm><tableitem><para>All of the debug messages (debug: some annoying crap text) can
be suppressed by setting the debug level (-v).  If you do not
want these messages built in at all then disable this feature.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-control-proto</itemformat></item>
</tableterm><tableitem><para>If you enable this feature the control protocol will be supported
by Serveez.  This protocol is for remote control of the server.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-irc-proto</itemformat></item>
</tableterm><tableitem><para>Enabling this feature tells the software package to support the
IRC (Internet Relay Chat) protocol.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-irc-ts</itemformat></item>
</tableterm><tableitem><para>This feature is only available if you enabled the IRC protocol.
If you enabled both of them then Serveez will support the so
called TimeStamp protocol, which is an EFNet extension of the
original IRC protocol.  In order to connect to EFNet you MUST
use this option.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-http-proto</itemformat></item>
</tableterm><tableitem><para>When using Serveez as part of the textSure (C) chat system you
will will have need of an additional web server.  This option
makes Serveez support a simple HTTP protocol.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-flood</itemformat></item>
</tableterm><tableitem><para>If you enable this feature Serveez will support a simple built-in
flood protection.  It is always useful to protect the software
from flood clients.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--with-mingw=DIR</itemformat></item>
</tableterm><tableitem><para>When compiling under M$-Windows the <var>DIR</var> argument specifies the
path to the extra MinGW32 library and header files.  If you want the
final executable to use the Cygwin project&textrsquo;s <file>cygwin1.dll</file> instead,
you have to disable this option by passing the configure script
<samp>--without-mingw</samp> or <samp>--with-mingw=no</samp>.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-sntp-proto</itemformat></item>
</tableterm><tableitem><para>This option enables support for a simple network time protocol
server.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-poll</itemformat></item>
</tableterm><tableitem><para>If the target system supports <code>poll</code> and this feature is
enabled the main file descriptor loop is done via <code>poll</code>.
This helps to work around the (g)libc&textrsquo;s file descriptor limit.
Otherwise Serveez always falls back to the <code>select</code> system call.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-sendfile</itemformat></item>
</tableterm><tableitem><para>This option enables the use of the <code>sendfile</code> system call.
Disabling it using <samp>--disable-sendfile</samp> provides a work-around
for bogus implementations of <code>sendfile</code>.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-gnutella</itemformat></item>
</tableterm><tableitem><para>If you do *not* want the Gnutella spider client compiled in you
need to *disable* this option.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-crypt</itemformat></item>
</tableterm><tableitem><para>This option tells Serveez to process any passwords as <code>crypt</code>ed.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-tunnel</itemformat></item>
</tableterm><tableitem><para>If you enable this feature the port forwarder will be included.
This is useful if you plan to use Serveez as a gateway or
firewall workaround.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-fakeident</itemformat></item>
</tableterm><tableitem><para>By enabling this you will get a fake ident server included in
the binary executable.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-guile-server</itemformat></item>
</tableterm><tableitem><para>If you enable this feature the user is able to write servers
using Guile.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-passthrough</itemformat></item>
</tableterm><tableitem><para>This includes the program passthrough server in the Serveez
binary.  The server provides basic inetd functionality.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-iflist</itemformat></item>
</tableterm><tableitem><para>If Serveez is unable to detect the correct list of local network
interfaces (<samp>serveez -i</samp>) you can disable this option and setup
them manually in the configuration file.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-heap-count</itemformat></item>
</tableterm><tableitem><para>This option depends on <samp>--enable-debug</samp>.  With the debugging option
disabled there is also no support for heap counters.  The heap
counters are used to detect memory leaks in Serveez.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">--enable-libserveez-install</itemformat></item>
</tableterm><tableitem><para>This causes <samp>make install</samp> to also copy libserveez and its
header files to <code>$(libdir)</code> and <code>$(includedir)</code>, respectively.
While Serveez is in alpha (version less than <samp>0.8.0</samp>),
this option is disabled by default.
</para></tableitem></tableentry></table>

<para>For maximum flexibility and reproducibility, we recommend enabling
warnings and optimizations specifying <code>CFLAGS</code> as a command-line
option to the <file>configure</file> script.  For reference, here is the
collected set of flags built into previous Serveez releases:
</para>
<example endspaces=" ">
<pre xml:space="preserve"><r>(warnings)</r>
  -W -fullwarn -pedantic -ansi
  -Wall -Wcast-align -Wstrict-prototypes
  -Wformat -Wno-unused -Wno-long-long

<r>(optimizations)</r>
  -O2 -fomit-frame-pointer -fstrength-reduce
  -funroll-loops -finline-functions
  -fexpensive-optimizations -fcaller-saves
  -frerun-loop-opt -foptimize-register-move
  -ffunction-cse -fpeephole -momit-leaf-frame-pointer
  -fschedule-insns2 -m486 -march=pentiumpro -O3
</pre></example>

<para>Note that not all flags may be compatible with your compiler or even
each other.  That&textrsquo;s one of the reasons we no longer take this approach.
<xref><xrefnodename>Defining Variables</xrefnodename><xrefinfofile>autoconf</xrefinfofile><xrefprintedname>The Autoconf Manual</xrefprintedname></xref>.
</para>
<example endspaces=" ">
<pre xml:space="preserve">sleepless ~/serveez-0.1.7&gt; ./configure \
  CFLAGS='-g -O3 -Wall -Wextra'
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Now compile the package:</itemformat></item>
</tableterm><tableitem><example endspaces=" ">
<pre xml:space="preserve">sleepless ~/serveez-0.1.7&gt; make
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Install serveez:</itemformat></item>
</tableterm><tableitem><para>You must have root privileges if you want to install the package in the
standard location <file>/usr/local</file> or in any location that is only writable
by root.
</para><example endspaces=" ">
<pre xml:space="preserve">sleepless ~/serveez-0.1.7&gt; make install
</pre></example>
</tableitem></tableentry></table>

<para>If you have problems building the package out of the box this is due to
GNU libtool&textrsquo;s inability to handle dynamic linking in most cases.  That
is why we recommend to try to configure the package with
<samp>--disable-shared</samp>.
</para>
</subsubsection>
</subsection>
</section>
<node name="Environment-variables" spaces=" "><nodename>Environment variables</nodename><nodenext automatic="on">Starting Serveez</nodenext><nodeprev automatic="on">Build and install</nodeprev><nodeup automatic="on">Using Serveez</nodeup></node>
<section spaces=" "><sectiontitle>Environment variables</sectiontitle>

<para>When using the serveezopt package or playing around with the dynamic server
module loader of Serveez you can tell the core API of Serveez (which is the
<file>libserveez.[so|dll]</file> library) to use an additional load path to find
these server modules.  The environment variable <samp>SERVEEZ_LOAD_PATH</samp> holds
this information.  You can set it up via:
</para>
<example endspaces=" ">
<pre xml:space="preserve">  on Unices
sleepless ~&gt; export SERVEEZ_LOAD_PATH=/home/lib:/usr/local/lib

  or on Windows
C:\HOME&gt; set SERVEEZ_LOAD_PATH=C:\HOME\LIB;C:\USR\LOCAL\LIB
</pre></example>

</section>
<node name="Starting-Serveez" spaces=" "><nodename>Starting Serveez</nodename><nodenext automatic="on">Command line options</nodenext><nodeprev automatic="on">Environment variables</nodeprev><nodeup automatic="on">Using Serveez</nodeup></node>
<section spaces=" "><sectiontitle>Starting Serveez</sectiontitle>

<para>When Serveez is started it reads its configuration from a file called
<file>serveez.cfg</file> in the current directory and runs the server
loop afterwards.  Press <key>^C</key>  to abort the execution of this program.
Serveez is not interactive and does not automatically detach from the
terminal.
</para>
</section>
<node name="Command-line-options" spaces=" "><nodename>Command line options</nodename><nodenext automatic="on">The config file</nodenext><nodeprev automatic="on">Starting Serveez</nodeprev><nodeup automatic="on">Using Serveez</nodeup></node>
<section spaces=" "><sectiontitle>Command line options</sectiontitle>

<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">-h, --help</itemformat></item>
</tableterm><tableitem><para>Display this help and exit.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">-V, --version</itemformat></item>
</tableterm><tableitem><para>Display version information and exit.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">-i, --iflist</itemformat></item>
</tableterm><tableitem><para>List local network interfaces and exit.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">-f, --cfg-file=FILENAME</itemformat></item>
</tableterm><tableitem><para>File to use as configuration file (serveez.cfg).
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">-v, --verbose=LEVEL</itemformat></item>
</tableterm><tableitem><para>Set level of logging verbosity.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">-l, --log-file=FILENAME</itemformat></item>
</tableterm><tableitem><para>Use <code>FILENAME</code> for logging (default is stderr).
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">-P, --password=STRING</itemformat></item>
</tableterm><tableitem><para>Set the password for control connections.
This option is available only if the control protocol is enabled.
<xref><xrefnodename>Control Protocol Server</xrefnodename></xref>.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">-m, --max-sockets=COUNT</itemformat></item>
</tableterm><tableitem><para>Set the maximum number of socket descriptors.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">-d, --daemon</itemformat></item>
</tableterm><tableitem><para>Start as daemon in background.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">-c, --stdin</itemformat></item>
</tableterm><tableitem><para>Use standard input as configuration file.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">-s, --solitary</itemformat></item>
</tableterm><tableitem><para>Do not start any builtin coserver instances.
</para></tableitem></tableentry></table>

</section>
<node name="The-config-file" spaces=" "><nodename>The config file</nodename><nodeprev automatic="on">Command line options</nodeprev><nodeup automatic="on">Using Serveez</nodeup></node>
<section spaces=" "><sectiontitle>Configuring Serveez</sectiontitle>

<para>As noted above Serveez is configured via a configuration file which is by
default <file>serveez.cfg</file> and can be set by passing the <samp>-f</samp> command
line argument.  When you pipe a file into Serveez or pass the <samp>-c</samp>
argument on the command line the input stream will be used as configuration
file no matter whether you passed a <samp>-f</samp> command line switch or not.
</para>
<para>To make configuring more fun we did not invent yet another configuration
file format.  Instead we use a dialect of the Scheme programming language
called GNU Guile (<uref><urefurl>http://www.gnu.org/software/guile/</urefurl></uref>).  There is no
need to be worried if you are not a programmer.  What you have to do is
really simple and this document shows you everything you need to know.  We
also provide many examples.  However there are some simple concepts you
have to understand.  The following paragraphs will explain them.
</para>
<para>The idea of the configuration file is this: Serveez starts, runs the
configuration file (other applications usually just read them and remember
the settings) and finally enters its main loop doing the things you wanted
it to.
</para>
<para>There are three things you have to do in the configuration file.
</para>
<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::           ">Define ports</menunode><menudescription><pre xml:space="preserve">Port configuration definition
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::         ">Define servers</menunode><menudescription><pre xml:space="preserve">Server definition
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::  ">Bind servers to ports</menunode><menudescription><pre xml:space="preserve">How to bind servers to port configurations
</pre></menudescription></menuentry></menu>

<node name="Define-ports" spaces=" "><nodename>Define ports</nodename><nodenext automatic="on">Define servers</nodenext><nodeup automatic="on">The config file</nodeup></node>
<subsection spaces=" "><sectiontitle>Define ports</sectiontitle>

<para>A <code>port</code> (in Serveez) is a transport endpoint.  You might know them
from other TCP or UDP server applications.  For example: web servers
(HTTP) usually listen on TCP port 80.  However, there is more than TCP
ports: we have UDP, ICMP and named pipes each with different options to
set.  Every port has a unique name you assign to it.  The name of the port is
later used to bind servers to it.
</para>
<para>The following examples show how you setup different types of port
configurations.  You start to define such a port using the procedure
<code>define-port!</code>.  The first argument specifies the
name of the port configuration.  The remaining argument describes the
port in detail.
</para>
<subsubsection spaces=" "><sectiontitle>Port configuration items</sectiontitle>
<para>This table describes each configuration item for a port in Serveez.  Note
that not each item applies to every kind of port configuration.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">proto (string)</itemformat></item>
</tableterm><tableitem><para>This is the main configuration item for a port configuration setting up the
type of port.  Valid values are <samp>tcp</samp>, <samp>udp</samp>, <samp>icmp</samp>,
<samp>raw</samp> and <samp>pipe</samp>.  This configuration item decides which of the
remaining configuration items apply and which do not.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">port (integer in the range 0..65535)</itemformat></item>
</tableterm><tableitem><para>The <code>port</code> item determines the network port number on which TCP and UDP
servers will listen.  Thus it does not make sense for ICMP and named pipes.
If you pass <samp>0</samp> Serveez will determine a free port in the range
between 1 and 65535.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">recv (string or associative list)</itemformat></item>
</tableterm><tableitem><para>This item describes the receiving (listening) end of a named pipe
connection, i.e., the filename of a fifo node to which a client can
connect by opening it for writing.  Both the <code>recv</code> and <code>send</code>
item apply to named pipes only.  The value can either be an associative
list or a simple filename.  Using a simple filename leaves additional
options to use default values.  They deal mainly with file permissions
and are described below.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">send (string or associative list)</itemformat></item>
</tableterm><tableitem><para>This item is the sending end of a named pipe connection.  It is used to
send data when the receiving (listening) end has detected a connection.
The following table enumerates the additional options you can
setup if you pass an associative list and not a simple filename.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">name (string)</itemformat></item>
</tableterm><tableitem><para>The filename of the named pipe.  On Windows systems you can also specify
the hostname on which the pipe should be created in the format
<samp>\\hostname\pipe\name</samp>.  By default (if you leave the leading
<samp>\\hostname\pipe\</samp> part) the pipe will be created on
<samp>\\.\pipe\name</samp> which refers to a pipe on the local machine.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">permission (octal integer)</itemformat></item>
</tableterm><tableitem><para>This specifies the file permissions a named pipe should be created with.
The given number is interpreted in a Unix&textrsquo;ish style (e.g., <samp>#o0666</samp>
is a permission field for reading and writing for the creating user, all
users in the same group and all other users).
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">user (string)</itemformat></item>
</tableterm><tableitem><para>The file owner (username) of the named pipe in textual form.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">group (string)</itemformat></item>
</tableterm><tableitem><para>The file owner group (groupname) of the named pipe in textual form.  If
this item is left it defaults to the file owner&textrsquo;s primary group.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">uid (integer)</itemformat></item>
</tableterm><tableitem><para>The file owner of the named pipe as a user id.  You are meant to specify
either the <code>uid</code> item or the <code>user</code> item.  Serveez will
complain about conflicting values.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">gid (integer)</itemformat></item>
</tableterm><tableitem><para>The file owner group of the named pipe as a group id.  This item
defaults to the file owner&textrsquo;s primary group id.  You are meant to specify
either the <code>gid</code> item or the <code>group</code> item.  Serveez will croak
about conflicting values.
</para></tableitem></tableentry></table>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">ipaddr (string)</itemformat></item>
</tableterm><tableitem><para>This configuration item specifies the IP address (either in dotted decimal
form e.g., <samp>192.168.2.1</samp> or as a device description which can be
obtained via <samp>serveez -i</samp>) to which a server is bound to.  The
<samp>*</samp> keyword for all known IP addresses and the <samp>any</samp> keyword for
any IP address are also valid values.  The default value is <samp>*</samp>.  The
configuration item applies to network ports (TCP, UDP and ICMP) only.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">device (string)</itemformat></item>
</tableterm><tableitem><para>The <code>device</code> configuration item also refers to the IP address a server
can be bound to.  It overrides the <code>ipaddr</code> item.  Valid values are
network device descriptions (probably no aliases and no loopback devices).
It applies to network ports (TCP, UDP and ICMP) only.
</para>
<para>A note on device bindings:  Device bindings are based on the
<code>SO_BINDTODEVICE</code> socket layer option.  This option is not available
on all systems.  We only tested it on GNU/Linux (2.2.18 and 2.4.17 as of
this writing).  Device bindings are very restrictive: only root can do it
and only physical devices are possible.  The loopback device cannot be used
and no interface alias (i.e., <samp>eth0:0</samp>).  A device binding can only
be reached from the physical outside but it includes all aliases for the
device.  So if you bind to device <samp>eth0</samp> even <samp>eth0:0</samp> (and all
other aliases) are used.  The connection has to be made from a remote
machine.  The advantage of this kind of binding is that it survives
changes of IP addresses.  This is tested for ethernet networks (i.e., eth*)
and isdn dialups (i.e., ippp*).  It does not work for modem dialups
(i.e., ppp*) (at least for Stefan&textrsquo;s PCMCIA modem).  The problem seems to be
the dialup logic actually destroying ppp*.  Other opinions are welcome.
Device bindings always win: If you bind to <samp>*</samp> (or an individual IP
address) and to the corresponding device, connections are made with
the device binding.  The order of the <code>bind-server!</code> statements
do not matter.  This feature is not thoroughly tested.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">backlog (integer)</itemformat></item>
</tableterm><tableitem><para>The <code>backlog</code> parameter defines the maximum length the queue of
pending connections may grow to.  If a connection request arrives with the
queue full the client may receive an error.  This parameter applies to
TCP ports only.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">type (integer in the range 0..255)</itemformat></item>
</tableterm><tableitem><para>This item applies to ICMP ports only.  It defines the message type
identifier used to send ICMP packets (e.g., <samp>8</samp> is an echo message
i.e., PING).
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">send-buffer-size (integer)</itemformat></item>
</tableterm><tableitem><para>The <code>send-buffer-size</code> configuration item defines the maximum number
of bytes the send queue of a client is allowed to grow to.  The item
influences the &textldquo;send buffer overrun error condition&textrdquo;.  For packet oriented
protocols (UDP and ICMP) you need to specify at least the maximum number
of bytes a single packets can have.  For UDP and ICMP this is 64 KByte.
The value specified here is an initial value.  It is used unless the
server bound to this port changes it.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">recv-buffer-size (integer)</itemformat></item>
</tableterm><tableitem><para>The <code>recv-buffer-size</code> configuration item defines the maximum
number of bytes the receive queue of a client is allowed to grow to.
The item influences the &textldquo;receive buffer underrun error condition&textrdquo;.  The
value specified here is an initial value.  It is used unless the server
bound to this port changes it.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">connect-frequency (integer)</itemformat></item>
</tableterm><tableitem><para>This item determines the maximum number of connections per second the port
will accept.  It is a kind of &textldquo;hammer protection&textrdquo;.  The item is evaluated
for each remote client machine separately.  It applies to TCP ports.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">allow (list of strings)</itemformat></item>
</tableterm><tableitem><para>Both the <code>allow</code> and <code>deny</code> lists are lists of IP addresses in
dotted decimal form (e.g., <samp>192.168.2.1</samp>).  The <code>allow</code> list defines
the remote machines which are allowed to connect to the port.  It applies
to TCP ports.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">deny (list of strings)</itemformat></item>
</tableterm><tableitem><para>The <code>deny</code> list defines the remote machines which are not allowed to
connect to the port.  Each connection from one of these IP addresses will
be refused and shut down immediately.  It applies to TCP ports.
</para></tableitem></tableentry></table>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>TCP port definition</sectiontitle>
<para>Definition of a TCP port configuration with the name <code>foo-tcp-port</code>.  The
enhanced settings are all optional including the <var>ipaddr</var> property
which defaults to <samp>*</samp>.  The <var>ipaddr</var> item can contain any form
of a dotted decimal internet address, a <samp>*</samp>, <samp>any</samp> or an
interface description which you can obtain by running <samp>serveez -i</samp>.
</para>
<example endspaces=" ">
<pre xml:space="preserve">(define-port! 'foo-tcp-port '(
    ;; usual settings
    (proto  . tcp)              ;; protocol is tcp
    (port   . 42421)            ;; network port 42421
    (ipaddr . *)                ;; bind to all known interfaces
    (device . eth0)             ;; bind to network card

    ;; enhanced settings
    (backlog           . 5)     ;; enqueue max. 5 connections
    (connect-frequency . 1)     ;; allow 1 connect per second
    (send-buffer-size  . 1024)  ;; initial send buffer size in bytes
    (recv-buffer-size  . 1024)  ;; initial receive buffer size in bytes

    ;; allow connections from these ip addresses
    (allow             . (127.0.0.1 127.0.0.2))

    ;; refuse connections from this ip address
    (deny              . (192.168.2.7))
  ))
</pre></example>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>Pipe port definition</sectiontitle>
<para>Definition of a pipe port configuration with the name <code>foo-pipe-port</code>.
When bound to a server it creates the receiving end and listens on that.
If some client accesses this named pipe the server opens the sending end
which the client has to open for reading previously.
</para>
<para>The only mandatory item is the file name of each pipe.  If you want to
specify a user creating the named pipe (file ownership) use either the
<var>user</var> or the <var>uid</var> setting.  Same goes for the items
<var>group</var> and <var>gid</var>.
</para>
<example endspaces=" ">
<pre xml:space="preserve">(define-port! 'foo-pipe-port `(
    (proto . pipe)                   ;; protocol is named pipe

    ;; specify the receiving endpoint
    (recv . ((name . &quot;.foo-recv&quot;)    ;; name of the pipe
             (permissions . #o0666)  ;; create it with these permissions
             (user . &quot;calvin&quot;)       ;; as user &quot;calvin&quot;
             (uid . 50)              ;; with the user id 50
             (group . &quot;heros&quot;)       ;; which is in the group &quot;heros&quot;
             (gid . 100)))           ;; with the group id 100

    ;; specify the sending endpoint
    (send . ((name . &quot;.foo-send&quot;)
             (permissions . #o0666)
             (user . &quot;hobbes&quot;)
             (uid . 51)
             (group . &quot;stuffed&quot;)
             (gid . 101)))
   ))
</pre></example>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>ICMP port definition</sectiontitle>
<para>Define an ICMP port configuration which will accept connections from the
network interface <samp>127.0.0.1</samp> only and communicates via the message
type 8 as described in the <ref><xrefnodename>Tunnel Server</xrefnodename></ref> chapter.  The name of
this port configuration is <code>foo-icmp-port</code>.  When you are going to bind
some server to this kind of port you have to ensure root (or
Administrator under Windows) privileges.
</para>
<example endspaces=" ">
<pre xml:space="preserve">(define-port! 'foo-icmp-port '((proto  . icmp)
                               (ipaddr . 127.0.0.1)
                               (type   . 8)))
</pre></example>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>UDP port definition</sectiontitle>
<para>Simple definition of a UDP port configuration with the name <code>foo-udp-port</code>.
</para>
<example endspaces=" ">
<pre xml:space="preserve">(define-port! 'foo-udp-port `((proto . udp)
                              (port  . 27952)))
</pre></example>

</subsubsection>
</subsection>
<node name="Define-servers" spaces=" "><nodename>Define servers</nodename><nodenext automatic="on">Bind servers to ports</nodenext><nodeprev automatic="on">Define ports</nodeprev><nodeup automatic="on">The config file</nodeup></node>
<subsection spaces=" "><sectiontitle>Define servers</sectiontitle>

<para>A <code>server</code> (in Serveez) is a snippet of code that implements some
protocol.  There are many servers built into Serveez but you can implement
your own, too.  For example we provide a webserver implementing the
Hypertext Transfer Protocol (HTTP).  Each server has a different set of
options you can change.  You can have many instances of every server, each
with a different set of options.  For example: You can create a webserver
on TCP port 42420 publishing the Serveez documentation and also have another
webserver on a different port publishing something else.  Every server
has a unique name you assign to it.  The name of the server is later used
to bind it to a port.
</para>
<para>The following example instantiates a server with the short name &textldquo;foo&textrdquo;.  Each
server in Serveez has got a short name.  <xref><xrefnodename>Existing servers</xrefnodename></xref>, for the
details.  This example demonstrates everything which is possible in server
configurations.  You start a definition of a server with the procedure
<code>define-server!</code>.  The following argument specifies the name of the
server instance (in this case <code>foo-server</code>) which starts with the short
name.  The second argument describes the server in detail.  Each
configuration item is setup with a <code>(key . value)</code> pair where <var>key</var> is
the name of the configuration item and <var>value</var> is the value which depends
on the type of the item.  <xref><xrefnodename>Configuring servers</xrefnodename></xref>, for a detailed
description of each type of value.
</para>
<example endspaces=" ">
<pre xml:space="preserve">(define-server! 'foo-server '(
    (bar . 100)                             ;; number
    (reply . &quot;Booo&quot;)                        ;; character string
    (messages .                             ;; list of strings
      (&quot;Welcome to the foo test server.&quot;
       &quot;This one echos your lines.&quot;))
    (ports . (5 6 7 8 9))                   ;; list of numbers
    (port . foo-tcp-port)                   ;; a port configuration
    (assoc . (( &quot;GNU&quot; . &quot;great&quot; )           ;; associative list
              ( &quot;Tree&quot; . &quot;tall&quot; )))
    (truth . #f)                            ;; boolean value
  ))
</pre></example>

<para>Serveez provides a number of server types.  Each of them has a short name.
The name of the server instance has to begin with this short name followed
by a dash (-).  You can append any suffix then.  In the example above &textldquo;foo&textrdquo;
is the short name and <code>foo-server</code> the name of the server instance.
</para>
</subsection>
<node name="Bind-servers-to-ports" spaces=" "><nodename>Bind servers to ports</nodename><nodeprev automatic="on">Define servers</nodeprev><nodeup automatic="on">The config file</nodeup></node>
<subsection spaces=" "><sectiontitle>Bind servers to ports</sectiontitle>

<para>Finally you can bind servers to ports.  When you do so the server you
created listens on the port, accepts connections and serves clients.  It
does so as soon as Serveez enters its main loop right after running the
configuration file.  Serveez won&textrsquo;t stop until you interrupt it (e.g., by
pressing <key>^C</key> in the terminal you started it in).
</para>
<para>This example binds the server <code>foo-server</code> (s.a.)
to the port <code>foo-tcp-port</code>
which was described above.  Therefore you need to call the procedure
<code>bind-server!</code> which takes two arguments specifying the name of a port
configuration and a server instance.  Both need to be defined before
you can write this statement.
</para>
<example endspaces=" ">
<pre xml:space="preserve">(bind-server! 'foo-tcp-port 'foo-server)
</pre></example>

<para>One of the main features of Serveez is that you can bind multiple
servers to the same port.  This for example is useful to pass braindead
firewall configurations or proxy servers.  It is also possible to bind
servers to ports they are actually not designed for.  This might be used
for debugging servers or other funny things (again, think about the
firewall).  This is the point we have to warn you: Some protocols cannot
share the same port (e.g., the tunnel server) and some protocols simply won&textrsquo;t
work on &textrsquo;wrong&textrsquo; ports.  Additionally, you will not get error messages when
that happens.  The server just will not work then.
</para>
</subsection>
<subsection spaces=" "><sectiontitle>Additional configuration possibilities</sectiontitle>

<para>The three procedures <code>define-port!</code>, <code>define-server!</code> and
<code>bind-server!</code> return <code>#t</code> on success and <code>#f</code> on failure.
For your convenience we provide some more built-in procedures,
some of which are based upon those above.
</para>
<!-- c guile-boot.texh - a -*-texinfo-*- fragment for built-in procedures -->
<!-- c -->
<!-- c Copyright (C) 2011, 2012 Thien-Thi Nguyen -->
<!-- c -->
<!-- c This file is provided under the same terms as serveez.texi. -->

<subsubsection spaces=" "><sectiontitle>output</sectiontitle>

<set name="TSINCURMOD" line=" TSINCURMOD (guile)">(guile)</set>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">println</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>println</deffunction> <defdelimiter>[</defdelimiter><defparam>object</defparam><defparam>&dots;</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Do <code>display</code> on each <var>object</var>.
Then, output a newline.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">printsln</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>printsln</deffunction> <defparam>spacer</defparam> <defdelimiter>[</defdelimiter><defparam>object</defparam><defparam>&dots;</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>For each <var>object</var>, do <code>display</code> on it
and on <var>spacer</var>, as well.  Then, output a newline.
</para></definitionitem></deffn>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>augmenting</sectiontitle>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">interface-add!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>interface-add!</deffunction> <defparam>interface</defparam></definitionterm>
<definitionitem><para>Add <var>interface</var> to the list of known network interfaces.
You can get the list of known interfaces by running the shell
command <samp>serveez -i</samp>.  The <var>interface</var> argument must be in
dotted decimal form (e.g., <samp>127.0.0.1</samp>).  Serveez provides this
procedure for systems where it is unable to detect the list of
network interface automatically.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">loadpath-add!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>loadpath-add!</deffunction> <defdelimiter>[</defdelimiter><defparam>dir</defparam><defparam>&dots;</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Append <var>dir</var>&dots; to the server modules load path.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">serveez-load</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>serveez-load</deffunction> <defparam>filename</defparam></definitionterm>
<definitionitem><para>Try to load <var>filename</var> (via <code>primitive-load</code>).
If <var>filename</var> is not absolute, search for it
in the list of directories returned by <code>serveez-loadpath</code>.
Return <code>#t</code> if successful, <code>#f</code> otherwise.
</para></definitionitem></deffn>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>abstractions</sectiontitle>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">bind-servers!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>bind-servers!</deffunction> <defdelimiter>[</defdelimiter><defparam>args</defparam><defparam>&dots;</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Bind all servers and ports in <var>args</var> to each other.
This is a cross-product operation; given <var>s</var> servers, and
<var>p</var> ports, <code><var>s</var> * <var>p</var></code> bindings will be created.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">create-tcp-port!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>create-tcp-port!</deffunction> <defparam>basename</defparam> <defparam>port</defparam></definitionterm>
<definitionitem><para>Define a new TCP port named by concatenating
<var>basename</var> and <var>port</var>.  Return the new name.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">bind-tcp-port-range!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>bind-tcp-port-range!</deffunction> <defparam>from</defparam> <defparam>to</defparam> <defdelimiter>[</defdelimiter><defparam>servers</defparam><defparam>&dots;</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Bind the list of <var>servers</var> to simple TCP port configurations whose
network ports range between <var>from</var> and <var>to</var> both inclusive.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">create-udp-port!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>create-udp-port!</deffunction> <defparam>basename</defparam> <defparam>port</defparam></definitionterm>
<definitionitem><para>Define a new UDP port named by concatenating
<var>basename</var> and <var>port</var>.  Return the new name.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">bind-udp-port-range!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>bind-udp-port-range!</deffunction> <defparam>from</defparam> <defparam>to</defparam> <defdelimiter>[</defdelimiter><defparam>servers</defparam><defparam>&dots;</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Bind the list of <var>servers</var> to simple UDP port configurations whose
network ports range between <var>from</var> and <var>to</var> both inclusive.
</para></definitionitem></deffn>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>rpc</sectiontitle>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">getrpcent</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>getrpcent</deffunction></definitionterm>
<definitionitem><para>Return the next RPC entry as a vector of the form:
<code>#(<var>name</var> <var>aliases</var> <var>program-number</var>)</code>.
<var>name</var> is a symbol, <var>aliases</var> is a list (possibly empty)
of symbols, and <var>program-number</var> is an integer.
If the list is exhausted, return <code>#f</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">getrpcbyname</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>getrpcbyname</deffunction> <defparam>name</defparam></definitionterm>
<definitionitem><para>Return the RPC entry for <var>name</var>, a string.
(FIXME: Should be able to handle a symbol, too.)
If no such service exists, signal error.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">getrpcbynumber</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>getrpcbynumber</deffunction> <defparam>number</defparam></definitionterm>
<definitionitem><para>Return the RPC entry for <var>number</var>, an integer.
If no such service exists, signal error.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">setrpcent</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>setrpcent</deffunction> <defdelimiter>[</defdelimiter><defparam>stayopen</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Open and rewind the file <file>/etc/rpc</file>.
If optional arg <var>stayopen</var> (an integer) is non-zero,
the database will not be closed after each call to <code>getrpc</code>
(or its derivatives <code>getrpcent</code>, <code>getrpcbyname</code>,
<code>getrpcbynumber</code>).
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">endrpcent</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>endrpcent</deffunction></definitionterm>
<definitionitem><para>Close the file <file>/etc/rpc</file>.
</para></definitionitem></deffn>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>misc</sectiontitle>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">serveez-verbosity</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>serveez-verbosity</deffunction> <defdelimiter>[</defdelimiter><defparam>level</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Return the verbosity level (an integer).  Optional
arg <var>level</var> means set it to that level, instead.  This
setting is overridden by the command-line <samp>-v</samp> option.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">serveez-maxsockets</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>serveez-maxsockets</deffunction> <defdelimiter>[</defdelimiter><defparam>max</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Return the maximum number of open sockets permitted (an integer).
Optional arg <var>max</var> means set it to that number, instead.
This setting is overridden by the command-line <samp>-m</samp> option.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">serveez-passwd</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>serveez-passwd</deffunction> <defdelimiter>[</defdelimiter><defparam>pw</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Return the control password (a string).
Optional arg <var>pw</var> sets it to that, instead.  This effectively
does nothing if the control protocol is not enabled.
</para></definitionitem></deffn>

<para>We now have a closer look at the internals of Serveez.  If you
are not interested in that have a look at the existing
servers (<xref><xrefnodename>Existing servers</xrefnodename></xref>.).
</para>
</subsubsection>
</subsection>
</section>
</chapter>
<node name="Concept" spaces=" "><nodename>Concept</nodename><nodenext automatic="on">Server</nodenext><nodeprev automatic="on">Using Serveez</nodeprev><nodeup automatic="on">Top</nodeup></node>
<chapter spaces=" "><sectiontitle>Concept</sectiontitle>

<section spaces=" "><sectiontitle>Overall concept</sectiontitle>
<para>The primary functionality Serveez provides is a framework for Internet
services.  It can act as a kind of server collection and may even
replace super-servers such as the inetd daemon.
</para>
<para>Its key features and benefits are:
</para>
<itemize commandarg="bullet" spaces=" " endspaces=" "><itemprepend><formattingcommand command="bullet" /></itemprepend>
<listitem spaces=" "><prepend>&bullet;</prepend><para>support for packet and connection oriented protocols&linebreak;
Serveez currently supports two server types.  TCP and named pipe servers
are connection oriented servers.  This type of server accepts a client&textrsquo;s
connection request and communicates with it using a dedicated
connection.  The format of the incoming and outgoing data streams are
irrelevant to Serveez.  Packet oriented servers (like UDP and ICMP)
receive data packets and respond to the sender with data packets.  A
server in Serveez can detect whether it is bound to a packet or
connection oriented port configuration and thus can act as the expected
type.
</para>
</listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>server and client functionality&linebreak;
Besides a wide variety of server capabilities, Serveez also contains
some client functionality.  This may be necessary when a server is meant
to establish a connection to another server in response to an incoming
request.  For example, imagine a protocol where a client tells the
server, &textldquo;Let me be the server.  Please connect to this <var>host</var> at this
<var>port</var>&textrdquo;.  You are also able to implement pure clients.
</para>
</listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>platform portability&linebreak;
When writing this software the authors were always mindful of platform
portability.  Serveez compiles and runs on various Unix platforms as
well as on Windows systems.  <xref><xrefnodename>Porting issues</xrefnodename></xref>, for details.  Most
of the routines in the core library can be used without regard to the
platform on which you are programming or the details of its underlying
system calls.  Exceptions are noted in the documentation.  Platform
portability also means that the server code you write will run on other
systems, too.
</para>
</listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>powerful configuration capabilities&linebreak;
Server configuration has always been a complicated but very important
issue.  When Serveez starts up it runs the configuration file using the
programming language Guile.  In contradiction, other (server)
applications just read their configuration files and remember the
settings in it.  This makes them powerful enough to adapt the Serveez
settings dynamically.  Using the Guile interpreter also means that you
can split your configuration into separate files and load these, perhaps
conditionally, from the main configuration file.
</para>
</listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>easy server implementation&linebreak;
Serveez is a server framework.  When implementing a new server the
programmer need pay little or no attention to the networking code but is
free to direct his attention to the protocol the server is meant to
support.  That protocol may be an established one such as HTTP, or may
be a custom protocol fitting the specific application&textrsquo;s requirements.
The <ref><xrefnodename>Writing servers</xrefnodename></ref> section describes this process in detail.
</para>
</listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>code reusability&linebreak;
The Serveez package comes along with a core library (depending on the
system this is a static library, shared library or a DLL) and its API
which contains most of the functionality necessary to write an Internet
server.  Most probably, a programmer can also use the library for other
(network programming related) purposes.
</para>
</listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>server instantiation and network port sharing&linebreak;
Once you have written a protocol server and integrated into Serveez&textrsquo;s
concept of servers the user can instantiate (multiply) the server.  At
the first glimpse this sounds silly, but with different server
configurations it does not.  If, for example, an administrator wishes to
run multiple HTTP servers with different document roots, Serveez will
handle them all in a single process.  Also if the same administrator
wants to run a HTTP server and some other server on the same network
port this is possible with Serveez.  You can run a single server on
different network ports, too.
</para></listitem></itemize>

</section>
<section spaces=" "><sectiontitle>I/O Strategy</sectiontitle>
<para>Serveez&textrsquo;s I/O strategy is the traditional <code>select</code> method.  It is
serving many clients in a single server thread.  This is done by setting
all network handles to non-blocking mode.  We then use <code>select</code>
to tell which network handles have data waiting.  This is the
traditional Unix style multiplexing.
</para>
<para>An important bottleneck in this method is that a <code>read</code> or
<code>sendfile</code> from disk blocks if the data is not in core at the
moment.  Setting non-blocking mode on a disk file handle has no effect.
The same thing applies to memory-mapped disk files.  The first time a
server needs disk I/O, its process blocks, all clients have to wait, and
raw non-threaded performance may go to waste.
</para>
<para>Unfortunately, <code>select</code> is limited to the number of
<code>FD_SETSIZE</code> handles.  This limit is compiled into the standard
library, user programs and sometimes the kernel.  Nevertheless, Serveez
is able to serve about one thousand and more clients on GNU/Linux, a
hundred on Win95 and more on later Windows systems.
</para>
<para>We chose this method anyway because it seems to be the most portable.
</para>
<para>An alternative method to multiplex client network connections is
<code>poll</code>.  It is automatically used when <samp>configure</samp> finds
<code>poll</code> to be available.  This will work around the builtin (g)libc&textrsquo;s
<code>select</code> file descriptor limit.
</para>
<subsection spaces=" "><sectiontitle>Limits on open filehandles</sectiontitle>
<table commandarg="code" spaces=" " endspaces=" ">
<beforefirstitem>
</beforefirstitem><tableentry><tableterm><item spaces=" "><itemformat command="code">Any Unix</itemformat></item>
</tableterm><tableitem><para>The limits set by <code>ulimit</code> or <code>setrlimit</code>.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">Solaris</itemformat></item>
</tableterm><tableitem><para>See the Solaris FAQ, question 3.45.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">FreeBSD</itemformat></item>
</tableterm><tableitem><para>Use sysctl -w kern.maxfiles=nnnn to raise limit.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">GNU/Linux</itemformat></item>
</tableterm><tableitem><para>See Bodo Bauer&textrsquo;s /proc documentation.  On current 2.2.x kernels,
</para><example endspaces=" ">
<pre xml:space="preserve">echo 32768 &gt; /proc/sys/fs/file-max
</pre></example>
<para>increases the system limit on open files, and
</para><example endspaces=" ">
<pre xml:space="preserve">ulimit -n 32768
</pre></example>
<para>increases the current process&textrsquo; limit.  We verified that a process on
Linux kernel 2.2.5 (plus patches) can open at least 31000 file
descriptors this way.  It has also been verified that a process on
2.2.12 can open at least 90000 file descriptors this way (with
appropriate limits).  The upper bound seems to be available memory.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">Windows 9x/ME</itemformat></item>
</tableterm><tableitem><para>On Win9x machines, there is quite a low limit imposed by the kernel:
100 connections system wide (!).  You can increase this limit by editing
the registry key
HKLM\System\CurrentControlSet\Services\VxD\MSTCP\MaxConnections.
On Windows 95, the key is a DWORD; on Windows 98, it&textrsquo;s a string.
We have seen some reports of instability when this value is increased
to more than a few times its default value.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">Windows NT/2000</itemformat></item>
</tableterm><tableitem><para>More than 2000 connections tested.  It seems like the limit is due to
available physical memory.
</para></tableitem></tableentry></table>

</subsection>
</section>
<section spaces=" "><sectiontitle>Alternatives to Serveez&textrsquo;s I/O strategy</sectiontitle>
<para>One of the problems with the traditional <code>select</code> method with
non-blocking file descriptors occurs when passing a large number of
descriptors to the <code>select</code> system call.  The server loop then
goes through all the descriptors, decides which has pending data, then
reads and handles this data.  For a large number of connections (say,
90000) this results in temporary CPU load peaks even if there is no
network traffic.
</para>
<para>Along with this behaviour comes the problem of &textldquo;starving&textrdquo; connections.
Connections which reside at the beginning of the <code>select</code> set are
processed immediately while those at the end are processed significantly
later and may possibly die because of buffer overruns.  This is the
reason why Serveez features priority connection: it serves listening
sockets first and rolls the order of the remaining connections.  In this
way, non-priority connections are handled in a &textldquo;round robin&textrdquo; fashion.
</para>
<para>Other server implementations solve these problems differently.  Some
start a new process for each connection (fully-threaded server) or split
the <code>select</code> set into pieces and let different processes handle
them (threaded server).  This method shifts the priority scheduling to
the underlying operating system.  Another method is the use of
asynchronous I/O based upon signals where the server process receives a
signal when data arrives for a connection.  The signal handler queues
these events in order of arrival and the main server loop continuously
processes this queue.
</para>
</section>
</chapter>
<node name="Server" spaces=" "><nodename>Server</nodename><nodenext automatic="on">Coserver</nodenext><nodeprev automatic="on">Concept</nodeprev><nodeup automatic="on">Top</nodeup></node>
<chapter spaces=" "><sectiontitle>Server</sectiontitle>

<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::     ">Introduction to servers</menunode><menudescription><pre xml:space="preserve">Protocol servers in Serveez
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::             ">Writing servers</menunode><menudescription><pre xml:space="preserve">How to write Internet protocol servers
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::         ">Configuring servers</menunode><menudescription><pre xml:space="preserve">How do I configure an existing server ?
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::            ">Existing servers</menunode><menudescription><pre xml:space="preserve">Which kind of servers do we have already ?
</pre></menudescription></menuentry></menu>

<node name="Introduction-to-servers" spaces=" "><nodename>Introduction to servers</nodename><nodenext automatic="on">Writing servers</nodenext><nodeup automatic="on">Server</nodeup></node>
<section spaces=" "><sectiontitle>Introduction to servers</sectiontitle>

<para>Serveez is a kind of server server.  It allows different protocol
servers to listen on various TCP/UDP ports, on ICMP sockets and on named
pipes.  Servers are instantiated with a certain configuration.  It is
possible to run multiple different servers on the same port.
</para>
<para>This chapter covers all questions about how to write your own Internet
protocol server with this package.  Most of the common tasks of
such a server have got a generic solution (default routines) which could be
&textldquo;overridden&textrdquo; by your own routines.  There are some examples within this
package.  They are showing the possibilities with this package and how to
implement servers.
</para>
<para>The <samp>foo</samp> server does not do anything at all and is of no actual use
but could be a basis for a new protocol server.  We are now going to describe
how this specific server works.  Eventually the reader might get an
impression of what is going on.
</para>
<para>For better understanding the text below we will use the following
terminology:
</para><table commandarg="asis" spaces=" " endspaces=" ">
<beforefirstitem>
</beforefirstitem><tableentry><tableterm><item spaces=" "><itemformat command="asis">server definition</itemformat></item>
</tableterm><tableitem><para>A server definition is a <code>svz_servertype_t</code> structure which contains
server specific members like its name, different callbacks, a single default
configuration and a list of configuration items which determines what can be
configured.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">server configuration</itemformat></item>
</tableterm><tableitem><para>A server configuration can be any kind of structure.  The default server
configuration must be specified within the server definition (see above).
When instantiating a server (which is done via the configuration file) the
configuration items specified in the server definition get processed and
are put into a copy of the default configuration.  Thus we get an instance.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">server instance</itemformat></item>
</tableterm><tableitem><para>A server instance is a copy of the server definition including the modified
server configuration.  A server gets instantiated by the configuration file
parser.  The concept of server instances has been introduced because we
wanted Serveez to have the following features.  A single server can have
multiple instances with different behaviour due to different server
configurations.  A server instance can be bound to multiple port
configurations.  Different server instances (of the same and/or different
server type) can share the same port configuration.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">port configuration</itemformat></item>
</tableterm><tableitem><para>A port configuration in Serveez is represented by the <code>svz_portcfg_t</code>
structure.  Depending on a shared flag it contains different type of
information specifying a transport endpoint.  <xref><xrefnodename>Define ports</xrefnodename></xref>, for more
on this topic.  It also can be a special configuration item within a server
configuration.  This is necessary if a server needs for some reason a remote
transport endpoint.  A server instance does not usually need to know about
the port configuration it is bound to.
</para></tableitem></tableentry></table>

</section>
<node name="Writing-servers" spaces=" "><nodename>Writing servers</nodename><nodenext automatic="on">Configuring servers</nodenext><nodeprev automatic="on">Introduction to servers</nodeprev><nodeup automatic="on">Server</nodeup></node>
<section spaces=" "><sectiontitle>Writing servers</sectiontitle>

<para>Serveez is meant to be a server framework.  That is why it supports various
ways to implement Internet servers.  First of all there are some servers
already included in the main serveez package (<pxref><xrefnodename>Existing servers</xrefnodename></pxref>).
These are called <samp>Builtin servers</samp>.  Another possibility to add a new
server are <samp>Embedded servers</samp> which are shared libraries (or DLL&textrsquo;s)
containing the server implementation.  These can be dynamically loaded by
Serveez at runtime.  This kind of server is also called <samp>Server modules</samp>.
A third possibility are the <samp>Guile servers</samp> which allow even
unexperienced schemers to write an Internet server.
</para>
<para>This section describes each of the above possibilities in detail.
</para>
<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::    ">Embedded servers</menunode><menudescription><pre xml:space="preserve">How to write dynamic server modules
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::       ">Guile servers</menunode><menudescription><pre xml:space="preserve">Servers using Serveez&textrsquo;s guile interface
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::     ">Builtin servers</menunode><menudescription><pre xml:space="preserve">Servers located in the main project
</pre></menudescription></menuentry></menu>

<node name="Embedded-servers" spaces=" "><nodename>Embedded servers</nodename><nodenext automatic="on">Guile servers</nodenext><nodeup automatic="on">Writing servers</nodeup></node>
<subsection spaces=" "><sectiontitle>Embedded servers</sectiontitle>

<para>The core library of Serveez can be used to write standalone server modules.
Serveez defines a certain interface for shared libraries which contain
such server modules.  If Serveez detects an unknown server type (server type
which is not builtin) in its configuration file it tries to load a shared
library containing this server type during startup.
</para>
<subsubsection spaces=" "><sectiontitle>Prerequisites</sectiontitle>

<para>In order to implement a server module you need an existing installation
of Serveez.  This can be achieved issuing the following commands:
</para>
<example endspaces=" ">
<pre xml:space="preserve">$ ./configure --enable-shared --prefix=/usr/local
$ make
$ make install
</pre></example>

<para>After successful installation you are able to compile and link against the
Serveez core API.  The headers should be available in <file>/usr/local/include</file>
and the library itself (<file>libserveez.so</file> or <file>libserveez.dll</file>) is
located in <file>/usr/local/lib</file> if you passed the configure script
<samp>--prefix=/usr/local</samp>.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Server definition</sectiontitle>

<para>The interface mentioned in the introduction is defined via the extern
declaration of the server type in the shared library of the server module.
Imagine you want to implement a server type called <samp>foo</samp>.  This requires
the external symbol <code>foo_server_definition</code> in the shared library.
You can achieve this inserting the following lines into your header file:
</para>
<example endspaces=" ">
<pre xml:space="preserve">/* Either Unices.  */
extern svz_servertype_t foo_server_definition;

/* Or Windows.  */
__declspec (dllexport) extern svz_servertype_t foo_server_definition;
</pre></example>

<para>The data symbol <code>foo_server_definition</code> must be statically filled with
the proper content (<xref><xrefnodename>Builtin servers</xrefnodename></xref>.)
</para>
</subsubsection>
</subsection>
<node name="Guile-servers" spaces=" "><nodename>Guile servers</nodename><nodenext automatic="on">Builtin servers</nodenext><nodeprev automatic="on">Embedded servers</nodeprev><nodeup automatic="on">Writing servers</nodeup></node>
<subsection spaces=" "><sectiontitle>Guile servers</sectiontitle>

<!-- c -*-texinfo-*- -->
<!-- c -->
<!-- c This file includes the documentation about the Guile servers.  It is -->
<!-- c included by `serveez.texi'. -->
<!-- c -->

<para>This section describes the Guile interface to Serveez which provides
the ability to write servers with Guile.  Of course, you could do this
without any help from Serveez, but it makes the task a lot easier.
This interface reduces the Guile implementation of an Internet server
to a simple data processor.
</para>
<subsubsection spaces=" "><sectiontitle>Underlying libserveez</sectiontitle>

<set name="TSINCURMOD" line=" TSINCURMOD (guile)">(guile)</set>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">libserveez-features</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>libserveez-features</deffunction></definitionterm>
<definitionitem><para>Return a list of symbols representing the features of the underlying
libserveez.  For details, <xref><xrefnodename>Library features</xrefnodename></xref>.
</para></definitionitem></deffn>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>Special Data Types</sectiontitle>

<para>Serveez extends Guile by various new data types which represent internal
data structures of Serveez&textrsquo;s core API.
</para>
<itemize commandarg="bullet" spaces=" " endspaces=" "><itemprepend><formattingcommand command="bullet" /></itemprepend>
<listitem spaces=" "><prepend>&bullet;</prepend><para><code>#&lt;svz-servertype&gt;</code>
represents a server type.
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para><code>#&lt;svz-server&gt;</code>
represents a server (an instance of a server type).
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para><code>#&lt;svz-socket&gt;</code>
represents a socket structure.
</para></listitem></itemize>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>Passing Binary Data</sectiontitle>

<para>The new binary data type (<code>#&lt;svz-binary&gt;</code>) provides access to any
kind of unstructured data.  It manages the data exchange between Guile
and Serveez.  There are some conversion procedures for strings and lists
which help to process this binary data in a more complex (guile&textrsquo;ish) way.
</para>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-&gt;string</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-&gt;string</deffunction> <defparam>binary</defparam></definitionterm>
<definitionitem><para>Convert the given binary smob <var>binary</var> into a string.
Return the string itself.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">string-&gt;binary</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>string-&gt;binary</deffunction> <defparam>string</defparam></definitionterm>
<definitionitem><para>Convert the given <var>string</var> into a binary smob.  The data pointer of
the binary smob is marked as garbage which must be <code>free</code>&textrsquo;d in the
sweep phase of the garbage collector.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary?</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary?</deffunction> <defparam>obj</defparam></definitionterm>
<definitionitem><para>Return <code>#t</code> if <var>obj</var> is an instance of the binary smob type.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">list-&gt;binary</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>list-&gt;binary</deffunction> <defparam>list</defparam></definitionterm>
<definitionitem><para>Convert the scheme list <var>list</var> into a binary smob.  Each of the
elements of <var>list</var> is checked for validity.  The elements can be
either exact numbers in a byte&textrsquo;s range or characters.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-&gt;list</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-&gt;list</deffunction> <defparam>binary</defparam></definitionterm>
<definitionitem><para>Convert the given binary smob <var>binary</var> into a scheme list.  The list
is empty if the size of <var>binary</var> is zero.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-search</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-search</deffunction> <defparam>binary</defparam> <defparam>needle</defparam></definitionterm>
<definitionitem><para>Search through the binary smob <var>binary</var> for <var>needle</var>,
which can be an exact number, character,
string or another binary smob.  Return <code>#f</code> if the needle could
not be found, or a positive number indicating the position of the first
occurrence of <var>needle</var> in the binary smob <var>binary</var>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-set!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-set!</deffunction> <defparam>binary</defparam> <defparam>index</defparam> <defparam>value</defparam></definitionterm>
<definitionitem><para>Set the byte at position <var>index</var> of the binary smob <var>binary</var> to
the value given in <var>value</var> which can be either a character or an
exact number.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-ref</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-ref</deffunction> <defparam>binary</defparam> <defparam>index</defparam></definitionterm>
<definitionitem><para>Obtain the byte at position <var>index</var> of the binary smob
<var>binary</var>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-length</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-length</deffunction> <defparam>binary</defparam></definitionterm>
<definitionitem><para>Return the size in bytes of the binary smob <var>binary</var>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-concat!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-concat!</deffunction> <defparam>binary</defparam> <defparam>append</defparam></definitionterm>
<definitionitem><para>Append either the binary smob or string <var>append</var> onto the binary
smob <var>binary</var>.  If <var>binary</var> has been a simple data pointer
reference it is then a standalone binary smob as returned by
<code>string-&gt;binary</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-subset</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-subset</deffunction> <defparam>binary</defparam> <defparam>start</defparam> <defdelimiter>[</defdelimiter><defparam>end</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Create a subset binary smob from the given binary smob <var>binary</var>.  The
range of this subset is specified by <var>start</var> and <var>end</var> both
inclusive (thus the resulting size is <code><var>end</var> - <var>start</var> + 1</code>).
With a single exception: If <var>end</var> is not given or specified with -1,
return all data until the end of <var>binary</var>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-reverse</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-reverse</deffunction> <defparam>binary</defparam></definitionterm>
<definitionitem><para>Return a new binary smob with the reverse byte order of the given
binary smob <var>binary</var>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-reverse!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-reverse!</deffunction> <defparam>binary</defparam></definitionterm>
<definitionitem><para>Perform an in-place reversal of the given binary smob <var>binary</var>
and return it.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-long-ref</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-long-ref</deffunction> <defparam>binary</defparam> <defparam>index</defparam></definitionterm>
<definitionitem><para>Return the <code>long</code> value of the binary
smob <var>binary</var> at the array index <var>index</var>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-long-set!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-long-set!</deffunction> <defparam>binary</defparam> <defparam>index</defparam> <defparam>value</defparam></definitionterm>
<definitionitem><para>Set the <code>long</code> value of the binary smob <var>binary</var>
at the array index <var>index</var> to the given value <var>value</var>.
Return the previous (overridden) value.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-int-ref</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-int-ref</deffunction> <defparam>binary</defparam> <defparam>index</defparam></definitionterm>
<definitionitem><para>Return the <code>int</code> value of the binary
smob <var>binary</var> at the array index <var>index</var>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-int-set!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-int-set!</deffunction> <defparam>binary</defparam> <defparam>index</defparam> <defparam>value</defparam></definitionterm>
<definitionitem><para>Set the <code>int</code> value of the binary smob <var>binary</var>
at the array index <var>index</var> to the given value <var>value</var>.
Return the previous (overridden) value.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-short-ref</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-short-ref</deffunction> <defparam>binary</defparam> <defparam>index</defparam></definitionterm>
<definitionitem><para>Return the <code>short</code> value of the binary
smob <var>binary</var> at the array index <var>index</var>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-short-set!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-short-set!</deffunction> <defparam>binary</defparam> <defparam>index</defparam> <defparam>value</defparam></definitionterm>
<definitionitem><para>Set the <code>short</code> value of the binary smob <var>binary</var>
at the array index <var>index</var> to the given value <var>value</var>.
Return the previous (overridden) value.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-char-ref</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-char-ref</deffunction> <defparam>binary</defparam> <defparam>index</defparam></definitionterm>
<definitionitem><para>Return the <code>char</code> value of the binary
smob <var>binary</var> at the array index <var>index</var>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">binary-char-set!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>binary-char-set!</deffunction> <defparam>binary</defparam> <defparam>index</defparam> <defparam>value</defparam></definitionterm>
<definitionitem><para>Set the <code>char</code> value of the binary smob <var>binary</var>
at the array index <var>index</var> to the given value <var>value</var>.
Return the previous (overridden) value.
</para></definitionitem></deffn>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>Server Definition</sectiontitle>

<para>In order to set up a new server type, you use the procedure
<code>define-servertype!</code>.  This procedure takes one argument which
must be an associative list specifying the server type in detail.
There are optional and mandatory elements you can set up in this alist.
</para>
<para>The following example shows the overall syntax of this procedure:
</para>
<lisp endspaces=" ">
<pre xml:space="preserve">(define-servertype! '(

  ;; Mandatory: server type prefix for later use in (define-server!)
  (prefix          . &quot;foo&quot;)

  ;; Mandatory: server type description
  (description     . &quot;guile foo server&quot;)

  ;; Mandatory for TCP and PIPE servers: protocol detection
  (detect-proto    . foo-detect-proto)

  ;; Optional: global server type initialisation
  (global-init     . foo-global-init)

  ;; Optional: server instance initialisation
  (init            . foo-init)

  ;; Optional: server instance finalisation
  (finalize        . foo-finalize)

  ;; Optional: global server type finalisation
  (global-finalize . foo-global-finalize)

  ;; Mandatory for TCP and PIPE servers: socket connection
  (connect-socket  . foo-connect-socket)

  ;; Optional: server instance info
  (info-server     . foo-info-server)

  ;; Optional: client info
  (info-client     . foo-info-client)

  ;; Optional: server instance reset callback
  (reset           . foo-reset)

  ;; Optional: server instance notifier
  (notify          . foo-notify)

  ;; Mandatory for UDP and ICMP servers: packet handler
  (handle-request  . foo-handle-request)

  ;; Mandatory: server type configuration (may be an empty list)
  (configuration   . (

    ;; The server configuration is an alist (associative list) again.
    ;; Each item consists of an item name and a list describing the
    ;; item itself.
    ;; Syntax: (key . (type defaultable default))
    (foo-integer       . (integer  #t 0))
    (foo-integer-array . (intarray #t (1 2 3 4 5)))
    (foo-string        . (string   #t &quot;default-foo-string&quot;))
    (foo-string-array  . (strarray #t (&quot;guile&quot; &quot;foo&quot; &quot;server&quot;)))
    (foo-hash          . (hash     #t ((&quot;foo&quot; . &quot;bar&quot;))))
    (foo-port          . (portcfg  #t foo-port))
    (foo-boolean       . (boolean  #t #t))
  ))))
</pre></lisp>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">define-servertype!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>define-servertype!</deffunction> <defparam>args</defparam></definitionterm>
<definitionitem><para>Define a new server type based on <var>args</var>.  (If everything
works fine you have a freshly registered server type afterwards.)
Return <code>#t</code> on success.
</para></definitionitem></deffn>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>Predefined Procedures</sectiontitle>

<para>The following subset of procedures may be used to implement a Guile
server.  They should be used within the callbacks defined in the
<code>define-servertype!</code> procedure.  Each of these callbacks gets
passed the appropriate arguments needed to stuff into the following
procedures.  Please have a look at the example Guile servers for the
details.
</para>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock?</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock?</deffunction> <defparam>sock</defparam></definitionterm>
<definitionitem><para>Return <code>#t</code> if the given cell <var>sock</var> is an instance of a valid
<code>#&lt;svz-socket&gt;</code>, otherwise <code>#f</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:check-request</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:check-request</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>proc</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Set the <code>check-request</code> member of the socket structure <var>sock</var>
to <var>proc</var>.  Return the previously handler if there is any.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:check-oob-request</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:check-oob-request</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>proc</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Set the <code>check-oob-request</code> callback of the given socket
structure <var>sock</var> to <var>proc</var>, returning
the previous callback (if there was any set before).
The callback is run whenever urgent data (out-of-band)
has been detected on the socket.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:send-oob</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:send-oob</deffunction> <defparam>sock</defparam> <defparam>oob</defparam></definitionterm>
<definitionitem><para>Send byte <var>oob</var> as urgent (out-of-band) data through the
underlying TCP stream of TCP <var>sock</var>.
Return <code>#t</code> on successful completion and otherwise
(either it failed to send the byte or the passed socket is not a TCP
socket) <code>#f</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:handle-request</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:handle-request</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>proc</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Set the <code>handle-request</code> member of the socket structure <var>sock</var>
to <var>proc</var>.  Return the previously set handler if there is any.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:boundary</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:boundary</deffunction> <defparam>sock</defparam> <defparam>boundary</defparam></definitionterm>
<definitionitem><para>Setup the packet boundary of the socket <var>sock</var>.  The given string
value <var>boundary</var> can contain any kind of data.  If <var>boundary</var>
is an exact number, set up the socket to parse fixed sized packets.
More precisely, set the <code>check-request</code> callback of the given
socket structure <var>sock</var> to an internal routine which runs the
socket&textrsquo;s <code>handle-request</code> callback when it detects a
complete packet specified by <var>boundary</var>.
</para>
<para>For instance, you can arrange for Serveez to pass the
<code>handle-request</code> procedure lines of text by calling
<code>(svz:sock:boundary sock &quot;\n&quot;)</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:floodprotect</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:floodprotect</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>flag</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Set or unset the flood protection bit of the given socket <var>sock</var>.
Return the previous value of this bit (<code>#t</code> or <code>#f</code>).  The
<var>flag</var> argument must be either boolean or an exact number and is
optional.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:print</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:print</deffunction> <defparam>sock</defparam> <defparam>buffer</defparam></definitionterm>
<definitionitem><para>Write <var>buffer</var> (string or binary smob) to the socket <var>sock</var>.
Return <code>#t</code> on success and <code>#f</code> on failure.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:final-print</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:final-print</deffunction> <defparam>sock</defparam></definitionterm>
<definitionitem><para>Schedule the socket <var>sock</var> for shutdown after all data
within the send buffer queue has been sent.  You should call this
right <strong>before</strong> the last call to <code>svz:sock:print</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:no-delay</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:no-delay</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>enable</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Turn the Nagle algorithm for the TCP socket <var>sock</var> on or off depending
on the optional <var>enable</var> argument.  Return the previous state of this
flag (<code>#f</code> if Nagle is active, <code>#t</code> otherwise).  By default this
flag is switched off.  This socket option is useful when dealing with small
packet transfer in order to disable unnecessary delays.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:send-buffer</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:send-buffer</deffunction> <defparam>sock</defparam></definitionterm>
<definitionitem><para>Return the send buffer of the
socket <var>sock</var> as a binary smob.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:send-buffer-size</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:send-buffer-size</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>size</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Return the current send buffer size and fill status in
bytes of the socket <var>sock</var> as a pair of exact numbers.  If the
optional argument <var>size</var> is given, set the send buffer to
the specified size in bytes.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:receive-buffer</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:receive-buffer</deffunction> <defparam>sock</defparam></definitionterm>
<definitionitem><para>Return the receive buffer of the
socket <var>sock</var> as a binary smob.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:receive-buffer-size</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:receive-buffer-size</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>size</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Return the current receive buffers size and fill status in bytes of
the socket <var>sock</var> as a pair of exact numbers.  If the optional
argument <var>size</var> is given, set the receive buffer to the
specified size in bytes.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:receive-buffer-reduce</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:receive-buffer-reduce</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>length</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Dequeue <var>length</var> bytes from the receive buffer of the
socket <var>sock</var>, or all bytes if <var>length</var> is omitted.
Return the number of bytes actually shuffled away.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:connect</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:connect</deffunction> <defparam>host</defparam> <defparam>proto</defparam> <defdelimiter>[</defdelimiter><defparam>port</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Establish a network connection to the given <var>host</var> [ :<var>port</var> ].
If <var>proto</var> equals <code>PROTO_ICMP</code> the <var>port</var> argument is
ignored.  Valid identifiers for <var>proto</var> are <code>PROTO_TCP</code>,
<code>PROTO_UDP</code> and <code>PROTO_ICMP</code>.  The <var>host</var> argument must be
either a string in dotted decimal form, a valid hostname or an exact number
in host byte order.  When giving a hostname this operation might block.
The <var>port</var> argument must be an exact number in the range from
0 to 65535, also in host byte order.  Return a valid <code>#&lt;svz-socket&gt;</code>
or <code>#f</code> on failure.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:disconnected</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:disconnected</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>proc</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Set the <code>disconnected-socket</code> member of the socket structure
<var>sock</var> to <var>proc</var>.  The given callback
runs whenever the socket is lost for some external reason.
Return the previously set handler if there is one.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:kicked</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:kicked</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>proc</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Set the <code>kicked-socket</code> callback of the given socket structure
<var>sock</var> to <var>proc</var> and return any previously
set procedure.  This callback gets called whenever the socket gets
closed by Serveez intentionally.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:trigger</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:trigger</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>proc</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Set the <code>trigger</code> callback of the socket structure <var>sock</var> to
<var>proc</var> and return any previously set procedure.
The callback is run when the <code>trigger-condition</code> callback returns
<code>#t</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:trigger-condition</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:trigger-condition</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>proc</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Set the <code>trigger-condition</code> callback for the socket
structure <var>sock</var> to <var>proc</var>.  Return the
previously set procedure if available.  The callback is run once every
server loop indicating whether the <code>trigger</code> callback should be
run or not.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:idle</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:idle</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>proc</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Set the <code>idle</code> callback of the socket structure
<var>sock</var> to <var>proc</var>.  Return any previously
set procedure.  The callback is run by the periodic task scheduler when the
<code>idle-counter</code> of the socket structure drops to zero.  If this counter
is not zero it gets decremented once a second.  The <code>idle</code>
callback can reset <code>idle-counter</code> to some value and thus can
re-schedule itself for a later task.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:idle-counter</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:idle-counter</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>counter</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Return the socket structure <var>sock</var>&textrsquo;s current
<code>idle-counter</code> value.  If the optional argument <var>counter</var> is
given, the set the <code>idle-counter</code>.  Please have a look at the
<code>svz:sock:idle</code> procedure for the exact meaning of this value.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:data</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:data</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>data</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Associate any kind of data (any object) given in the argument
<var>data</var> with the socket <var>sock</var>.  The <var>data</var> argument is
optional.  Return a previously stored value or an empty list.
[Do not use; will be deleted; use object properties, instead.  &textndash;ttn]
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:parent</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:parent</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>parent</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Return the given socket&textrsquo;s <var>sock</var> parent and optionally set it to the
socket <var>parent</var>.  Return either a valid
<code>#&lt;svz-socket&gt;</code> object or an empty list.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:referrer</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:referrer</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>referrer</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Return the given socket&textrsquo;s <var>sock</var> referrer and optionally set it to the
socket <var>referrer</var>.  Return either a valid
<code>#&lt;svz-socket&gt;</code> or an empty list.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:server</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:server</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>server</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Return the <code>#&lt;svz-server&gt;</code> object associated with the
given argument <var>sock</var>.  The optional argument <var>server</var> can be used
to redefine this association and must be a valid <code>#&lt;svz-server&gt;</code>
object.  For a usual socket callback like <code>connect-socket</code> or
<code>handle-request</code>, the association is already in place.  But for sockets
created by <code>svz:sock:connect</code>, you can use it in order to make the
returned socket object part of a server.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:local-address</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:local-address</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>address</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Return the current local address as a pair like
<code>(host . port)</code> with both entries in network byte order.  If you pass
the optional argument <var>address</var>, you can set the local address of
the socket <var>sock</var>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:remote-address</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:remote-address</deffunction> <defparam>sock</defparam> <defdelimiter>[</defdelimiter><defparam>address</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Return the current remote address as a pair like
<code>(host . port)</code> with both entries in network byte order.  If you pass
the optional argument <var>address</var>, you can set the remote address of
the socket <var>sock</var>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:find</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:find</deffunction> <defparam>ident</defparam></definitionterm>
<definitionitem><para>Return the <code>#&lt;svz-socket&gt;</code> specified by <var>ident</var>,
a pair of integers in the form <code>(identification . version)</code>.
If that socket no longer exists, return <code>#f</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:ident</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:ident</deffunction> <defparam>sock</defparam></definitionterm>
<definitionitem><para>Return a pair of numbers identifying the given
<code>#&lt;svz-socket&gt;</code> <var>sock</var>, which can be passed to
<code>svz:sock:find</code>.  This may be necessary when you are passing
a <code>#&lt;svz-socket&gt;</code> through coserver callback arguments in order to
verify that the passed <code>#&lt;svz-socket&gt;</code> is still valid when the
coserver callback runs.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:sock:protocol</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:sock:protocol</deffunction> <defparam>sock</defparam></definitionterm>
<definitionitem><para>Return one of the <code>PROTO_TCP</code>, <code>PROTO_UDP</code>, <code>PROTO_ICMP</code>,
<code>PROTO_RAW</code> or <code>PROTO_PIPE</code> constants indicating the type of
the socket structure <var>sock</var>.  If there is no protocol information
available, return <code>#f</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:read-file</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:read-file</deffunction> <defparam>port</defparam> <defparam>size</defparam></definitionterm>
<definitionitem><para>Return either a binary smob containing a data block read
from the open input port <var>port</var> with a maximum number of <var>size</var>
bytes, or the end-of-file object if the underlying ports end has been
reached.  The size of the returned binary smob may be less than the
requested size <var>size</var> if it exceed the current size of the given port
<var>port</var>.  Throw an exception if an error occurred while
reading from the port.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:server?</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:server?</deffunction> <defparam>server</defparam></definitionterm>
<definitionitem><para>Return <code>#t</code> if the given cell <var>server</var> is an instance of a valid
<code>#&lt;svz-server&gt;</code>, otherwise <code>#f</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:server:listeners</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:server:listeners</deffunction> <defparam>server</defparam></definitionterm>
<definitionitem><para>Return a list of listening <code>#&lt;svz-socket&gt;</code> smobs to which the
given server instance <var>server</var> is currently bound, or an empty list
if there is no such binding yet.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:server:clients</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:server:clients</deffunction> <defparam>server</defparam></definitionterm>
<definitionitem><para>Return a list of <code>#&lt;svz-socket&gt;</code> client smobs associated with
the given server instance <var>server</var> in arbitrary order, or an
empty list if there is no such client.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:server:config-ref</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:server:config-ref</deffunction> <defparam>server</defparam> <defparam>key</defparam></definitionterm>
<definitionitem><para>Return the configuration item specified by <var>key</var> of the given server
instance <var>server</var>.  You can pass this procedure a socket, too, in
which case the appropriate server instance is looked up.  If the given
string <var>key</var> is invalid (not defined in the configuration alist in
<code>define-servertype!</code>), then return an empty list.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:server:state-set!</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:server:state-set!</deffunction> <defparam>server</defparam> <defparam>key</defparam> <defparam>value</defparam></definitionterm>
<definitionitem><para>Associate the Guile object <var>value</var> with the string <var>key</var>.  The
given <var>server</var> argument can be both, a <code>#&lt;svz-server&gt;</code> or a
<code>#&lt;svz-socket&gt;</code>.  Return the previously associated object or an
empty list if there was no such association.  This procedure is useful
for server instance state savings.  [Actually, it is superfluous since
Guile provides object properties and closures.  Probably this procedure
will be deleted soon. &textmdash;ttn]
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:server:state-ref</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:server:state-ref</deffunction> <defparam>server</defparam> <defparam>key</defparam></definitionterm>
<definitionitem><para>Return the Guile object associated with the string value <var>key</var> which
needs to be have been set via <code>svz:server:state-set!</code> previously.
Otherwise return an empty list.  The given <var>server</var> argument must be
either a valid <code>#&lt;svz-server&gt;</code> object or a <code>#&lt;svz-socket&gt;</code>.
[NB: See comment in <code>svz:server:state-set!</code>. &textmdash;ttn]
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:server:state-&gt;hash</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:server:state-&gt;hash</deffunction> <defparam>server</defparam></definitionterm>
<definitionitem><para>Convert the <var>server</var> instance&textrsquo;s state into a Guile hash.
Return an empty list if there is no such state yet.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">serveez-port?</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>serveez-port?</deffunction> <defparam>name</defparam></definitionterm>
<definitionitem><para>Return <code>#t</code> if the given string <var>name</var> corresponds with a
registered port configuration, otherwise <code>#f</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">serveez-server?</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>serveez-server?</deffunction> <defparam>name</defparam></definitionterm>
<definitionitem><para>Check whether the given string <var>name</var> corresponds with an
instantiated server name and return <code>#t</code> if so.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">serveez-servertype?</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>serveez-servertype?</deffunction> <defparam>name</defparam></definitionterm>
<definitionitem><para>Check whether the given string <var>name</var> is a valid
server type prefix known in Serveez and return <code>#t</code> if so.
Otherwise return <code>#f</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">serveez-exceptions</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>serveez-exceptions</deffunction> <defdelimiter>[</defdelimiter><defparam>enable</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Control the use of exception handlers for the Guile procedure calls of
Guile server callbacks.  If the optional argument <var>enable</var> is
<code>#t</code>, enable exception handling; if <code>#f</code>, disable it.
Return the current (boolean) setting.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">serveez-nuke</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>serveez-nuke</deffunction> <defdelimiter>[</defdelimiter><defparam>exit-value</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Shutdown all network connections and terminate after the next event
loop.  You should use this instead of calling <code>quit</code>.
Optional arg <var>exit-value</var> specifies an exit value for the
serveez program.  It is mapped to a number via <code>scm_exit_value</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">serveez-loadpath</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>serveez-loadpath</deffunction> <defdelimiter>[</defdelimiter><defparam>args</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Make the search path for the Serveez core library accessible to Scheme.
Return a list a each path as previously defined.  If <var>args</var> is specified,
override the current definition of this load path with it.
The load path is used to tell Serveez where
it can find additional server modules.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">serveez-interfaces</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>serveez-interfaces</deffunction> <defdelimiter>[</defdelimiter><defparam>args</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Make the list of local interfaces accessible to Scheme.  Return the
local interfaces as a list of ip addresses in dotted decimal form.  If
<var>args</var> are specified, they are added as additional local interfaces.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">getrpc</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>getrpc</deffunction> <defdelimiter>[</defdelimiter><defparam>arg</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Lookup a network rpc service <var>arg</var> (name or service number),
and return a network rpc service object.
If given no arguments, it behave like <code>getrpcent</code>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">setrpc</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>setrpc</deffunction> <defdelimiter>[</defdelimiter><defparam>stayopen</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Open and rewind the file <file>/etc/rpc</file>.
If the <var>stayopen</var> flag is non-zero, the net data base will not be
closed after each call to <code>getrpc</code>.  If <var>stayopen</var> is omitted,
this is equivalent to calling <code>endrpcent</code>.  Otherwise it is
equivalent to calling <code>setrpcent</code> with arg 1.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">portmap</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>portmap</deffunction> <defparam>prognum</defparam> <defparam>versnum</defparam> <defdelimiter>[</defdelimiter><defparam>protocol</defparam> <defdelimiter>[</defdelimiter><defparam>port</defparam><defdelimiter>]</defdelimiter><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Establish a (portmap service) mapping
between the triple [<var>prognum</var>,<var>versnum</var>,<var>protocol</var>] and
<var>port</var> on the machine&textrsquo;s portmap service.  The value of <var>protocol</var>
is most likely <code>IPPROTO_UDP</code> or <code>IPPROTO_TCP</code>.
If instead <var>protocol</var> and <var>port</var> are omitted, destroy
all mapping between the triple [<var>prognum</var>,<var>versnum</var>,*] and ports
on the machine&textrsquo;s portmap service.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">portmap-list</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>portmap-list</deffunction> <defdelimiter>[</defdelimiter><defparam>address</defparam><defdelimiter>]</defdelimiter></definitionterm>
<definitionitem><para>Return a list of the current RPC program-to-port mappings
on the host located at IP address <var>address</var>, which
defaults to the local machine&textrsquo;s IP address.
Return an empty list if either there is no such list
available or an error occurred while fetching the list.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:coserver:dns</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:coserver:dns</deffunction> <defparam>host</defparam> <defparam>callback</defparam></definitionterm>
<definitionitem><para>Enqueue the <var>host</var> string argument into the internal
DNS coserver queue.  When the coserver responds, the procedure
<var>callback</var> is run as <code>(callback addr)</code>.  The <var>addr</var>
argument passed to the callback is a string representing the appropriate
IP address for the given hostname <var>host</var>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:coserver:reverse-dns</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:coserver:reverse-dns</deffunction> <defparam>addr</defparam> <defparam>callback</defparam></definitionterm>
<definitionitem><para>Enqueue the given <var>addr</var> argument, which must be
an IP address in network byte order, into the internal reverse DNS coserver
queue.  When the coserver responds, the procedure <var>callback</var> is
run as <code>(callback host)</code> where <var>host</var> is the hostname of the
requested IP address <var>addr</var>.
</para></definitionitem></deffn>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz:coserver:ident</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>svz:coserver:ident</deffunction> <defparam>sock</defparam> <defparam>callback</defparam></definitionterm>
<definitionitem><para>Enqueue the given <code>#&lt;svz-socket&gt;</code> <var>sock</var> into the
internal ident coserver queue.  When the coserver responds, it
runs the procedure <var>callback</var> as <code>(callback user)</code>, where
<var>user</var> is the corresponding username for the client connection
<var>sock</var>.
</para></definitionitem></deffn>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>Callback Prototypes</sectiontitle>

<para>The Guile interface of Serveez is completely callback driven.
Callbacks can be set up in the associative list passed to
<code>define-servertype!</code>, or by using the predefined procedures
described in the previous section.  Each of the callbacks is passed
certain arguments and is meant to return specific values to indicate
success or failure.  This section describes each of these callbacks.
</para>
<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">global-init</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>global-init</deffunction> <defparam>servertype</defparam></definitionterm>
<definitionitem><para>This callback is invoked once for every type of server right after
the <code>define-servertype!</code> statement.  Here you can initialise
resources shared between all instances of your server type.  The callback
is optional and can be set up in <code>define-servertype!</code>.  It should
return zero to indicate success and non-zero to indicate failure.  If the
global initialiser fails, Serveez will refuse to register the server type.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">global-finalize</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>global-finalize</deffunction> <defparam>servertype</defparam></definitionterm>
<definitionitem><para>If you want to free shared resources, which were possibly allocated
within the global initialiser, you can do so here.  The callback is
invoked when Serveez shuts down (issued by <code>serveez-nuke</code>) or the
server type gets unregistered for some reason.  It should return zero to
signal success.  The callback can be set up in <code>define-servertype!</code>
and is optional.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">init</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>init</deffunction> <defparam>server</defparam></definitionterm>
<definitionitem><para>Within this callback you can initialise everything you might need for
a single instance of your server.  The callback is invoked for each
server instance which has been created by <code>define-server!</code> and
should return zero to indicate success, otherwise Serveez rejects the
server instance.  The callback can be set up in <code>define-servertype!</code>
and is optional.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">finalize</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>finalize</deffunction> <defparam>server</defparam></definitionterm>
<definitionitem><para>The server instance finaliser gets its instance representation passed
as argument.  You need to free all resources used by this server
instance which might have been allocated within the server instance
initialiser or consumed while running.  You can set this callback in
the <code>define-servertype!</code> statement.  The callback is optional
and should return zero to indicate success.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">detect-proto</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>detect-proto</deffunction> <defparam>server</defparam> <defparam>socket</defparam></definitionterm>
<definitionitem><para>Connection oriented protocols like TCP and PIPE allow more than one
server to be listening on the same network port.  Therefore, it is
necessary to be able to detect the type of client connecting to a port.
</para>
<para>This callback takes two arguments; the first is the server instance
and the second is the client socket object containing the client
connection information.  You can set up this callback in the
<code>define-servertype!</code> statement.
</para>
<para>Serveez may invoke this callback several times as data becomes
available from the client until one of the servers recognises it.
The servers can retrieve the data received so far using the
<code>svz:sock:receive-buffer</code> call.
</para>
<para>To indicate successful client detection, you need to return a non-zero
value.  (Note that for historical reasons, this is inconsistent with
other procedures which return zero on successful completion.)  Once the
server has indicated success, Serveez invokes any further callbacks for
the connection only on that server.
</para>
<para>If no server has recognised the client after the first 16 bytes, Serveez
will close the connection.  The connection will also be closed if the
client has not sent enough data for a server to recognise it within 30
seconds of connecting.
</para>
<para>If multiple servers are listening on the same network port, Serveez
invokes this callback for each of them in an arbitrary order.  Only one
server at most should indicate successful detection.
</para>
<para>This callback is mandatory for servers which get bound to
connection oriented protocol (TCP and PIPE) port configurations by
<code>bind-server!</code>.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">connect-socket</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>connect-socket</deffunction> <defparam>server</defparam> <defparam>socket</defparam></definitionterm>
<definitionitem><para>If the client detection signalled success, this callback is invoked to
assign the client connection to a server instance.  The arguments are
the same as the detection callback.  In this callback you can assign
all the connection specific callbacks for your server and perform some
initial tasks.  Basically you should specify the <code>handle-request</code>
and/or <code>check-request</code> callback.  This can be achieved by calling
<code>svz:sock:handle-request</code> and <code>svz:sock:check-request</code>.
The <code>connect-socket</code> callback is also mandatory for connection
oriented protocols and must be defined in <code>define-servertype!</code>.
On success you should return zero, otherwise the connection will be
shutdown by Serveez.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">info-server</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>info-server</deffunction> <defparam>server</defparam></definitionterm>
<definitionitem><para>This callback gets invoked when requested by the builtin
<ref><xrefnodename>Control Protocol Server</xrefnodename></ref>.  The callback is optional and can be
set up in <code>define-servertype!</code>.  The returned character string
can be multiple lines separated by <code>\r\n</code> (but without a trailing
separator).  Usually you will return information about the server instance
configuration and/or state.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">info-client</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>info-client</deffunction> <defparam>server</defparam> <defparam>socket</defparam></definitionterm>
<definitionitem><para>This callback is optional.  You can set it up in the
<code>define-servertype!</code> procedure.  It is meant to provide socket
structure specific information.  (The socket structure is a client/child
of the given server instance.)  You need to return a single line
character string without trailing newlines.  The information provided
can be requested by the builtin <ref><xrefnodename>Control Protocol Server</xrefnodename></ref>.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">notify</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>notify</deffunction> <defparam>server</defparam></definitionterm>
<definitionitem><para>The server instance notifier callback will be invoked whenever there is idle
time available.  In practice, it is run approximately once a second.
A server instance can use it to perform periodic tasks.  The callback
is optional and can be set up in <code>define-servertype!</code>.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">reset</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>reset</deffunction> <defparam>server</defparam></definitionterm>
<definitionitem><para>This callback is invoked when the Serveez process receives a <code>SIGHUP</code>
signal which can be issued via <samp>killall -HUP serveez</samp> from user
land.  If the underlying operating system does not provide <code>SIGHUP</code>
there is no use for this callback.  It provides the possibility to
perform asynchronous tasks scheduled from outside Serveez.  You can
optionally set it up in the <code>define-servertype!</code> procedure.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">handle-request</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>handle-request</deffunction> <defparam>socket</defparam> <defparam>binary</defparam> <defparam>size</defparam></definitionterm>
<definitionitem><para>This callback is invoked whenever a complete packet has been detected
in the receive buffer.  The packet data is passed to the callback as a
<code>#&lt;svz-binary&gt;</code>.  The <var>size</var> argument is passed for convenience
and specifies the length of the packet in bytes.
</para>
<para>The detection, and therefore the invocation, can be made in one of two
ways.  When Serveez can determine itself when a packet is complete, the
callback will be invoked directly.  Serveez can make this determination
for connections with packet oriented protocols such as UDP and ICMP, or
if you tell Serveez how to parse the packet using
<code>svz:sock:boundary sock delimiter</code> or
<code>svz:sock:boundary sock size</code> and do not specify a
<code>check-request</code> callback.
</para>
<para>Whenever you specify a <code>check-request</code> callback to determine when
a packet is complete, it becomes the responsiblity of that callback to
invoke <code>handle-request</code> itself.
</para>
<para>Serveez recognises two different return value meanings.  For connection
oriented protocols (TCP and PIPE), zero indicates success and non-zero
failure; on failure, Serveez will shutdown the connection.  For packet
oriented protocols (UDP and ICMP), a non-zero return value indicates
that your server was able to process the passed packet data, otherwise
(zero return value) the packet can be passed to other servers listening
on the same port configuration.
</para>
<para>This callback must be specified in <code>define-servertype!</code> for
packet oriented protocols (UDP and ICMP) but is optional otherwise.
You can modify the callback by calling <code>svz:sock:handle-request</code>.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">check-request</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>check-request</deffunction> <defparam>socket</defparam></definitionterm>
<definitionitem><para>This callback is invoked whenever new data has arrived in the receive buffer.
The receive buffer of the given <code>#&lt;svz-socket&gt;</code> can be obtained
using <code>svz:sock:receive-buffer</code>.  The callback is initially not
set and can be set up with <code>svz:sock:check-request</code>.  Its purpose
is to check whether a complete request was received.  If so, it should
be handled (by running the <code>handle-request</code> callback) and removed
from the receive buffer (using <code>svz:sock:receive-buffer-reduce</code>).
The callback is for connection oriented protocols (TCP and PIPE) only.
You should return zero to indicate success and non-zero to indicate
failure.  On failure Serveez shuts the connection down.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">disconnected</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>disconnected</deffunction> <defparam>socket</defparam></definitionterm>
<definitionitem><para>The <code>disconnected</code> callback gets invoked whenever the socket is
lost for some external reason and is going to be shutdown by Serveez.
It can be set up with <code>svz:sock:disconnected</code>.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">kicked</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>kicked</deffunction> <defparam>socket</defparam> <defparam>reason</defparam></definitionterm>
<definitionitem><para>This callback gets invoked whenever the socket gets closed by Serveez
intentionally.  It can be set up with <code>svz:sock:kicked</code>.  The
<var>reason</var> argument can be either <code>KICK_FLOOD</code>, indicating the
socket is a victim of the builtin flood protection, or <code>KICK_QUEUE</code>
which indicates a send buffer overflow.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">idle</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>idle</deffunction> <defparam>socket</defparam></definitionterm>
<definitionitem><para>The <code>idle</code> callback gets invoked from the periodic task scheduler,
which maintains a <code>idle-counter</code> for each socket structure.
This counter is decremented whenever Serveez becomes idle and the
callback is invoked when it drops to zero.  The <code>idle</code> callback can
set its socket&textrsquo;s <code>idle-counter</code> to some value with the procedure
<code>svz:sock:idle-counter</code> and thus re-schedule itself for a later
task.  You can set up this callback with <code>svz:sock:idle</code>.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">trigger-condition</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>trigger-condition</deffunction> <defparam>socket</defparam></definitionterm>
<definitionitem><para>This callback is invoked once every server loop for the socket structure.
If you return <code>#f</code> nothing else is happening.  Otherwise the
<code>trigger</code> callback will be invoked immediately.  You can set up the
callback using the procedure <code>svz:sock:trigger-condition</code>.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">trigger</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>trigger</deffunction> <defparam>socket</defparam></definitionterm>
<definitionitem><para>The <code>trigger</code> callback is invoked when the <code>trigger-condition</code>
returns <code>#t</code>.  The callback can be set up with the procedure
<code>svz:sock:trigger</code>.  Returning a non-zero value shuts the
connection down.  A zero return value indicates success.  This callback
can be used to perform connection related updates, e.g., you can ensure
a certain send buffer fill.
</para></definitionitem></deffn>

<deffn spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">check-oob-request</indexterm><defcategory bracketed="on">Scheme Procedure</defcategory> <deffunction>check-oob-request</deffunction> <defparam>socket</defparam> <defparam>oob-byte</defparam></definitionterm>
<definitionitem><para>This callback is invoked whenever urgent data (out-of-band) has been detected
on a socket.  Initially this event is ignored and the callback can be set
up with the procedure <code>svz:sock:check-oob-request</code>.  The
<var>oob-byte</var> argument is a number containing the received out-of-band
data byte ranging from 0 to 255.  If the callback returns non-zero the
connection will be shutdown.  A zero return value indicates success.  You
can use <code>svz:sock:send-oob</code> to send a single out-of-band data byte.
</para>
<para><strong>Please note</strong>:
The urgent data is not supported by all operating systems.  Also it does
not work for all types of network protocols.  We verified it to be working
for TCP streams on GNU/Linux 2.x.x and Windows 95; let us know if/how it
works on other platforms.
</para></definitionitem></deffn>

</subsubsection>
</subsection>
<node name="Builtin-servers" spaces=" "><nodename>Builtin servers</nodename><nodeprev automatic="on">Guile servers</nodeprev><nodeup automatic="on">Writing servers</nodeup></node>
<subsection spaces=" "><sectiontitle>Builtin servers</sectiontitle>

<para>All of the servers listed in <ref><xrefnodename>Existing servers</xrefnodename></ref> are builtin servers.
The following sections describe in detail how to setup a new builtin server
type.  This kind of server will be part of the Serveez executable.  That is
why you should make it configurable in the configure script via a
<samp>--enable-xxxserver</samp> argument.
</para>
<subsubsection spaces=" "><sectiontitle>Making and configuring preparations</sectiontitle>

<para>Serveez is configured and built via automake and autoconf.  That
is why you are not supposed to write your own Makefiles but simplified
<file>Makefile.am</file>s.  Automake will automatically generate dependencies and
compiler/linker command lines.  Here are the steps you basically need
to follow:
</para>
<itemize commandarg="bullet" spaces=" " endspaces=" "><itemprepend><formattingcommand command="bullet" /></itemprepend>
<listitem><prepend>&bullet;</prepend>
<para>Change to the <file>src/</file> directory in the source tree.
</para>
</listitem><listitem><prepend>&bullet;</prepend>
<para>Edit the <file>Makefile.am</file>.  Add your sub directory name and library name
which you are going to create.
</para>
</listitem><listitem><prepend>&bullet;</prepend>
<para>Now create the sub directory and change into it.
</para>
</listitem><listitem><prepend>&bullet;</prepend>
<para>You need to create a new <file>Makefile.am</file> therein.  If you want to have
this file <file>configure</file>d you need to add a further line to the
<code>AC_OUTPUT</code> statement in <file>configure.ac</file> which is in the top
level directory.  You have to put at least the following into the newly
created <file>Makefile.am</file>:
</para>
<example endspaces=" ">
<pre xml:space="preserve">noinst_LIBRARIES = libfoo.a
libfoo_a_SOURCES = foo-proto.h foo-proto.c
INCLUDES = $(SERVEEZ_CFLAGS) -I$(top_srcdir)/src
CLEANFILES = *~
MAINTAINERCLEANFILES = Makefile.in
</pre></example>

</listitem><listitem><prepend>&bullet;</prepend>
<para>Just have a look at all the other server directories.  For more information
about automake read the info pages.
</para>
</listitem></itemize>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>Server header file <file>foo-proto.h</file></sectiontitle>

<para>This file contains at least your server&textrsquo;s <code>extern</code> declaration of your
server definition which must be available from the outside.
The <code>foo</code> server implements all kinds of
configuration items which can be integers, integer arrays, strings, string
arrays, port configurations, booleans and hash maps.  Every item of the server
configuration can later be manipulated from the configuration file.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Server implementation file <file>foo-proto.c</file></sectiontitle>

<para>If you want to define default values for your configuration you have
to define them somewhere and put them into the default configuration
structure.  This structure will be used to instantiate your server.  For
this example we simply called it simply <code>foo_config</code>.
</para>
<para>In order to associate the configuration items in a server configuration
to keywords within the configuration file you have to define an
array of key-value-pairs.  This is done in the <code>foo_config_prototype</code>
field.  There are several macros which make different associations.  These
are the <code>SVZ_REGISTER_*</code> macros which take three arguments.  The first
argument is the keyword which will occur in the configuration file, the
second is the associated item in your default configuration structure
and the last argument specifies if this item is defaultable or not.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Server definition</sectiontitle>

<para>The server definition is in a way the <samp>class</samp> of your server.  Together
with the default values (<code>foo_config_prototype</code>) it serves as a
template for newly instantiated servers.  The structure contains a long and a
short description of your server.  The short name is used as the prefix for
all server instances of this specific type.  The long description is
used in the control protocol (<xref><xrefnodename>Control Protocol Server</xrefnodename></xref>.).  The server
definition also contains the callbacks your server (mandatorily) provides.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Server callbacks</sectiontitle>

<para>There are several callback routines, which get called in order to
instantiate the server and for describing the actual behaviour of your
server.  Here are the description of all of these callbacks.  Some of them
have to be implemented.  Others have reasonable default values.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">global initializer (optional)</itemformat></item>
</tableterm><tableitem><para>This callback is executed once for every type of server.  Here you can
initialize data or whatever is shared between all instances of your server.
For instance the HTTP server initializes its file cache here.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">global finalizer (optional)</itemformat></item>
</tableterm><tableitem><para>If you want to free shared resources which were possibly allocated within
the global initializer you can do so here.  The foo server frees its
default hash previously allocated in the global initializer.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">instance initializer (mandatory)</itemformat></item>
</tableterm><tableitem><para>Within this routine you can initialize everything you might need for one
instance of your server.  The foo server does not do anything in this
callback.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">instance finalizer (optional)</itemformat></item>
</tableterm><tableitem><para>The server instance finalizer gets its instance representation as argument.
You have to free all resources used by this server instance.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">protocol detection (mandatory)</itemformat></item>
</tableterm><tableitem><para>Because it is possible to have more than one server listening on one
network port we need to detect the type of client which is connecting
to this port.  The foo server checks if the first five bytes the client
was sending is identifying it as a foo client.  This routine is getting
two arguments where the first one is a pointer to this servers instance
and the second is the client socket object containing all
information of the client connection.  This structure is described a bit
later.  Be patient.  For successful client detection return non-zero value.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">socket connection (mandatory)</itemformat></item>
</tableterm><tableitem><para>If the client detection signaled success this routine is called to assign
the client connection to the server instance.  The arguments are just
the same as in the detection routine.  In this callback you can assign
all the connection specific callbacks for your server and do some initial
things.  The foo server sets the <code>check_request</code> callback to the default
<code>svz_sock_check_request</code> which is using the packet delimiter
information to find whole packets.  When a client sent such a packet the
<code>handle_request</code> callback is executed.  That is why the foo
server assigns the <code>handle_request</code> method.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">client info (optional)</itemformat></item>
</tableterm><tableitem><para>If this callback is given the control protocol
(<xref><xrefnodename>Control Protocol Server</xrefnodename></xref>.) can give information about a specific
client if requested with <samp>stat id NUM</samp>.  The first argument given
is the server instance and the second one the client&textrsquo;s socket
structure.  You have to return a static single line character string.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">server info (optional)</itemformat></item>
</tableterm><tableitem><para>This function is called when listing the server instances via
<samp>stat all</samp> from the control protocol (<xref><xrefnodename>Control Protocol Server</xrefnodename></xref>.).
The returned character string might be multilined separated by
<code>\r\n</code> (no trailing separator).  Usually you will return all the
server configuration information.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">notifier (optional)</itemformat></item>
</tableterm><tableitem><para>If this callback is not <code>NULL</code> it is called whenever there is some time
left.  It gets the server instance itself as argument.  Actually it gets
called every second.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">handle request (mandatory for UDP and ICMP servers)</itemformat></item>
</tableterm><tableitem><para>The arguments to this callback are the client&textrsquo;s socket structure, the
address of the packet data and its length.  When implementing a UDP or
ICMP server you need to return non-zero if your server could process the
packet.  Thus it is possible that there are multiple UDP servers on a
single port.
</para></tableitem></tableentry></table>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>Make your server available</sectiontitle>

<para>You distribute your server by editing the <file>cfgfile.c</file> file in the
<file>src/</file> directory.  There you have to include the servers header
file and add the server definition by calling <code>svz_servertype_add</code>
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>More detailed description of the callback system and structures</sectiontitle>

<para>The client connection information is stored within the <code>svz_socket_t</code>
object.  All of the client connection specific callbacks get this object as
first argument.  Following is a description of the most important elements
of this object.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">int id</itemformat></item>
</tableterm><tableitem><para>The socket id is a unique id for a client connection.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">int version</itemformat></item>
</tableterm><tableitem><para>This item validates this socket structure.  If you pass the <code>id</code> and
<code>version</code> to a coserver you can check if the delivered socket
structure is the original or not within the coserver callback.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">int proto</itemformat></item>
</tableterm><tableitem><para>The <code>proto</code> flag determines a server sockets protocol type which can
be <code>PROTO_PIPE</code>, <code>PROTO_TCP</code>, <code>PROTO_UDP</code>,
<code>PROTO_ICMP</code> or <code>PROTO_RAW</code>.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">int flags</itemformat></item>
</tableterm><tableitem><para>The flag field of the client connection contains informations about the
state of this connection.  See <file>socket.h</file> in the <file>src/libserveez/</file>
directory for more information.  Basically this bitfield specifies how this
object is handled by the main server loop.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">int userflags</itemformat></item>
</tableterm><tableitem><para>This bitfield could be used for protocol specific information.  You can use
it for any information.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">char *boundary, int boundary_size</itemformat></item>
</tableterm><tableitem><para>If you are going to write a packet oriented protocol server you can use
the <code>svz_sock_check_request</code> method to parse packets.  These two
properties describe the packet delimiter.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">char *send_buffer, int send_buffer_size, int send_buffer_fill</itemformat></item>
</tableterm><tableitem><para>This is the outgoing data for a client connection object.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">char *recv_buffer, int recv_buffer_size, int recv_buffer_fill</itemformat></item>
</tableterm><tableitem><para>Within the receive buffer all incoming data for a connection object is
stored.  This buffer is at least used for the client detection callback.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">int read_socket (svz_socket_t)</itemformat></item>
</tableterm><tableitem><para>This callback gets called whenever data is available on the socket.
Normally, this is set to a default function which reads all available
data from the socket and feeds it to <code>check_request</code>, but specific
sockets may need other policies.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">int write_socket (svz_socket_t)</itemformat></item>
</tableterm><tableitem><para>This routine is called when data is is valid in the output buffer
and the socket gets available for writing.  You normally leave this
callback untouched.  It simply writes as much data as possible to the
socket and removes the data from the send buffer.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">int disconnected_socket (svz_socket_t)</itemformat></item>
</tableterm><tableitem><para>This gets called whenever the socket is lost for some external reason.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">int connected_socket (svz_socket_t)</itemformat></item>
</tableterm><tableitem><para>If some piece of code tries to connect to another host via
<code>svz_tcp_connect</code> this connection might be established some time later.
This callback gets called when the socket is finally connected.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">int kicked_socket (svz_socket_t, int)</itemformat></item>
</tableterm><tableitem><para>We call this whenever the socket gets closed by us.  The second argument
specifies a reason.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">int check_request (svz_socket_t)</itemformat></item>
</tableterm><tableitem><para>This gets called whenever data was read from the socket.
Its purpose is to check whether a complete request was read, and
if it was, it should be handled and removed from the input buffer.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">int handle_request (svz_socket_t, char *, int)</itemformat></item>
</tableterm><tableitem><para>This gets called when the <code>check_request</code> got a valid packet.  The
request arguments contains the actual packet and the second argument is the
length of this packet including the packet delimiter.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">int idle_func (svz_socket_t)</itemformat></item>
</tableterm><tableitem><para>This callback gets called from the periodic task scheduler.  Whenever
<code>idle_counter</code> (see below) is non-zero, it is decremented and
<code>idle_func</code> gets called when it drops to zero.  <code>idle_func</code> can
reset <code>idle_counter</code> to some value and thus can re-schedule itself
for a later task.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">int idle_counter</itemformat></item>
</tableterm><tableitem><para>Counter for calls to <code>idle_func</code>.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">void *data</itemformat></item>
</tableterm><tableitem><para>Miscellaneous field.  Listener keeps array of server instances here.
This array is <code>NULL</code> terminated.  Some servers store server specific
information here.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">void *cfg</itemformat></item>
</tableterm><tableitem><para>When the final protocol detection
has been done <code>cfg</code> should contain a pointer to the actual
configuration hash map taken from the server instance object.
</para></tableitem></tableentry></table>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>Using coservers</sectiontitle>

<para>Coservers are designed to complete blocking tasks.  Each coserver runs in
its own thread/process.  There are several coservers implemented: the dns,
reverse dns and ident coserver.  You need to implement the
callback which gets called when a coserver completed its task.  This
routine must be a <code>svz_coserver_handle_result_t</code>.  The first argument is
the actual coserver result which might be <code>NULL</code> if the request
could not  be fulfilled and the latter two arguments are the arguments
you specified  yourself when issuing the request.  To invoke a coserver
you use one of the <code>svz_coserver_*</code> macros.  The foo server uses
the reverse dns coserver to identify the host name of the remote client.
</para>
</subsubsection>
</subsection>
</section>
<node name="Configuring-servers" spaces=" "><nodename>Configuring servers</nodename><nodenext automatic="on">Existing servers</nodenext><nodeprev automatic="on">Writing servers</nodeprev><nodeup automatic="on">Server</nodeup></node>
<section spaces=" "><sectiontitle>Some words about server configuration</sectiontitle>

<para>If you define a server you basically pass an instance name and a list of
items to the <code>define-server!</code> procedure.  Each item has a name and a
value.  A value has a type.  We provide several types: integers (numbers),
integer arrays, strings, string arrays, booleans (yes/no-values), hashes
(associations) and port configurations.
</para>
<para>The following table shows how each kind of value is set up in the
configuration file.  <var>item</var> is the name of the item to be configured.
</para>
<table commandarg="asis" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="asis">Integer&linebreak;</itemformat></item>
</tableterm><tableitem><para>Example: (item . 42)
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Integer array&linebreak;</itemformat></item>
</tableterm><tableitem><para>Example: (item . (0 1 2 3))
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">String&linebreak;</itemformat></item>
</tableterm><tableitem><para>Example: (item . &quot;a character string&quot;)
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">String array&linebreak;</itemformat></item>
</tableterm><tableitem><para>Example: (item . (&quot;abc&quot; &quot;cba&quot; &quot;bca&quot; &quot;acb&quot;))
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Boolean&linebreak;</itemformat></item>
</tableterm><tableitem><para>A normal boolean in guile is represented by #t or #f.  But the configuration
file parser additional understand some bare words and numbers.&linebreak;
Example: (item . #f)
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Hash&linebreak;</itemformat></item>
</tableterm><tableitem><para>Hash maps associate keys with values.  Both must be character strings.&linebreak;
Example: (item . (key1 . &quot;value1&quot;) (key2 . &quot;value2&quot;))
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Port configuration&linebreak;</itemformat></item>
</tableterm><tableitem><para><xref><xrefnodename>Define ports</xrefnodename></xref>, for more information on this.  When configuring a port
configuration you need to define it via <code>define-port!</code> previously and
put its symbolic name into the configuration.&linebreak;
Example: (item . foo-tcp-port)
</para></tableitem></tableentry></table>

<para>The next chapter describes the servers currently implemented using
Serveez.  The configuration items used by each of them are described in the
following format:
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">NameOfTheItem (Type, default: DefaultValue, Comments)</itemformat></item>
</tableterm><tableitem><para>Description of the configuration item named <samp>NameOfTheItem</samp> (case
sensitive).  <samp>Type</samp> can be either <samp>integer</samp>, <samp>integer array</samp>,
<samp>string</samp>, <samp>string array</samp>, <samp>boolean</samp>, <samp>hash</samp> or
<samp>port configuration</samp>.  The <samp>Comments</samp> is an optional text.
</para></tableitem></tableentry></table>

<para>The example configuration file <file>data/serveez.cfg</file> contains an example
definition of each server already implemented.  You can copy and modify the
example for an easy start.
</para>
</section>
<node name="Existing-servers" spaces=" "><nodename>Existing servers</nodename><nodeprev automatic="on">Configuring servers</nodeprev><nodeup automatic="on">Server</nodeup></node>
<section spaces=" "><sectiontitle>Existing servers</sectiontitle>

<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::                 ">HTTP Server</menunode><menudescription><pre xml:space="preserve">Integrated Web Server description
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::                  ">IRC Server</menunode><menudescription><pre xml:space="preserve">EFNet IRC Server
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::     ">Control Protocol Server</menunode><menudescription><pre xml:space="preserve">Serveez control center
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::                  ">Foo Server</menunode><menudescription><pre xml:space="preserve">Example server implementation
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::                 ">SNTP Server</menunode><menudescription><pre xml:space="preserve">Simple network time protocol server
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::             ">Gnutella Spider</menunode><menudescription><pre xml:space="preserve">Gnutella Client description
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::               ">Tunnel Server</menunode><menudescription><pre xml:space="preserve">Description of the port forwarder
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::           ">Fake Ident Server</menunode><menudescription><pre xml:space="preserve">Description of a simple ident server
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::          ">Passthrough Server</menunode><menudescription><pre xml:space="preserve">Description of the program passthrough server
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::               ">Mandel Server</menunode><menudescription><pre xml:space="preserve">Distributed Mandelbrot server
</pre></menudescription></menuentry></menu>

<node name="HTTP-Server" spaces=" "><nodename>HTTP Server</nodename><nodenext automatic="on">IRC Server</nodenext><nodeup automatic="on">Existing servers</nodeup></node>
<subsection spaces=" "><sectiontitle>HTTP Server</sectiontitle>

<subsubsection spaces=" "><sectiontitle>General description</sectiontitle>

<para>The integrated HTTP server was originally meant to be a simple but fast
document server.  But now it can even execute CGI scripts.  The GET, HEAD and
POST methods are fully functional.  Additionally Serveez produces
directory listings when no standard document file
(e.g., <file>index.html</file>) has been found at the requested document node
(directory).  Furthermore it implements a file cache for speeding up
repetitive HTTP request.
</para>
<para>In comparison to other web server projects like Apache and Roxen this
web server is really fast.  Comparative benchmarks will follow.
The benchmark system is a 233 MHz Mobile Pentium MMX.  Both the server and
the client (http_load - multiprocessing http test client) ran on the same
computer.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">Small files</itemformat></item>
</tableterm><tableitem><para>The small-file test load consists of 1000 files, each 1KB long, requested
randomly.
</para>
<example endspaces=" ">
<pre xml:space="preserve">concurrent fetches   1   10   50  100  200  500  1000
hits/second        501  520  481  475  420  390   295
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">CGI</itemformat></item>
</tableterm><tableitem><para>The CGI test load consists of a trivial &textldquo;hello world&textrdquo; C program.  I noticed
GNU/Linux (2.2.17 in this case, probably others too) to throw
&textldquo;Resource temporarily unavailable&textrdquo; errors when <code>fork</code>ing very fast.  This
limits the test to about 200 concurrent fetches on the test system.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">Large files</itemformat></item>
</tableterm><tableitem><para>The large-file test load consists of 100 files, each 1MB long, requested
randomly.  Also, each connection is throttled to simulate a 33.6Kbps modem.
Note that 1000 33.6Kbps connections is 3/4 of a T3.  There was no problem to
get 1000+ concurrent fetches.
</para></tableitem></tableentry></table>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>Configuration</sectiontitle>

<para>The following options can be set from the configuration file.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">indexfile (string, default: index.html)</itemformat></item>
</tableterm><tableitem><para>The <code>indexfile</code> parameter is the default file served by the HTTP
server when the user does not specify a file but a document node
(e.g., <uref><urefurl>http://www.lkcc.org/</urefurl></uref>).
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">docs (string, default: ../show)</itemformat></item>
</tableterm><tableitem><para>The <code>docs</code> parameter is the document root where the server finds its
web documents.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">userdir (string, default: public_html)</itemformat></item>
</tableterm><tableitem><para>Each <samp>~user</samp> request gets converted into the given users home
directory.  The string will be appended to this directory.  Its default
value is <samp>public_html</samp>.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">cgi-url (string, default: /cgi-bin)</itemformat></item>
</tableterm><tableitem><para>This parameter is the first part of the URL the HTTP server identifies a
CGI request.  For instance if you specify here <file>/cgi-bin</file> and the
user requests <uref><urefurl>http://www.lkcc.org/cgi-bin/test.pl</urefurl></uref> then the
HTTP server tries to execute the program <file>test.pl</file> within the
<code>cgi-dir</code> (see below) and pipes its output to the user.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">cgi-dir (string, default: ./cgibin)</itemformat></item>
</tableterm><tableitem><para>The <code>cgi-dir</code> is the CGI document root (on the server).
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">cgi-application (hash, default: empty)</itemformat></item>
</tableterm><tableitem><para>Within the MinGW32 port you can use this hash to associate
certain file suffices with applications on your computer (e.g., <file>pl</file> with
<file>perl</file>).  This is necessary because there is no possibility to check whether
a file is executable on Win32.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">cache-size (integer, default: 200 kb)</itemformat></item>
</tableterm><tableitem><para>This specifies the size of the document cache in bytes for each cache
entry.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">cache-entries (integer, default: 64)</itemformat></item>
</tableterm><tableitem><para>This parameter specifies the maximum number of HTTP file cache entries
(files).  When you instantiate more than one HTTP server the biggest value
wins.  The HTTP file cache is shared by all HTTP servers.&linebreak;
<strong>Please note</strong>: If your harddrive/filesystem combination proves to
be faster than the HTTP file cache you should disable it by setting both
<code>cache-size</code> and <code>cache-entries</code> to zero.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">timeout (integer, default: 15)</itemformat></item>
</tableterm><tableitem><para>The <code>timeout</code> value is the amount of time in seconds after which
a keep-alive connection (this is a HTTP/1.1 feature) will be closed when
it has been idle.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">keepalive (integer, default: 10)</itemformat></item>
</tableterm><tableitem><para>On one keep-alive connection can be served the number of <code>keepalive</code>
documents at all.  Then the connection will be closed.
Both this and the <code>timeout</code> value are just to be on the safe side.
They protect against idle and high traffic connections.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">default-type (string, default: text/plain)</itemformat></item>
</tableterm><tableitem><para>The <code>default-type</code> is the default content type the HTTP server
assumes if it can not identify a served file by the <code>types</code> hash
and the <code>type-file</code> (see below).
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">type-file (string, default: /etc/mime.types)</itemformat></item>
</tableterm><tableitem><para>This should be a file like the <file>/etc/mime.types</file> on Unix systems.
It associates file suffices with MIME types.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">types (hash, default: empty)</itemformat></item>
</tableterm><tableitem><para>If you want to specify special content types do it here.  This parameter
is a hash map associating file suffices with HTTP content types (MIME types).
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">admin (string, default: root&arobase;localhost)</itemformat></item>
</tableterm><tableitem><para>Your address, where problems with the server should be e-mailed.
This address appears on some server-generated pages, such as error
documents.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">host (string, default: localhost)</itemformat></item>
</tableterm><tableitem><para>This is the host name of your web server.  Sometimes the server has
to send back its own name to the client.  It will use this value.
Be aware that you cannot invent such a name.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">nslookup (boolean, default: false)</itemformat></item>
</tableterm><tableitem><para>If this is true the HTTP server invokes a reverse DNS lookup
for each client connection in order to replace the remote ip address with
the remote host name in the access logfile.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">ident (boolean, default: false)</itemformat></item>
</tableterm><tableitem><para>If this is true the HTTP server processes identd requests
for each client connection for logging purposes.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">logfile (string, default: http-access.log)</itemformat></item>
</tableterm><tableitem><para>The location of the access logfile.  For each HTTP request a line gets
appended to this file.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">logformat (string, default: CLF)</itemformat></item>
</tableterm><tableitem><para>The format of the access logfile.  There are special placeholders for
different kinds of logging information.  The default log format is the
Common Log Format (CLF).  It contains a separate line for each request.  A
line is composed of several tokens separated by spaces.
</para><example endspaces=" ">
<pre xml:space="preserve">CLF = host ident authuser date request status bytes
</pre></example>
<para>If a token does not have a value then it is represented by a hyphen (-).
The meanings and values of these tokens are as follows:
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">%h (host)</itemformat></item>
</tableterm><tableitem><para>The fully-qualified domain name of the client, or its IP number if the name
is not available.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">%i (ident)</itemformat></item>
</tableterm><tableitem><para>This is the identity information reported by the client.  Not active, so
we will see a hyphen (-).
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">%u (authuser)</itemformat></item>
</tableterm><tableitem><para>If the request was for an password protected document, then this is the
userid used in the request.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">%t (date)</itemformat></item>
</tableterm><tableitem><para>The date and time of the request, in the following format:
</para><example endspaces=" ">
<pre xml:space="preserve">date   = [day/month/year:hour:minute:second zone]
day    = 2*digit
month  = 3*letter
year   = 4*digit
hour   = 2*digit
minute = 2*digit
second = 2*digit
zone   = (`+' | `-') 4*digit
</pre></example>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">%R (request)</itemformat></item>
</tableterm><tableitem><para>The request line from the client, enclosed in double quotes (&quot;).
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">%r (referrer)</itemformat></item>
</tableterm><tableitem><para>Which document referred to this document.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">%a (agent)</itemformat></item>
</tableterm><tableitem><para>What kind of web browser did the remote client use.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">%c (status)</itemformat></item>
</tableterm><tableitem><para>The three digit status code returned to the client.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">%l (bytes)</itemformat></item>
</tableterm><tableitem><para>The number of bytes in the object returned to the client, not including
any headers.
</para></tableitem></tableentry></table>
</tableitem></tableentry></table>

</subsubsection>
</subsection>
<node name="IRC-Server" spaces=" "><nodename>IRC Server</nodename><nodenext automatic="on">Control Protocol Server</nodenext><nodeprev automatic="on">HTTP Server</nodeprev><nodeup automatic="on">Existing servers</nodeup></node>
<subsection spaces=" "><sectiontitle>IRC Server</sectiontitle>

<subsubsection spaces=" "><sectiontitle>General description</sectiontitle>

<para>Internet Relay Chat.  The mother of all chat systems.  The integrated
IRC server is intended to be compatible with the EFNet.  There are no
good possibilities to test this in real life, so it is still under
heavy construction.  But it can be used as a standalone server anyway.
</para>
<para>IRC itself is a teleconferencing system, which (through the use of
the client-server model) is well-suited for running on many machines
in a distributed fashion.  A typical setup involves a single process
(the server) forming a central point for clients (or other servers)
to connect to, performing the required message delivery/multiplexing
and other functions.
</para>
<para>The server forms the backbone of IRC, providing a point for clients and
servers to connect to.  Clients connect to talk to each other.  Servers
connect to build up a network of servers.  IRC server connections have
to build up a spanning tree.  Loops are not allowed.  Each server acts
as a central node for the rest of the network it sees.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Configuration</sectiontitle>

<para>The following table shows the configuration keys provided.  Most of the
configuration items are similar to those of an Hybrid IRC server.  They
seem archaic at first sight but IRC operators are used to it.  Refer to
the Hybrid documentation for further information.  It can be found on
the EFNet web page.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">MOTD-file (string, default: ../data/irc-MOTD.txt)</itemformat></item>
</tableterm><tableitem><para>When a user initially joins it will get this file&textrsquo;s content as the
message of the day comment.  When changing on disk the server will notice
that and reload the file automatically.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">INFO-file (string, default: no file)</itemformat></item>
</tableterm><tableitem><para>The <code>INFO-file</code>s content gets displayed when the user issues the
/INFO command.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">tsdelta (integer, default: 0)</itemformat></item>
</tableterm><tableitem><para>This value is the timestamp delta value to UTC (Coordinated Universal Time)
in seconds.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">channels-per-user (integer, default: 10)</itemformat></item>
</tableterm><tableitem><para>Configures the maximum number of channels a single local user can join.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">admininfo (string, no default)</itemformat></item>
</tableterm><tableitem><para>Some administrative information delivered on the /ADMIN command.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">M-line (string, no default, mandatory)</itemformat></item>
</tableterm><tableitem><para>The TCP level configuration of this IRC server.  The server info field
is sometimes given to the client for informational use.  The server will
croak about if the settings do not correspond with the actual bindings.
The format of this line is:
</para><example endspaces=" ">
<pre xml:space="preserve">&quot;:&quot; virtual hostname
&quot;:&quot; optional bind address (real hostname)
&quot;:&quot; server info: &quot;World's best IRC server&quot;
&quot;:&quot; port
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">A-line (string, no default, mandatory)</itemformat></item>
</tableterm><tableitem><para>The administrative info, printed by the /ADMIN command.
</para><example endspaces=" ">
<pre xml:space="preserve">&quot;:&quot; administrative info (department, university)
&quot;:&quot; the server's geographical location
&quot;:&quot; email address for a person responsible for the IRC server
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">Y-lines (string array, no default, suggested)</itemformat></item>
</tableterm><tableitem><para>The connection classes.  They are used in other parameters (e.g., I-lines).
A Y-line describes a group of connections.  You usually have at least
two Y-lines: One for server connections and one for client connections.
Format of each line is:
</para><example endspaces=" ">
<pre xml:space="preserve">&quot;:&quot; class number (higher numbers refer to a higher priority)
&quot;:&quot; ping frequency (in seconds)
&quot;:&quot; connect frequency in seconds for servers, 0 for
    client classes
&quot;:&quot; maximum number of links in this class
&quot;:&quot; send queue size
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">I-lines (string array, no default, mandatory)</itemformat></item>
</tableterm><tableitem><para>Authorization of clients, wildcards permitted, a valid client is matched
<email><emailaddress>user&arobase;ip</emailaddress></email> OR <email><emailaddress>user&arobase;host</emailaddress></email>.
</para><example endspaces=" ">
<pre xml:space="preserve">&quot;:&quot; user&arobase;ip, you can specify <samp>NOMATCH</samp> here to force
    matching user&arobase;host
&quot;:&quot; password (optional)
&quot;:&quot; user&arobase;host
&quot;:&quot; password (optional)
&quot;:&quot; connection class number (YLine)
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">O-lines (string array, no default, optional)</itemformat></item>
</tableterm><tableitem><para>Authorize operator, wildcards allowed.
</para><example endspaces=" ">
<pre xml:space="preserve">&quot;:&quot; user&arobase;host, user&arobase; forces checking ident
&quot;:&quot; password
&quot;:&quot; nick
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">o-lines (string array, no default, optional)</itemformat></item>
</tableterm><tableitem><para>Authorize local operator.
</para><example endspaces=" ">
<pre xml:space="preserve">&quot;:&quot; user&arobase;host, user&arobase; forces checking ident
&quot;:&quot; password
&quot;:&quot; nick
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">C-lines (string array, no default, networked)</itemformat></item>
</tableterm><tableitem><para>List of servers to connect to.
Note: C and N lines can also use the user&arobase; combination in order to
check specific users (ident) starting servers.  C and N lines are
usually given in pairs.
</para><example endspaces=" ">
<pre xml:space="preserve">&quot;:&quot; host name
&quot;:&quot; password
&quot;:&quot; server name (virtual)
&quot;:&quot; port (if not given we will not connect)
&quot;:&quot; connection class number (YLine)
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">N-lines (string array, no default, networked)</itemformat></item>
</tableterm><tableitem><para>Servers which may connect.
</para><example endspaces=" ">
<pre xml:space="preserve">&quot;:&quot; host name
&quot;:&quot; password
&quot;:&quot; server name (virtual host name)
&quot;:&quot; password
&quot;:&quot; how many components of your own server's name to strip
    off the front and be replaced with a <samp>*</samp>.
&quot;:&quot; connection class number (YLine)
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">K-lines (string array, no default, optional)</itemformat></item>
</tableterm><tableitem><para>Kill user, wildcards allowed.
</para><example endspaces=" ">
<pre xml:space="preserve">&quot;:&quot; host
&quot;:&quot; time of day
&quot;:&quot; user
</pre></example>
</tableitem></tableentry></table>

</subsubsection>
</subsection>
<node name="Control-Protocol-Server" spaces=" "><nodename>Control Protocol Server</nodename><nodenext automatic="on">Foo Server</nodenext><nodeprev automatic="on">IRC Server</nodeprev><nodeup automatic="on">Existing servers</nodeup></node>
<subsection spaces=" "><sectiontitle>Control Protocol Server</sectiontitle>

<para>If the GNU Serveez package is configured with the control
protocol enabled, running <samp>serveez --help</samp> will show
the option <code>-P</code> and the following documentation applies.
Otherwise, feel free to skip to the next section.
</para>
<subsubsection spaces=" "><sectiontitle>General description</sectiontitle>

<para>Serveez implements something like a telnet protocol for
administrative purposes.  You just need to start a telnet session like:
</para><example endspaces=" ">
<pre xml:space="preserve">$ telnet www.lkcc.org 42420
</pre></example>
<para>After pressing <key>RET</key> you will be asked for a password which you
might setup passing Serveez the -P argument.
<xref><xrefnodename>Using Serveez</xrefnodename></xref>.  The next section describes the interactive commands
available.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Using the Control Protocol</sectiontitle>

<table commandarg="samp" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="samp">help</itemformat></item>
</tableterm><tableitem><para>This command will give you a very short help screen of all available
commands.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">quit</itemformat></item>
</tableterm><tableitem><para>This command closes the connection to Serveez.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">restart ident</itemformat></item>
</tableterm><tableitem><para>Restarts the internal ident coserver.  This is useful if you just want
to start a new one if the old one died or is otherwise unusable.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">restart dns</itemformat></item>
</tableterm><tableitem><para>Restarts the internal dns lookup server.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">restart reverse dns</itemformat></item>
</tableterm><tableitem><para>Restarts the internal reverse dns lookup server.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">killall</itemformat></item>
</tableterm><tableitem><para>This might be useful if Serveez seems to be unstable but you do not
want to restart it.  With <samp>killall</samp> you disconnect all client
network connections except the control protocol connections.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">kill id NUM</itemformat></item>
</tableterm><tableitem><para>Disconnects a specific connection identified by its ID.  These IDs will
be stated when you type <samp>stat con</samp> (see below).
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">stat</itemformat></item>
</tableterm><tableitem><para>General statistics about Serveez.  This will show you some useful
information about the computer Serveez is running on and about the
state of Serveez in general.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">stat coserver</itemformat></item>
</tableterm><tableitem><para>Statistics about all running coserver instances.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">stat SERVER</itemformat></item>
</tableterm><tableitem><para>This command is for selecting certain server instances to be listed.
SERVER is one of server names you specified in the configuration file.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">stat id NUM</itemformat></item>
</tableterm><tableitem><para>Show statistics about a specific connection.  This will give you all
available information about every connection you specified.
<xref><xrefnodename>Writing servers</xrefnodename></xref>, for more information about how to provide these
information.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">stat con</itemformat></item>
</tableterm><tableitem><para>Connection statistics.  This will give a list of all socket structures
within Serveez.  If you want more detailed information about specific
connections, coservers or servers you need to request these information
with <samp>stat id NUM</samp> or <samp>stat all</samp>.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">stat all</itemformat></item>
</tableterm><tableitem><para>Server and coserver instance statistics.  This command lists all
the information about instantiated servers and coservers.
<xref><xrefnodename>Writing servers</xrefnodename></xref>, for more information about how to provide these
information.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">stat cache</itemformat></item>
</tableterm><tableitem><para>HTTP cache statistics.  This command produces an output something like the
following where <samp>File</samp> is the short name of the cache entry,
<samp>Size</samp> the cache size, <samp>Usage</samp> the amount of connections
currently using this entry, <samp>Hits</samp> the amount of cache hits,
<samp>Recent</samp> the cache strategy flag (newer entries have larger numbers)
and <samp>Ready</samp> is the current state of the cache entry.
</para>
<example endspaces=" ">
<pre xml:space="preserve">File                      Size  Usage  Hits Recent Ready
zlib-1.1.3-20000531.zip  45393      0     0      1 Yes
texinfo.tex             200531      0     0      2 Yes
shayne.txt                2534      0     1      1 Yes

Total : 248458 byte in 3 cache entries
</pre></example>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="samp">kill cache</itemformat></item>
</tableterm><tableitem><para>Reinitialize the HTTP file cache.  Flushes all files from the cache.
</para></tableitem></tableentry></table>

</subsubsection>
<subsubsection spaces=" "><sectiontitle>Configuration</sectiontitle>

<para>There is nothing to be configured yet.
</para>
</subsubsection>
</subsection>
<node name="Foo-Server" spaces=" "><nodename>Foo Server</nodename><nodenext automatic="on">SNTP Server</nodenext><nodeprev automatic="on">Control Protocol Server</nodeprev><nodeup automatic="on">Existing servers</nodeup></node>
<subsection spaces=" "><sectiontitle>Foo Server</sectiontitle>

<subsubsection spaces=" "><sectiontitle>General description</sectiontitle>
<para>The Foo Server is a simple example on how to write Internet protocol
servers with Serveez.  <xref><xrefnodename>Writing servers</xrefnodename></xref>.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Configuration</sectiontitle>
<para>There are all kinds of configuration items.  They are used to explain
the implementation of servers.  A complete list will follow.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">port (port configuration, default: tcp, 42421, *)</itemformat></item>
</tableterm><tableitem><para>Sets up the TCP port and local address.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">bar (integer, no default)</itemformat></item>
</tableterm><tableitem><para>Some integer value.  Printed as server information.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">reply (string, default: Default reply)</itemformat></item>
</tableterm><tableitem><para>Some string.  Printed as server information.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">messages (string array, default: ...)</itemformat></item>
</tableterm><tableitem><para>Some string array which is actually a list of strings.  Also printed as
server information.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">ports (integer array, default: 1, 2, 3, 4)</itemformat></item>
</tableterm><tableitem><para>Some array of integer numbers.  Printed as server information.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">assoc (hash, default, default: ...)</itemformat></item>
</tableterm><tableitem><para>An hash map associating keys with values.  Printed as server information.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">truth (boolean, default: true)</itemformat></item>
</tableterm><tableitem><para>Some boolean value.  Printed as server information.
</para></tableitem></tableentry></table>

</subsubsection>
</subsection>
<node name="SNTP-Server" spaces=" "><nodename>SNTP Server</nodename><nodenext automatic="on">Gnutella Spider</nodenext><nodeprev automatic="on">Foo Server</nodeprev><nodeup automatic="on">Existing servers</nodeup></node>
<subsection spaces=" "><sectiontitle>SNTP Server</sectiontitle>

<subsubsection spaces=" "><sectiontitle>General</sectiontitle>
<para>The SNTP server can be queried with the <samp>netdate</samp> command.  It is used
to synchronize time and dates between Internet hosts.  The protocol is
described in the ARPA Internet RFC 868.  Thus it is not really an SNTP server
as described by RFC 2030 (Simple Network Time Protocol (SNTP) Version 4 for
IPv4, IPv6 and OSI).  It is rather an excellent example on how to implement
a UDP server in Serveez.
</para>
<para>This protocol provides a site-independent, machine readable date and
time.  The Time service sends back time in seconds since midnight on
January first 1900.
</para>
<para>One motivation arises from the fact that not all systems have a
date/time clock, and all are subject to occasional human or machine
error.  The use of time-servers makes it possible to quickly confirm or
correct a system&textrsquo;s idea of the time, by making a brief poll of several
independent sites on the network.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Configuration</sectiontitle>

<para>The configuration of this server does not require any item.
</para>
</subsubsection>
</subsection>
<node name="Gnutella-Spider" spaces=" "><nodename>Gnutella Spider</nodename><nodenext automatic="on">Tunnel Server</nodenext><nodeprev automatic="on">SNTP Server</nodeprev><nodeup automatic="on">Existing servers</nodeup></node>
<subsection spaces=" "><sectiontitle>Gnutella Spider</sectiontitle>

<subsubsection spaces=" "><sectiontitle>What is it ?</sectiontitle>
<para>The Gnutella net is a peer-to-peer network which is based on
client programs only.  There are no servers.  The network itself is formed
by client connections only.  Generally the Gnutella network is for sharing
files of any kind.
</para>
<para>This Gnutella spider is for seeking the needle in the haystack.  Once
connected to the network it regularly tries to find certain files in there.
It keeps track of all connected clients and tries to reconnect them if
the current connections are lost.
</para>
<para>Gnutella, however has nothing to do with the GNU project.  The original
client is just a free (as in free beer) piece of software.  With Serveez
you have a free (as in freedom) way to use it.  Have a look at the Gnutella
page for further information.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Configuration</sectiontitle>
<para>The Gnutella spider knows the following configurations items.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">net-url (string, default: gnutella-net)</itemformat></item>
</tableterm><tableitem><para>If you want to see the host catcher list of this Gnutella spider you can
connect to this port with any WWW browser at
<uref><urefurl>http://host:port/net-url</urefurl></uref>.  The <code>host:port</code> combinations
depend on the bindings.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">hosts (string array, no default)</itemformat></item>
</tableterm><tableitem><para>This is the start of the haystack, the initial host list of the clients
the spider tries to connect to.  Each list item should be of the format
<code>ip:port</code> (e.g., <samp>146.145.85.34:6346</samp>).  You can also pass Internet
host names.  If the port information is left blank it defaults to 6346.  If
you need some entry point for the Gnutella network have a look at
<uref><urefurl>http://www.gnutellahosts.com/</urefurl></uref> or <uref><urefurl>http://www.gnutellanet.com/</urefurl></uref>.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">search (string array, default: Puppe3000, Meret Becker)</itemformat></item>
</tableterm><tableitem><para>This is the needle.  Each search line is either a set of
space delimited tokens where every token must match.  Or a kind of wildcard
expression including <samp>?</samp> and <samp>*</samp>.
Search lines are always matched case insensitive.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">search-limit (integer, default: 30)</itemformat></item>
</tableterm><tableitem><para>This limits how many results the Gnutella spider returns to other people
searching your files.  This is for protection against <code>*</code> search requests.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">max-ttl (integer, default: 5)</itemformat></item>
</tableterm><tableitem><para>Every Gnutella packet has got a TTL.  This is the maximum TTL allowed for
outgoing packets.  When a packet comes in it gets its TTL value decremented
and is forwarded to it destination.  If however an incoming packet has a TTL
larger than <code>max-ttl</code> the ttl value is set to <code>max-ttl</code>.  This is
necessary since most people use far too large TTL values.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">ttl (integer, default: 5)</itemformat></item>
</tableterm><tableitem><para>When creating a new Gnutella packet we use this as TTL.  Please use a
sane value.  This ttl needs not to be as large as it is for IP packets.
A value below 10 is more than enough.  Have a look at the Gnutella page
for a calculation of a &textrsquo;sane value&textrsquo;.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">download-path (string, default: /tmp)</itemformat></item>
</tableterm><tableitem><para>This is where the spider saves needles in.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">share-path (string, default: /tmp)</itemformat></item>
</tableterm><tableitem><para>Here are all the files we share with others.  The Gnutella spider will
recurse into directories.  So be careful with this option.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">max-downloads (integer, default: 4)</itemformat></item>
</tableterm><tableitem><para>Maximum number of concurrent downloads from the network.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">max-uploads (integer, default: 4)</itemformat></item>
</tableterm><tableitem><para>Maximum number of concurrent uploads to the network.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">connection-speed (integer, default: 28)</itemformat></item>
</tableterm><tableitem><para>This is what we send as our connection speed in KBit/s.  We also use this
value to throttle down the network transfer rate for file uploads.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">min-speed (integer, default: 28)</itemformat></item>
</tableterm><tableitem><para>Search for needles on hosts with a minimum speed.  Set it to 0 if you do
not care about that.  This value is in KBit/s, too.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">file-extensions (string array, default: empty list)</itemformat></item>
</tableterm><tableitem><para>If we get replies on search queries we check if the file extension of this
reply matches one of these extensions.  Useful extensions are <samp>mp3</samp> and
<samp>mpg</samp>.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">connections (integer, default: 4)</itemformat></item>
</tableterm><tableitem><para>This is the number of concurrent connections the Gnutella spider tries
to keep up to the network.  The IP addresses and the port information is
taken from the host catcher hash.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">force-ip (string, default: not set)</itemformat></item>
</tableterm><tableitem><para>You can force the Gnutella spider to send outgoing replies with this
IP as host information.  Must be in dotted decimals notation.  This is
useful if you are behind a masquerading gateway.  You need to install
some kind of port forwarder on the gateway so other people can reach you
from the outside.  Serveez is a good port forwarder.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">force-port (integer, default: not set)</itemformat></item>
</tableterm><tableitem><para>Force the Gnutella spider to send outgoing replies with the
<code>force-port</code> as port information.  See above for more information.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">disable (boolean, default: false)</itemformat></item>
</tableterm><tableitem><para>With this configuration option you can disable the bindings for a Gnutella
server instance.  This means that no remote client can connect without
being told so (e.g., by push requests).
</para></tableitem></tableentry></table>

</subsubsection>
</subsection>
<node name="Tunnel-Server" spaces=" "><nodename>Tunnel Server</nodename><nodenext automatic="on">Fake Ident Server</nodenext><nodeprev automatic="on">Gnutella Spider</nodeprev><nodeup automatic="on">Existing servers</nodeup></node>
<subsection spaces=" "><sectiontitle>Tunnel Server</sectiontitle>

<subsubsection spaces=" "><sectiontitle>General description</sectiontitle>
<para>The Tunnel server is for mapping one port configuration to another.
So we should rather speak of a port forwarder.  Two port forwarders can
form a tunnel.  Generally this means that you can setup Serveez to accept
network or pipe connections in order to pass all transfer data on this
line to another port configuration.  This can be useful to work around
gateways and firewalls.  When instantiating an ICMP source or destination
you must ensure root privileges for the application.  On Windows NT and
Windows 2000 you need to be either logged in as Administrator or have
set the registry key
HKLM\System\CurrentControlSet\Services\Afd\Parameters\DisableRawSecurity
to 1 (DWORD).  One of the given examples in <file>serveez.cfg</file> shows
how you can setup a tunnel server for forwarding a pipe connection.  Please
keep in mind when forwarding a TCP or pipe connection over ICMP or UDP
you loose reliability since the latter two are packet oriented rather than
connection oriented.  We are not willing to implement our own TCP stack to
work on ICMP/UDP directly.
</para>
<para>Forwarding between the same types of connection is always possible.  When
forwarding to an ICMP tunnel we use a special protocol which we will outline
in the following section.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Extended ICMP protocol specification</sectiontitle>
<para>Since ICMP (Internet Control Message Protocol) does have a fixed packet
format we had to extend it in order to use it for our own purposes.  The
protocol field of the IP header contains a binary <samp>1</samp> which is the
identifier for ICMP (e.g., <samp>6</samp> identifies TCP).  When creating an ICMP
socket the IP header is always generated by the kernel.  This is the main
difference to raw sockets where the IP header must be generated at
userspace level.
</para>
<para>When receiving an ICMP packet it also contains the IP header.  When sending
an ICMP packet you must not prepend this IP header.  The kernel will do this
itself.  The IP header always follows the actual ICMP header followed by the
ICMP packet data.  Since this section does not cover raw sockets we leave
the IP header structure out here.
</para>
<para>The modified ICMP message format is as:
</para><multitable spaces=" " endspaces=" "><columnfractions line=" .2 .2 .6"><columnfraction value=".2"></columnfraction><columnfraction value=".2"></columnfraction><columnfraction value=".6"></columnfraction></columnfractions>
<tbody><row><entry command="item" spaces=" "><para>Offset </para></entry><entry command="tab" spaces=" "><para>Size </para></entry><entry command="tab" spaces=" "><para>Meaning
</para></entry></row><row><entry command="item" spaces=" "><para>0 </para></entry><entry command="tab" spaces=" "><para>1 </para></entry><entry command="tab" spaces=" "><para>Message type.
</para></entry></row><row><entry command="item" spaces=" "><para>1 </para></entry><entry command="tab" spaces=" "><para>1 </para></entry><entry command="tab" spaces=" "><para>Message type sub code.
</para></entry></row><row><entry command="item" spaces=" "><para>2 </para></entry><entry command="tab" spaces=" "><para>2 </para></entry><entry command="tab" spaces=" "><para>Checksum.
</para></entry></row><row><entry command="item" spaces=" "><para>4 </para></entry><entry command="tab" spaces=" "><para>2 </para></entry><entry command="tab" spaces=" "><para>Senders unique identifier.
</para></entry></row><row><entry command="item" spaces=" "><para>6 </para></entry><entry command="tab" spaces=" "><para>2 </para></entry><entry command="tab" spaces=" "><para>Sequence number.
</para></entry></row><row><entry command="item" spaces=" "><para>8 </para></entry><entry command="tab" spaces=" "><para>2 </para></entry><entry command="tab" spaces=" "><para>Port number.
</para></entry></row><row><entry command="item" spaces=" "><para>10 </para></entry><entry command="tab" spaces=" "><para>0 - 65506 </para></entry><entry command="tab" spaces=" "><para>Packet load.
</para></entry></row></tbody></multitable>

<para>Each of these fields can be modified and processed by Serveez and do not
get touched by the kernel at all.  The ICMP socket implementation of Serveez
differentiates two types of sockets: listening and connected ICMP sockets.
This is non-standard because it actually makes no sense since there is no
difference for the kernel.  The introduction of these semantics allow
Serveez to forward data between connection-oriented (TCP and named pipes)
and packet-oriented (UDP and ICMP) protocols.
</para>
<table commandarg="asis" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="asis">Message type</itemformat></item>
</tableterm><tableitem><para>Valid message types are for instance <samp>8</samp> for an echo message and
<samp>0</samp> for its echo reply.  These two messages are used for the systems
builtin ping services.  Serveez uses its own message type identifier
which is <samp>42</samp> (<code>ICMP_SERVEEZ</code>) by default.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Message type sub code</itemformat></item>
</tableterm><tableitem><para>Serveez also defines its own message type sub codes described
in the following table.
</para><multitable spaces=" " endspaces=" "><columnfractions line=" .2 .4 .4"><columnfraction value=".2"></columnfraction><columnfraction value=".4"></columnfraction><columnfraction value=".4"></columnfraction></columnfractions>
<tbody><row><entry command="item" spaces=" "><para>Sub code </para></entry><entry command="tab" spaces=" "><para>Constant identifier </para></entry><entry command="tab" spaces=" "><para>Description
</para></entry></row><row><entry command="item" spaces=" "><para>0 </para></entry><entry command="tab" spaces=" "><para><code>ICMP_SERVEEZ_DATA</code> </para></entry><entry command="tab" spaces=" "><para>packet contains data
</para></entry></row><row><entry command="item" spaces=" "><para>1 </para></entry><entry command="tab" spaces=" "><para><code>ICMP_SERVEEZ_REQ</code> </para></entry><entry command="tab" spaces=" "><para>unused
</para></entry></row><row><entry command="item" spaces=" "><para>2 </para></entry><entry command="tab" spaces=" "><para><code>ICMP_SERVEEZ_ACK</code> </para></entry><entry command="tab" spaces=" "><para>unused
</para></entry></row><row><entry command="item" spaces=" "><para>3 </para></entry><entry command="tab" spaces=" "><para><code>ICMP_SERVEEZ_CLOSE</code> </para></entry><entry command="tab" spaces=" "><para>disconnection message
</para></entry></row><row><entry command="item" spaces=" "><para>4 </para></entry><entry command="tab" spaces=" "><para><code>ICMP_SERVEEZ_CONNECT</code> </para></entry><entry command="tab" spaces=" "><para>connect message
</para></entry></row></tbody></multitable>

</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Checksum</itemformat></item>
</tableterm><tableitem><para>The checksum field of the ICMP header is used to check the ICMP headers
and the payloads (packet data) validity.  We are using the standard
Internet Checksum algorithm described in RFC 1071.  If the check failed we
drop the packet.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Senders unique identifier</itemformat></item>
</tableterm><tableitem><para>The senders identifier field is used to determine if a received packet
has been sent by the sender itself and should therefore be dropped.  This
happens because each ICMP socket setup for receiving gets all sent
ICMP packets system wide.  Thus Serveez will even be notified if the kernel
creates some echo reply or destination unreachable message due to a
request completely outside the scope of Serveez.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Sequence number</itemformat></item>
</tableterm><tableitem><para>Each connected ICMP socket increments its sequence number when sending
a packet.  Thus a connection message type packet of such a socket always
has a zero sequence number.  This field could (but is not yet) also be used
to reorder ICMP packets or to detect missing packets.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Port number</itemformat></item>
</tableterm><tableitem><para>The port field of the modified packet format helps Serveez to establish
connected ICMP sockets.  A simple packet filter detects if a received packet
is kind of reply to a sockets sent packets by comparing this port number.
The packet is dropped if the comparison fails and it is not a listening
socket.
</para></tableitem></tableentry></table>

<para>Except the data message type subcode all ICMP packets created and sent by
Serveez have a zero payload.  The connect message subcode identifies a
new connection and the disconnection message subcode its shutdown without
actually transmitting data.  These two subcodes emulate a TCP connections
<code>connect</code>, <code>accept</code> and <code>shutdown</code> system call.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Configuration</sectiontitle>
<para>This might be the most easiest configuration to setup.  You essentially
need to define the source port configuration and the target port
configuration.  The <file>serveez.cfg</file> in the <file>data/</file>
directory shows two example configurations how to tunnel TCP
connections over UDP and ICMP.  The UDP tunnel accesses the standard
HTTP port 80 and the ICMP tunnel accesses the standard Telnet port 23.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">source (port configuration, no default)</itemformat></item>
</tableterm><tableitem><para>The source port configuration.  This is usually the same you bind the server
to.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">target (port configuration, no default)</itemformat></item>
</tableterm><tableitem><para>The target port configuration.
</para></tableitem></tableentry></table>

</subsubsection>
</subsection>
<node name="Fake-Ident-Server" spaces=" "><nodename>Fake Ident Server</nodename><nodenext automatic="on">Passthrough Server</nodenext><nodeprev automatic="on">Tunnel Server</nodeprev><nodeup automatic="on">Existing servers</nodeup></node>
<subsection spaces=" "><sectiontitle>Fake Ident Server</sectiontitle>

<subsubsection spaces=" "><sectiontitle>General description</sectiontitle>

<para>Most systems run the &textrsquo;ident protocol&textrsquo; on port 113.  Internet hosts can connect
to that port and find out what user is having a connection to the host.  For
example a webserver can query your username when you fetch a file (e.g.,
Serveez&textrsquo; internal ident-coserver can do that).
Most IRC servers protect themselves by allowing only users that have a valid
ident response.  Therefore mIRC (for windoze) has a built in ident server.
This fake ident server can be used to &textrsquo;fake&textrsquo; a response.  This is useful
when you connect through a masquerading gateway and the gateway cannot handle
ident requests correctly.  (Or, of course, you are using windoze, need an
ident response and do not have mIRC at hand.)
</para>
<para>This server has two modes of operation.  In one mode all requests get
<samp>ERROR : NO-USER</samp> as response.  This is a valid but not very helpful response.
The other mode makes the server send a valid and useful response.  It contains
a system type and a username.  The system type is usually &textrsquo;UNIX&textrsquo;.  Others are
valid but never used (at least i have never seen something else).
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Configuration</sectiontitle>

<para>This server is easy to configure.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">systemtype (string, default: UNIX)</itemformat></item>
</tableterm><tableitem><para>The system type to respond.  The username field of the response has other
meanings depending on this field, so do not make things up here.  Read
the RFC to learn more.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">username (string, default: &lt;NULL&gt;)</itemformat></item>
</tableterm><tableitem><para>If no username is set (which means this field does not appear in the
configuration file) the server runs in the flag-all-requests-as-error mode.
Use your favourite nickname here.
</para></tableitem></tableentry></table>

</subsubsection>
</subsection>
<node name="Passthrough-Server" spaces=" "><nodename>Passthrough Server</nodename><nodenext automatic="on">Mandel Server</nodenext><nodeprev automatic="on">Fake Ident Server</nodeprev><nodeup automatic="on">Existing servers</nodeup></node>
<subsection spaces=" "><sectiontitle>Passthrough Server</sectiontitle>

<subsubsection spaces=" "><sectiontitle>General description</sectiontitle>
<para>The program passthrough server provides basic inetd functionality.
Basically it can accept connections and pass this connection to the standard
input (stdin) and standard output (stdout) handles of programs.  Depending
on the platform (operating system) the user is able to configure different
methods how this can be achieved.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Configuration</sectiontitle>
<para>This server has different types of configuration options specifying its
behaviour.  Some of them are mandatory and some are optional.  The very
least to configure is the program to be started when a new connection is
made.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">binary (string, no default)</itemformat></item>
</tableterm><tableitem><para>This parameter specifies the program to execute when a new connection
has been accepted.  The parameter is mandatory and must be a fully qualified
file name (including path).
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">directory (string, no default)</itemformat></item>
</tableterm><tableitem><para>This will be the working directory of the executed program.  If you omit
this parameter the server uses the current directory (the directory is not
changed).
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">user (string, no default)</itemformat></item>
</tableterm><tableitem><para>If you omit this parameter no user or group will be set for the
started program.  Otherwise you need to specify this information in the
format <samp>user[.group]</samp>.  If the group is omitted the user&textrsquo;s primary
group will be used.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">argv (string array, no default)</itemformat></item>
</tableterm><tableitem><para>This list of character strings is going to be the program&textrsquo;s argument list
(command line).  If the first list item (which is argv[0] and the program&textrsquo;s
name) is left blank it defaults to the name specified in the
<code>binary</code> parameter.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">do-fork (boolean, default: true)</itemformat></item>
</tableterm><tableitem><para>This flag specifies the method used to pass the connection to the program.
If it is true the server uses the Unix&textrsquo;ish <code>fork</code> and <code>exec</code>
method.  Otherwise it will pass the data through a unnamed pair of
sockets [ or two pairs of anonymous pipes ].
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">single-threaded (boolean, default: true)</itemformat></item>
</tableterm><tableitem><para>This parameter applies to servers bound to UDP and ICMP port configurations
only.  For programs which process all incoming packets and eventually time
out, the program is said to be <samp>single-threaded</samp> and should use a true
value here.  If a program gets a packet and can receive further packets, it
is said to be a <samp>multi-threaded</samp> program, and should use a false value.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">thread-frequency (integer, default: 40)</itemformat></item>
</tableterm><tableitem><para>The optional <code>thread-frequency</code> parameter specifies the maximum number
of program instances that may be spawned from the server within an interval
of 60 seconds.
</para></tableitem></tableentry></table>

</subsubsection>
</subsection>
<node name="Mandel-Server" spaces=" "><nodename>Mandel Server</nodename><nodeprev automatic="on">Passthrough Server</nodeprev><nodeup automatic="on">Existing servers</nodeup></node>
<subsection spaces=" "><sectiontitle>Mandel Server</sectiontitle>

<html endspaces=" ">
&lt;pre&gt;[ Example Mandelbrot picture. ]&lt;/pre&gt;
&lt;img src=&quot;mandel.jpg&quot; border=&quot;0&quot; width=&quot;320&quot; height=&quot;240&quot;
     alt=&quot;Mandelbrot Set&quot;&gt;
</html>

<subsubsection spaces=" "><sectiontitle>General description</sectiontitle>
<para>The distributed Mandelbrot server is an Internet server completely written
in Guile with the help of the API provided by the underlying Serveez
application.  The reader will not see any occurrence of the networking API
of Guile.
</para>
<para>It implements a protocol called <samp>dnc</samp>.  <samp>dnc</samp> - short for
&textldquo;Distributed Number Cruncher&textrdquo;.  The Mandelbrot server manages the
computation of a graphic visualization of the Mandelbrot set fractal.
Each client can connect to the server and ask for something to calculate
and is meant to send its result back to the server.  Finally the server
produces a bitmap in the XPM format and uses a specified viewer
application to bring it onto your screen.
</para>
</subsubsection>
<subsubsection spaces=" "><sectiontitle>Configuration</sectiontitle>
<para>The server can be setup to manage the calculation of the Mandelbrot set at
various locations (rectangular region in the complex plane), in a specific
pixel resolution and colour depth.  Moreover you can define the name of the
final output file and the viewer application the output file is displayed
with.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">start (string, default: -2.0-1.5i)</itemformat></item>
</tableterm><tableitem><para>Specifies the upper left corner of the final bitmap in the complex plane.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">end (string, default: +1.1+1.5i)</itemformat></item>
</tableterm><tableitem><para>Specifies the lower right corner of the final bitmap in the complex plane.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">x-res (integer, default: 320)</itemformat></item>
</tableterm><tableitem><para>The real part pixel resolution.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">y-res (integer, default: 240)</itemformat></item>
</tableterm><tableitem><para>The imaginary part pixel resolution.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">colors (integer, default: 256)</itemformat></item>
</tableterm><tableitem><para>Number of maximum colours used in the bitmap.  Also determines the maximum
iteration depth.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">outfile (string, default: mandel.xpm)</itemformat></item>
</tableterm><tableitem><para>When the Mandel server has managed to calculate the whole bitmap it produces
an output file in the XPM format.  You can specify the name and location of
this output file.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">viewer (string, default: xv)</itemformat></item>
</tableterm><tableitem><para>Here you can setup your favourite bitmap viewer application.  It should be
able to parse and display the XPM format.
</para></tableitem></tableentry></table>

</subsubsection>
</subsection>
</section>
</chapter>
<node name="Coserver" spaces=" "><nodename>Coserver</nodename><nodenext automatic="on">Embedding</nodenext><nodeprev automatic="on">Server</nodeprev><nodeup automatic="on">Top</nodeup></node>
<chapter spaces=" "><sectiontitle>Coserver</sectiontitle>

<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::         ">What are coservers</menunode><menudescription><pre xml:space="preserve">The use of coservers in Serveez
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::          ">Writing coservers</menunode><menudescription><pre xml:space="preserve">How to write coservers with Serveez
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::         ">Existing coservers</menunode><menudescription><pre xml:space="preserve">What kind of coservers already exist ?
</pre></menudescription></menuentry></menu>

<node name="What-are-coservers" spaces=" "><nodename>What are coservers</nodename><nodenext automatic="on">Writing coservers</nodenext><nodeup automatic="on">Coserver</nodeup></node>
<section spaces=" "><sectiontitle>What are coservers</sectiontitle>

<para>If it is necessary to complete blocking tasks in Serveez you have
to use coservers.  The actual implementation differs on platforms.  On Unices
they are implemented as processes communicating with Serveez over pipes.
On Win32 Serveez uses threads and shared memory.
</para>
</section>
<node name="Writing-coservers" spaces=" "><nodename>Writing coservers</nodename><nodenext automatic="on">Existing coservers</nodenext><nodeprev automatic="on">What are coservers</nodeprev><nodeup automatic="on">Coserver</nodeup></node>
<section spaces=" "><sectiontitle>Writing coservers</sectiontitle>

<subsection spaces=" "><sectiontitle>Making and configuring preparations</sectiontitle>

<para>First you have to change into the <file>src/libserveez/coserver/</file>
directory of the Serveez package.  Then edit the <file>Makefile.am</file> and
add your header and implementation file to the <code>libcoserver_la_SOURCES</code>
variable.
</para>
</subsection>
<subsection spaces=" "><sectiontitle>Coserver header file</sectiontitle>

<para>You have to declare the coserver handle routine here.  This callback
gets the input buffer argument and delivers the output buffer result.
Both of these buffers are supposed to be lines separated by a <samp>\n</samp>.
</para>
</subsection>
<subsection spaces=" "><sectiontitle>Coserver implementation file</sectiontitle>

<para>Here you need to <code>#include &quot;libserveez/coserver/coserver.h&quot;</code> and
implement the coserver handle routine declared in the coserver header file.
This can be any blocking system call.  On successful completion you
can return the result or <code>NULL</code> on errors.  The input and output
buffers are plain strings and can have any format with one exception.
Because the coservers communicate via a line protocol with
Serveez these buffers must not contain <samp>\n</samp> (0x0d).
</para>
</subsection>
<subsection spaces=" "><sectiontitle>Make your coserver available in Serveez</sectiontitle>

<para>For this you have to edit <file>coserver.h</file> and <file>coserver.c</file> files
which are located in the <file>src/libserveez/coserver/</file> directory.  In
the header file you have to define a further <code>COSERVER_*</code> id
(macro) and set the <code>MAX_COSERVER_TYPES</code> define to the appropriate
value.  Then you should define a further <code>svz_coserver_*</code> macro in
the same file.
</para>
<para>In <file>coserver.c</file> you have to implement the <code>svz_coserver_*</code> macro.
This macro takes three arguments.  The first is always specific to your
coserver and is used to create the actual request string.  Then follows the
result callback routine, and an optional argument for this callback.  The
latter two are simply passed to the <code>svz_coserver_send_request</code>
routine.  This routine takes four arguments where the first is the
previously defined <code>COSERVER_*</code> id and the second is the input buffer
for the coserver handle routine without the trailing <samp>\n</samp>.
</para>
<para>Then you need to add your coserver to the <code>svz_coservertypes</code> array
specifying the <code>COSERVER_*</code> id, the coserver description, the coserver
handle routine discussed above, the number of coserver instances to be
created and an optional initialization routine.
</para>
</subsection>
</section>
<node name="Existing-coservers" spaces=" "><nodename>Existing coservers</nodename><nodeprev automatic="on">Writing coservers</nodeprev><nodeup automatic="on">Coserver</nodeup></node>
<section spaces=" "><sectiontitle>Existing coservers</sectiontitle>

<subsection spaces=" "><sectiontitle>Identification (Ident) coserver</sectiontitle>

<para>The Identification protocol is briefly documented in RFC1413.  It
provides a means to determine the identity of a user of a particular
TCP connection.  Given a TCP port number pair, it returns a character
string which identifies the owner of that connection on the server&textrsquo;s
(that is the client&textrsquo;s) system.
</para>
<para>This is a connection based application on TCP.  A server listens for
TCP connections on TCP port 113 (decimal).  Once a connection is
established, the server reads a line of data which specifies the
connection of interest.  If it exists, the system dependent user
identifier of the connection of interest is sent as the reply.  The
server may then either shut down the connection or it may continue to
read/respond to more queries.
</para>
<para>The Ident coserver is a client to this kind of service.  For
every established network connection you can use this service by calling
the appropriate macro from <file>coserver.h</file>.  But you could also use the
Ident coserver as is without this macro.
The messages from Serveez to this coserver are formatted this way:
</para>
<example endspaces=" ">
<pre xml:space="preserve">Format:
RemoteAddressInDottedDecimals &quot;:&quot; RemotePort &quot;:&quot; LocalPort

Macro:
svz_coserver_ident (sock, MyIdentCallback, sock-&gt;id, sock-&gt;version);
</pre></example>

<para>In this context <code>sock</code> is of type <code>svz_socket_t</code> and
<code>MyIdentCallback</code> is something like the following example.  Both
of the last two (optional) arguments identify a valid socket structure
and <code>user</code> can be <code>NULL</code> if there is no ident daemon running on the
foreign machine.  The last two argument within the above macro will be the
last two arguments in the callback below.  Thus you will know what kind of
data the invocation of the callback is related to.
</para>
<example endspaces=" ">
<pre xml:space="preserve">Callback:
int
MyIdentCallback (char *user, int id, int version)
&lbrace;
  printf (&quot;Identified user: %s\n&quot;, user);
  return 0;
&rbrace;
</pre></example>

</subsection>
<subsection spaces=" "><sectiontitle>Domain Name Server (DNS) coserver</sectiontitle>

<para>The DNS coserver is using <code>gethostbyname</code> to translate a given
hostname to the associated IP address.  The format of the coserver input
line and the macro from <file>coserver.h</file> is shown below.  The IRC server is
currently using this coserver for resolving its <samp>?-Lines</samp>.
<xref><xrefnodename>Existing servers</xrefnodename></xref>, for more information.  In the example below
<code>realhost</code> is something like <samp>www.lkcc.org</samp>.
</para>
<example endspaces=" ">
<pre xml:space="preserve">Format:
RemoteHostname

Macro:
svz_coserver_dns (realhost, irc_connect_server, ircserver, NULL);

Callback:
int
irc_connect_server (char *ip, irc_server_t *server)
&lbrace;
  printf (&quot;The ip address is: %s\n&quot;, ip);
  return 0;
&rbrace;
</pre></example>

</subsection>
<subsection spaces=" "><sectiontitle>Reverse Domain Name Server (reverse DNS) coserver</sectiontitle>

<para>As easily guessed from the name this coserver is just doing the reverse
as the DNS coserver.  It translates a given IP address into a hostname
using <code>gethostbyaddr</code>.  In the macro the ip address is given
as an <code>unsigned long</code> in host byte order.  The Reverse DNS
coserver itself takes something like <samp>192.168.2.1</samp>.
</para>
<example endspaces=" ">
<pre xml:space="preserve">Format:
RemoteAddressInDottedDecimals

Macro:
svz_coserver_reverse (addr, MyReverseCallback, sock-&gt;id, sock-&gt;version);

Callback:
int
MyReverseCallback (char *host, int id, int version)
&lbrace;
  printf (&quot;Hostname is: %s\n&quot;, host);
  return 0;
&rbrace;
</pre></example>

</subsection>
</section>
</chapter>
<node name="Embedding" spaces=" "><nodename>Embedding</nodename><nodenext automatic="on">Porting issues</nodenext><nodeprev automatic="on">Coserver</nodeprev><nodeup automatic="on">Top</nodeup></node>
<chapter spaces=" "><sectiontitle>Embedding</sectiontitle>
<cindex index="cp" spaces=" "><indexterm index="cp">embedding</indexterm></cindex>

<!-- c -*-texinfo-*- -->
<!-- c -->
<!-- c This file includes the embedding documentation. -->
<!-- c It is included by `serveez.texi'. -->
<!-- c -->

<para>This chapter documents how to embed Serveez into C programs and describes
all parts of the API it provides.
</para>
<para>The Serveez core library provides all of the functionality necessary in
order to write Internet protocol servers (currently TCP, UDP, ICMP and
RAW sockets), pipe servers (connection-oriented via a pair of named
pipes) and coservers in a portable way.  All of the included servers are
based upon this library, which encapsulates the native network and file
system programming interface of different Unices and Windows systems.
</para>
<para>The following sections will give the reader
an overview about how to use its core library.
</para>
<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::     ">Embedding Serveez</menunode><menudescription><pre xml:space="preserve">How to embed Serveez into C programs
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::         ">Embedding API</menunode><menudescription><pre xml:space="preserve">Description of functions and data in the library
</pre></menudescription></menuentry></menu>

<node name="Embedding-Serveez" spaces=" "><nodename>Embedding Serveez</nodename><nodenext automatic="on">Embedding API</nodenext><nodeup automatic="on">Embedding</nodeup></node>
<section spaces=" "><sectiontitle>Embedding Serveez</sectiontitle>

<para>This chapter deals with embedding the Serveez core library into standalone
C/C++ applications and using it in order to write additional servers.
</para>
<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::      ">Compiling and linking</menunode><menudescription><pre xml:space="preserve">How to compile and link against the library
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::           ">A simple example</menunode><menudescription><pre xml:space="preserve">A very small example showing the basics
</pre></menudescription></menuentry></menu>

<node name="Compiling-and-linking" spaces=" "><nodename>Compiling and linking</nodename><nodenext automatic="on">A simple example</nodenext><nodeup automatic="on">Embedding Serveez</nodeup></node>
<subsection spaces=" "><sectiontitle>Compiling and linking</sectiontitle>

<para>When you have installed a version of Serveez passing the
<file>configure</file> script the <code>$prefix</code> argument, e.g.,
<samp>./configure --prefix=/usr/local</samp>, you will find the
<file>libserveez</file> library in <file>/usr/local/lib</file> and the include
headers in <file>/usr/local/include</file>.  If you want to compile a C
program using the Serveez API and link against the Serveez core library
<code>libserveez</code>, which is <file>libserveez.so</file> for Unices and
<file>libserveez.dll</file> for Windows systems, you need to tell the compiler
and linker where to find the headers and libraries.
</para>
<para>Most C compilers you can use will understand the following command line
options for this purpose.  The <samp>-I</samp> argument specifies the
directory of additional include headers, the <samp>-L</samp> argument the
direcory to additional libraries and the <samp>-l</samp> argument the library
itself to link against.
</para>
<example endspaces=" ">
<pre xml:space="preserve">$ cc test.c -I/usr/local/include -o test -L/usr/local/lib -lserveez
</pre></example>

<para>In order to obtain the correct compiler and linker flag you can also run
the <samp>serveez-config</samp> script which gets installed with the Serveez
package.  The <samp>serveez-config</samp> script can be invoked with the
following set of option.
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">-h, --help</itemformat></item>
</tableterm><tableitem><para>Displays the usage information.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">-v, --version</itemformat></item>
</tableterm><tableitem><para>Displays installed Serveez version.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">-l, --ldflags</itemformat></item>
</tableterm><tableitem><para>Prints the linker flags (libraries to link with including
directory information).
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">-c, --cflags</itemformat></item>
</tableterm><tableitem><para>Prints the compiler flags to compile with.
</para></tableitem></tableentry></table>

</subsection>
<node name="A-simple-example" spaces=" "><nodename>A simple example</nodename><nodeprev automatic="on">Compiling and linking</nodeprev><nodeup automatic="on">Embedding Serveez</nodeup></node>
<subsection spaces=" "><sectiontitle>A simple example</sectiontitle>

<para>The following small example shows how to use the Serveez core library to
print the list of known network interface.  As you will notice there are
three major steps to do: Include the library header with <code>#include
&lt;libserveez.h&gt;</code>, initialize the library via <code>svz_boot</code> and finalize
it via <code>svz_halt</code>.  In between these calls you can use all of the
API functions, variables and macros described in <ref><xrefnodename>Embedding API</xrefnodename></ref>.
</para>
<example endspaces=" ">
<pre xml:space="preserve">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;libserveez.h&gt;

static int
display_ifc (const svz_interface_t *ifc,
             void *closure)
&lbrace;
  char *addr = svz_inet_ntoa (ifc-&gt;ipaddr);

  if (ifc-&gt;description)
    /* interface with description */
    printf (&quot;%40s: %s\n&quot;,
            ifc-&gt;description, addr);
  else
    /* interface with interface # only */
    printf (&quot;%31s%09lu: %s\n&quot;,
            &quot;interface # &quot;, ifc-&gt;index, addr);
  return 0;
&rbrace;

int
main (int argc, char **argv)
&lbrace;
  /* Library initialization.  */
  svz_boot (&quot;example&quot;);

  /* Display a list of interfaces.  */
  printf (&quot;local interfaces:\n&quot;);
  svz_foreach_interface (display_ifc, NULL);

  /* Library finalization.  */
  svz_halt ();

  return EXIT_SUCCESS;
&rbrace;
</pre></example>

</subsection>
</section>
<node name="Embedding-API" spaces=" "><nodename>Embedding API</nodename><nodeprev automatic="on">Embedding Serveez</nodeprev><nodeup automatic="on">Embedding</nodeup></node>
<section spaces=" "><sectiontitle>Embedding API</sectiontitle>

<para>In this chapter the reader will find a short description of each
function, global variable and macro provided by the Serveez core
library.  The API can either be used to implement a new server or
coserver module for use with Serveez or for supporting network and
server functionality within your own applications without caring about
the details and system programming.
</para>
<para>Most of the Serveez core library interface functionality should be
prefixed with <code>svz_</code>.  Small symbols will refer to functions and
variables in most cases and big letter symbols refer to macros.
</para>
<para>[FIXME: The subsections are named inconsistently because
originally, the API reference was a separate document; on merge,
weirdness like &textldquo;Port config funcs&textrdquo; was necessary to avoid
conflict with the other &textldquo;Port configuration&textrdquo; node. &textmdash;ttn]
</para>
<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::      ">Library features</menunode><menudescription><pre xml:space="preserve">A high-level list of what libserveez provides
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::     ">Memory management</menunode><menudescription><pre xml:space="preserve">How memory is managed in Serveez
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::       ">Data structures</menunode><menudescription><pre xml:space="preserve">Data structure helpers
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::         ">svz_address_t</menunode><menudescription><pre xml:space="preserve">A data type to hold family plus bits
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::     ">Utility functions</menunode><menudescription><pre xml:space="preserve">Miscellaneous helper functions
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::        ">Core functions</menunode><menudescription><pre xml:space="preserve">Network core implementations
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::    ">Client connections</menunode><menudescription><pre xml:space="preserve">Client connection functions
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::     ">Socket management</menunode><menudescription><pre xml:space="preserve">Socket management functions
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::    ">Coserver functions</menunode><menudescription><pre xml:space="preserve">Coserver interface
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::       ">Codec functions</menunode><menudescription><pre xml:space="preserve">Codec interface
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::          ">Server types</menunode><menudescription><pre xml:space="preserve">Server type implementations
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::      ">Server functions</menunode><menudescription><pre xml:space="preserve">Server object functions
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::     ">Port config funcs</menunode><menudescription><pre xml:space="preserve">Port configuration functions
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::               ">Booting</menunode><menudescription><pre xml:space="preserve">Configuration and boot functions
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::             ">Interface</menunode><menudescription><pre xml:space="preserve">Network interface function implementation
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::               ">Windoze</menunode><menudescription><pre xml:space="preserve">Windows port implementations
</pre></menudescription></menuentry></menu>

<node name="Library-features" spaces=" "><nodename>Library features</nodename><nodenext automatic="on">Memory management</nodenext><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Library features</sectiontitle>

<para>The <file>configure</file> script used to build libserveez takes many options
(<pxref><xrefnodename>Build and install</xrefnodename></pxref>).
Some of these are encapsulated by <code>svz_library_features</code>.
</para>
<set name="TSINCURMOD" line=" TSINCURMOD (-- s3as sez thx tsin --)">(-- s3as sez thx tsin --)</set>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_library_features</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">const char * const *</deftype> <deffunction>svz_library_features</deffunction> <defdelimiter>(</defdelimiter><defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>count</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return a list (length saved to <var>count</var>) of strings
representing the features compiled into libserveez.
</para></definitionitem></deftypefun>

<noindent></noindent>
<para>Here is a table describing the features in detail:
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">debug</itemformat></item>
</tableterm><tableitem><para>Present when <samp>--enable-debug</samp>.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">heap-counters</itemformat></item>
</tableterm><tableitem><para>Present when <samp>--enable-heap-count</samp>.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">interface-list</itemformat></item>
</tableterm><tableitem><para>Present when <samp>--enable-iflist</samp>.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">poll</itemformat></item>
</tableterm><tableitem><para>Present when <samp>--enable-poll</samp> and you have poll(2).
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">sendfile</itemformat></item>
</tableterm><tableitem><para>Present when <samp>--enable-sendfile</samp> and you have sendfile(2)
or some workalike (e.g., <code>TransmitFile</code>).
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">log-mutex</itemformat></item>
</tableterm><tableitem><para>Present when <code>svz_log</code> uses a mutex around its internal stdio
operations, implying that you have some kind of thread capability
(perhaps in a separate library).  If your system has
<code>fwrite_unlocked</code>, the configure script assumes that <code>fwrite</code>
et al already operate in a locked fashion, and disables this.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">flood-protection</itemformat></item>
</tableterm><tableitem><para>Present when <samp>--enable-flood</samp>.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">core</itemformat></item>
</tableterm><tableitem><para>The networking core.  This is always present.
</para></tableitem></tableentry></table>

</subsection>
<node name="Memory-management" spaces=" "><nodename>Memory management</nodename><nodenext automatic="on">Data structures</nodenext><nodeprev automatic="on">Library features</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Memory management</sectiontitle>

<para>The core library of Serveez is able to keep track of the memory an
application or part of a program consumes, and also controls itself in
the same manner.  When you are using this memory allocator interface you
can determine and afterwards remove memory leaks.  This is a very
important feature as servers are by nature long-lived programs.
</para>
<para>The three allocator function pointers for <code>malloc</code>, <code>realloc</code>
and <code>free</code> make it possible to instruct Serveez to use different
kinds of memory, which might be necessary if you want the library to work
with shared memory arenas or any other underlying memory API.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_set_mm_funcs</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_set_mm_funcs</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_malloc_func_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>cus_malloc</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_realloc_func_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>cus_realloc</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_free_func_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>cus_free</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Set the internal memory management functions to <var>cus_malloc</var>,
<var>cus_realloc</var> and <var>cus_free</var>, respectively.
The default internal values are <code>malloc</code>, <code>realloc</code>
and <code>free</code>.
</para></definitionitem></deftypefun>

<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_malloc</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void *</deftype> <deffunction>svz_malloc</deffunction> <defdelimiter>(</defdelimiter><defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>size</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Allocate <var>size</var> bytes of memory and return a pointer to this block.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_calloc</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void *</deftype> <deffunction>svz_calloc</deffunction> <defdelimiter>(</defdelimiter><defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>size</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Allocate <var>size</var> bytes of memory and return a pointer to this block.
The memory is cleared (filled with zeros).
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_realloc</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void *</deftype> <deffunction>svz_realloc</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>ptr</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>size</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Change the size of a block of memory at <var>ptr</var>, previously
returned by <code>svz_malloc</code>, to <var>size</var> bytes.  If <var>ptr</var>
is <code>NULL</code>, allocate a new block.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_free</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_free</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>ptr</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Free a block of memory at <var>ptr</var>, previously returned by
<code>svz_malloc</code> or <code>svz_realloc</code>.  If <var>ptr</var> is
<code>NULL</code>, do nothing.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_strdup</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">char *</deftype> <deffunction>svz_strdup</deffunction> <defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>src</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Duplicate the given string <var>src</var> if it is not <code>NULL</code> and has
non-zero length.  Return the new string.
</para></definitionitem></deftypefun>

<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_get_curalloc</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_get_curalloc</deffunction> <defdelimiter>(</defdelimiter><defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>to</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Write values to <code>to[0]</code> and <code>to[1]</code> representing the
number of currently allocated bytes and blocks, respectively.
If Serveez was not configured with <samp>--enable-debug</samp>,
the values are always 0.
</para></definitionitem></deftypefun>

</subsection>
<node name="Data-structures" spaces=" "><nodename>Data structures</nodename><nodenext automatic="on">svz_address_t</nodenext><nodeprev automatic="on">Memory management</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Data structures</sectiontitle>

<para>Since most servers need to store information about its clients or want
to keep track of data during runtime, we include a pair of of useful
data structures.  The actual aim was to provide higher level data
structures which the C programming language does not support.  Some of
the included servers which come with Serveez make extensive use of them.
</para>
<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::                 ">Array</menunode><menudescription><pre xml:space="preserve">A growable array implementation
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::             ">Hashtable</menunode><menudescription><pre xml:space="preserve">Hashtable implementation
</pre></menudescription></menuentry></menu>

<node name="Array" spaces=" "><nodename>Array</nodename><nodenext automatic="on">Hashtable</nodenext><nodeup automatic="on">Data structures</nodeup></node>
<subsubsection spaces=" "><sectiontitle>Array</sectiontitle>

<para>The array data structure is a simple array implementation.  Each array
has a size and capacity.  The array indices range from zero to the
array&textrsquo;s size minus one.  You can put any kind of data into this array
which fits into the size of a pointer.  The array grows automatically if
necessary.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_array_create</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_array_t *</deftype> <deffunction>svz_array_create</deffunction> <defdelimiter>(</defdelimiter><defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>capacity</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_free_func_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>destroy</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Create a new array with the initial capacity <var>capacity</var> and return
a pointer to it.  If <var>capacity</var> is zero it defaults to some value.
If <var>destroy</var> is non-<code>NULL</code>, <code>svz_array_destroy</code> calls
that function (typically used to free dynamically allocated memory).
For example, if the array contains data allocated by <code>svz_malloc</code>,
<var>destroy</var> should be specified as <code>svz_free</code>.  If the array
contains data which should not be released, <var>destroy</var> should
be <code>NULL</code>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_array_destroy</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_array_destroy</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_array_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>array</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Completely destroy the array <var>array</var>.  The <var>array</var> handle is
invalid afterwards.  The routine runs the <var>destroy</var> callback for each
element of the array.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_array_get</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void *</deftype> <deffunction>svz_array_get</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_array_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>array</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>index</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the array element at the position <var>index</var> of the array
<var>array</var> if the index is within the array range.  Return <code>NULL</code>
if not.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_array_set</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void *</deftype> <deffunction>svz_array_set</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_array_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>array</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>index</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>value</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Replace the array element at the position <var>index</var> of the array
<var>array</var> with the value <var>value</var> and return the previous value
at this index.  Return <code>NULL</code> and do nothing
if <var>array</var> is <code>NULL</code> or the <var>index</var> is out of the array
range.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_array_add</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_array_add</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_array_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>array</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>value</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Append the value <var>value</var> at the end of the array <var>array</var>.
Do nothing if <var>array</var> is <code>NULL</code>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_array_del</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void *</deftype> <deffunction>svz_array_del</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_array_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>array</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>index</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Remove the array element at the position <var>index</var> of the array
<var>array</var>.  Return its previous value or <code>NULL</code> if the index
is out of the array&textrsquo;s range.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_array_size</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">size_t</deftype> <deffunction>svz_array_size</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_array_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>array</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the current size of <var>array</var>.
</para></definitionitem></deftypefun>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_array_foreach</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>svz_array_foreach</deffunction> <defdelimiter>(</defdelimiter><defparam>array</defparam><defdelimiter>,</defdelimiter> <defparam>value</defparam><defdelimiter>,</defdelimiter> <defparam>i</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Expand into a <code>for</code>-statement header, for iterating over
<var>array</var>.  On each cycle, <var>value</var> is assigned to successive
elements of <var>array</var>, and <var>i</var> the element&textrsquo;s position.
</para></definitionitem></defmac>

</subsubsection>
<node name="Hashtable" spaces=" "><nodename>Hashtable</nodename><nodeprev automatic="on">Array</nodeprev><nodeup automatic="on">Data structures</nodeup></node>
<subsubsection spaces=" "><sectiontitle>Hashtable</sectiontitle>

<para>A hashtable associates keys of arbitrary size and content with values.
This data structure is also called associative array sometimes because
you use keys in order to access values instead of numbers.  You cannot
store two values associated with the same key.  The values can have any
simple C types like integers or pointers.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_hash_create</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_hash_t *</deftype> <deffunction>svz_hash_create</deffunction> <defdelimiter>(</defdelimiter><defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>size</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_free_func_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>destroy</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Create a new hash table with an initial capacity <var>size</var>.  Return a
non-zero pointer to the newly created hash.  The size is calculated down
to a binary value.  The <var>destroy</var> callback specifies an
element destruction callback for use by <code>svz_hash_clear</code> and
<code>svz_hash_destroy</code> for each value.  If no such operation should be
performed the argument must be <code>NULL</code>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_hash_configure</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_hash_t *</deftype> <deffunction>svz_hash_configure</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_hash_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>hash</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defdelimiter>(</defdelimiter><defparamtype>*</defparamtype><defparam>&nbsp;</defparam><defparamtype>keylen</defparamtype><defdelimiter>)</defdelimiter><defparam>&nbsp;</defparam><defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defdelimiter>)</defdelimiter><defparam>&nbsp;</defparam><defparam><var></var></defparam><defdelimiter>,</defdelimiter> <defparamtype>unsigned</defparamtype><defparam>&nbsp;</defparam><defparamtype>long</defparamtype><defparam>&nbsp;</defparam><defdelimiter>(</defdelimiter><defparamtype>*</defparamtype><defparam>&nbsp;</defparam><defparamtype>code</defparamtype><defdelimiter>)</defdelimiter><defparam>&nbsp;</defparam><defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defdelimiter>)</defdelimiter><defparam>&nbsp;</defparam><defparam><var></var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defdelimiter>(</defdelimiter><defparamtype>*</defparamtype><defparam>&nbsp;</defparam><defparamtype>equals</defparamtype><defdelimiter>)</defdelimiter><defparam>&nbsp;</defparam><defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var></var></defparam><defdelimiter>,</defdelimiter> <defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var></var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Set the internal <var>keylen</var>, <var>code</var> and and <var>equals</var>
functions for hash table <var>hash</var>.  Return <var>hash</var>.
</para>
<para><var>keylen</var> takes <code>const char *data</code> and returns <code>size_t</code>,
the number of bytes in <var>data</var> representing the key.
</para>
<para><var>code</var> takes <code>const char *data</code>
and returns <code>unsigned long</code>.
</para>
<para><var>equals</var> takes <code>const char *data1, const char *data2</code>
and returns <code>int</code>, which should be non-zero if equal.
</para>
<para>As a special case, a <code>NULL</code> value means don&textrsquo;t set that function,
leaving it to its default value.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_hash_destroy</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_hash_destroy</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_hash_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>hash</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Destroy the existing hash table <var>hash</var>, <code>svz_free</code>ing
all keys within the hash, the hash table and the hash itself.
If a non-<code>NULL</code> element destruction callback was specified to
<code>svz_hash_create</code>, that function is called on each value.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_hash_delete</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void *</deftype> <deffunction>svz_hash_delete</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_hash_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>hash</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>key</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Delete an existing entry accessed via a <var>key</var> from the
hash table <var>hash</var>.  Return <code>NULL</code> if there is no
such key, otherwise the previous value.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_hash_put</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void *</deftype> <deffunction>svz_hash_put</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_hash_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>hash</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>key</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>value</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Add a new element consisting of <var>key</var> and <var>value</var> to <var>hash</var>.
When <var>key</var> already exists, replace and return the old value.
<strong>Note</strong>: This is sometimes the source of memory leaks.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_hash_get</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void *</deftype> <deffunction>svz_hash_get</deffunction> <defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>svz_hash_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>hash</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>key</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the value associated with <var>key</var> in the hash table
<var>hash</var>, or <code>NULL</code> if there is no such key.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_hash_foreach</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_hash_foreach</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_hash_do_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>func</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_hash_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>hash</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>closure</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Iterate <var>func</var> over each key/value pair in <var>hash</var>.
<var>func</var> is called with three <code>void *</code> args: the key,
the value and the opaque (to <code>svz_hash_foreach</code>) <var>closure</var>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_hash_size</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">size_t</deftype> <deffunction>svz_hash_size</deffunction> <defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>svz_hash_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>hash</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the number of keys in the hash table <var>hash</var>.
If <var>hash</var> is <code>NULL</code>, return zero.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_hash_contains</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">char *</deftype> <deffunction>svz_hash_contains</deffunction> <defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>svz_hash_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>hash</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>value</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the key associated with <var>value</var> in the hash table
<var>hash</var>, or <code>NULL</code> if there is no such value.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_hash_exists</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_hash_exists</deffunction> <defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>svz_hash_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>hash</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>key</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return non-zero if <code>key</code> is stored within
the hash table <code>hash</code>, otherwise zero.
This function is useful when you cannot tell whether the return
value of <code>svz_hash_get</code> (<code>== NULL</code>) indicates a real
value in the hash or a non-existing hash key.
</para></definitionitem></deftypefun>

</subsubsection>
</subsection>
<node name="svz_005faddress_005ft" spaces=" "><nodename>svz_address_t</nodename><nodenext automatic="on">Utility functions</nodenext><nodeprev automatic="on">Data structures</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>svz_address_t</sectiontitle>

<para>A network address comprises a <dfn>family</dfn>, such as <code>AF_INET</code>
(also known as IPv4), and its <dfn>bits</dfn> in network byte order, such as
the bytes 127, 0, 0 and 1 (also known as the <dfn>IPv4 loopback
address</dfn>).  Many libserveez functions take <code>svz_address_t *</code>.
</para>
<para><strong>Please note</strong>: Although <code>svz_address_t</code>
supports<footnote><para>that is, if your system supports it</para></footnote> IPv6, the rest
of libserveez it does not (yet).  This means you can freely create and
manipulate address objects with the functions described in this
section, but any attempt to pass to the rest of libserveez an address
with a <var>family</var> other than <code>AF_INET</code> will immediately abort
the process.  When full IPv6 support is in place, this blurb will be
deleted and the list returned by <code>svz_library_features</code> will
include an appropriate indicator (<pxref><xrefnodename>Library features</xrefnodename></pxref>).
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_address_make</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_address_t *</deftype> <deffunction>svz_address_make</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>family</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>bits</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return an address object to hold an address in <var>family</var>,
represented by <var>bits</var>.  <var>family</var> must be one of:
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">AF_INET</itemformat></item>
</tableterm><tableitem><para>An IPv4 address; <var>bits</var> is <code>in_addr_t *</code>.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">AF_INET6</itemformat></item>
</tableterm><tableitem><para>(if supported by your system) An IPv6 address;
<var>bits</var> is <code>struct in6_addr *</code>.
</para></tableitem></tableentry></table>

<para>The <var>bits</var> are expected in network byte order.
If there are problems, return <code>NULL</code>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_address_family</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_address_family</deffunction> <defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>svz_address_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>addr</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the address family of <var>addr</var>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_address_to</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_address_to</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>dest</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>svz_address_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>addr</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Copy the address bits out of <var>addr</var> to <var>dest</var>.
Return 0 on success, -1 if either <var>addr</var> or <var>dest</var>
is <code>NULL</code>, or the <var>addr</var> family is <code>AF_UNSPEC</code>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_address_same</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_address_same</deffunction> <defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>svz_address_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>a</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>svz_address_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>b</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return 1 if <var>a</var> and <var>b</var> represent the same address
(identical family and bits), otherwise 0.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_pp_address</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">const char *</deftype> <deffunction>svz_pp_address</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>buf</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>size</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>svz_address_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>addr</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Format an external representation of <var>addr</var> into <var>buf</var>,
of <var>size</var> bytes.  The format depends on the family of
<var>addr</var>.  For IPv4, this is numbers-and-dots.  For IPv6, it
is &textldquo;the most appropriate IPv6 network address format for
<var>addr</var>&textrdquo;, according to the manpage of <code>inet_ntop</code>, the
function that actually does the work.
</para>
<para>If <var>buf</var> or <var>addr</var> is <code>NULL</code>, or <var>size</var> is not
big enough, return <code>NULL</code>.  Otherwise, return <var>buf</var>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_pp_addr_port</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">const char *</deftype> <deffunction>svz_pp_addr_port</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>buf</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>size</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>svz_address_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>addr</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>in_port_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>port</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Format an external representation of <var>addr</var> and <var>port</var>
(in network byte order) into <var>buf</var>, of <var>size</var> bytes.
The address <dfn>xrep</dfn> (external representation) is done by
<code>svz_pp_address</code>, q.v.  The rest of the formatting depends
on the <var>addr</var> family.
</para>
<multitable spaces=" " endspaces=" "><columnfractions line=" 0.4 0.6"><columnfraction value="0.4"></columnfraction><columnfraction value="0.6"></columnfraction></columnfractions>
<thead><row><entry command="headitem" spaces=" "><para>Family
</para></entry><entry command="tab" spaces=" "><para>Formatting
</para></entry></row></thead><tbody><row><entry command="item" spaces=" "><para><code>AF_INET</code> (IPv4)
</para></entry><entry command="tab" spaces=" "><para><code><var>xrep</var>:<var>port</var></code>
</para></entry></row><row><entry command="item" spaces=" "><para><code>AF_INET6</code> (IPv6)
</para></entry><entry command="tab" spaces=" "><para><code>[<var>xrep</var>]:<var>port</var></code>
</para></entry></row></tbody></multitable>

<para>If <var>buf</var> or <var>addr</var> is <code>NULL</code>, or <var>size</var> is not
big enough, return <code>NULL</code>.  Otherwise, return <var>buf</var>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_address_copy</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_address_t *</deftype> <deffunction>svz_address_copy</deffunction> <defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>svz_address_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>addr</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return a copy of <var>addr</var>.
</para></definitionitem></deftypefun>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_SET_ADDR</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_SET_ADDR</deffunction> <defdelimiter>(</defdelimiter><defparam>place</defparam><defdelimiter>,</defdelimiter> <defparam>family</defparam><defdelimiter>,</defdelimiter> <defparam>bits</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Expand to a series of commands.  First, if <var>place</var> is
non-<code>NULL</code>, then <code>svz_free</code> it.  Next, assign to
<var>place</var> a new address object made by calling
<code>svz_address_make</code> with <var>family</var> and <var>bits</var>.
</para></definitionitem></defmac>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_PP_ADDR</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_PP_ADDR</deffunction> <defdelimiter>(</defdelimiter><defparam>buf</defparam><defdelimiter>,</defdelimiter> <defparam>addr</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Expand to a call to <code>svz_pp_address</code>, passing it
<var>buf</var> and <code>sizeof <var>buf</var></code>, in addition to <var>addr</var>.
</para></definitionitem></defmac>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_PP_ADDR_PORT</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_PP_ADDR_PORT</deffunction> <defdelimiter>(</defdelimiter><defparam>buf</defparam><defdelimiter>,</defdelimiter> <defparam>addr</defparam><defdelimiter>,</defdelimiter> <defparam>port</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Expand to a call to <code>svz_pp_addr_port</code>, passing it
<var>buf</var> and <code>sizeof <var>buf</var></code>, in addition to
<var>addr</var> and <var>port</var>.
</para></definitionitem></defmac>

</subsection>
<node name="Utility-functions" spaces=" "><nodename>Utility functions</nodename><nodenext automatic="on">Core functions</nodenext><nodeprev automatic="on">svz_address_t</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Utility functions</sectiontitle>

<para>Within this section you will find some miscellaneous functionality and
left overs of the C API.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_log</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_log</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>level</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>format</var></defparam><defdelimiter>,</defdelimiter> <defparam>&dots;</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Print a message to the log system.  <var>level</var> specifies the prefix.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_log_setfile</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_log_setfile</deffunction> <defdelimiter>(</defdelimiter><defparamtype>FILE</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>file</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Set the file stream <var>file</var> to the log file all messages
are printed to.  Can also be <code>stdout</code> or <code>stderr</code>.
</para></definitionitem></deftypefun>

<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_hexdump</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_hexdump</deffunction> <defdelimiter>(</defdelimiter><defparamtype>FILE</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>out</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>action</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>from</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>buffer</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>len</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>max</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Dump <var>buffer</var> with the length <var>len</var> to the file stream <var>out</var>.
Display description <var>action</var> along with origin and size info first,
followed by the hexadecimal text representation.
Stop output at either <var>max</var> or <var>len</var> (if <var>max</var> is zero) bytes.
<var>from</var> is a numerical identifier of the buffers creator.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_itoa</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">char *</deftype> <deffunction>svz_itoa</deffunction> <defdelimiter>(</defdelimiter><defparamtype>unsigned</defparamtype><defparam>&nbsp;</defparam><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>i</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Convert an unsigned integer to its decimal string representation,
returning a pointer to an internal buffer.  (You should copy the result.)
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_atoi</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">unsigned int</deftype> <deffunction>svz_atoi</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>str</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Convert string <var>str</var> in decimal format to an unsigned integer.
Stop conversion on any invalid characters.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_getcwd</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">char *</deftype> <deffunction>svz_getcwd</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the current working directory in a newly allocated string.
(You should <code>svz_free</code> it when done.)
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_openfiles</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_openfiles</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>max_sockets</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Check for the current and maximum limit of open files of the
current process and try to set the limit to <var>max_sockets</var>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_time</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">char *</deftype> <deffunction>svz_time</deffunction> <defdelimiter>(</defdelimiter><defparamtype>long</defparamtype><defparam>&nbsp;</defparam><defparam><var>t</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Transform the given binary data <var>t</var> (UTC time) to an ASCII time text
representation without any trailing characters.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_tolower</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">char *</deftype> <deffunction>svz_tolower</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>str</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Convert the given string <var>str</var> to lower case text representation.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sys_version</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">char *</deftype> <deffunction>svz_sys_version</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return a statically-allocated string describing some operating system
version details.
</para></definitionitem></deftypefun>

<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_socket_unavailable_error_p</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_socket_unavailable_error_p</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return 1 if there was a &quot;socket unavailable&quot; error recently, 0
otherwise.  This checks <code>svz_errno</code> against <code>WSAEWOULDBLOCK</code>
(woe32) or <code>EAGAIN</code> (Unix).
</para></definitionitem></deftypefun>

<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sys_strerror</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">const char *</deftype> <deffunction>svz_sys_strerror</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return a string describing the most recent system error.
</para></definitionitem></deftypefun>

<para>The next two functions log (with <code>SVZ_LOG_ERROR</code>) the current
<dfn>system error</dfn> or <dfn>network error</dfn>, forming the prefix of the
message using <var>fmt</var> and <var>args</var>.  This formatted prefix cannot
exceed 255 bytes.  The rest of the message comprises: colon, space,
error description, newline.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_log_sys_error</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_log_sys_error</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>fmt</var></defparam><defdelimiter>,</defdelimiter> <defparam>&dots;</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Log the current <dfn>system error</dfn>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_log_net_error</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_log_net_error</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>fmt</var></defparam><defdelimiter>,</defdelimiter> <defparam>&dots;</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Log the current <dfn>network error</dfn>.
</para></definitionitem></deftypefun>

<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_mingw_at_least_nt4_p</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_mingw_at_least_nt4_p</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return 1 if running MinGW (Windows) NT4x or later,
otherwise 0.
</para></definitionitem></deftypefun>

</subsection>
<node name="Core-functions" spaces=" "><nodename>Core functions</nodename><nodenext automatic="on">Client connections</nodenext><nodeprev automatic="on">Utility functions</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Networking and other low level functions</sectiontitle>

<para>This chapter deals with the basic networking and file systems functions.
It encapsulates systems calls in a portable manner.  These functions
should behave identically on Windows and Unices.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_inet_ntoa</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">char *</deftype> <deffunction>svz_inet_ntoa</deffunction> <defdelimiter>(</defdelimiter><defparamtype>in_addr_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>ip</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Convert <var>ip</var>, an address in network byte order, to its dotted
decimal representation, returning a pointer to a statically
allocated buffer.  (You should copy the result.)
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_inet_aton</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_inet_aton</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>str</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>struct</defparamtype><defparam>&nbsp;</defparam><defparamtype>sockaddr_in</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>addr</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Convert the Internet host address <var>str</var> from the standard
numbers-and-dots notation into binary data and store it in the
structure that <var>addr</var> points to.
Return zero if the address is valid, nonzero otherwise.
As a special case, if <var>str</var> is <samp>*</samp> (asterisk),
store <code>INADDR_ANY</code> in <var>addr</var>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_closesocket</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_closesocket</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_t_socket</defparamtype><defparam>&nbsp;</defparam><defparam><var>sockfd</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Close the socket <var>sock</var>.
Return 0 if successful, -1 otherwise.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_fd_cloexec</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_fd_cloexec</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>fd</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Set the close-on-exec flag of the given file descriptor <var>fd</var> and
return zero on success.  Otherwise return non-zero.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_tcp_cork</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_tcp_cork</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_t_socket</defparamtype><defparam>&nbsp;</defparam><defparam><var>fd</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>set</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Enable or disable the <code>TCP_CORK</code> socket option of the socket
<var>fd</var>.  This is useful for performance reasons when using
<code>sendfile</code> with any prepending or trailing data not inside the
file to transmit.  Return zero on success, otherwise non-zero.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_tcp_nodelay</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_tcp_nodelay</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_t_socket</defparamtype><defparam>&nbsp;</defparam><defparam><var>fd</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>set</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>old</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Enable or disable the <code>TCP_NODELAY</code> setting for the socket
<var>fd</var> depending on the flag <var>set</var>, effectively enabling
or disabling the Nagle algorithm.
This means that packets are always sent
as soon as possible and no unnecessary delays are introduced.
If <var>old</var> is not <code>NULL</code>, save the old setting there.
Return zero on success, otherwise non-zero.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sendfile</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_sendfile</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>out_fd</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>in_fd</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>off_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>offset</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>count</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Transmit data between one file descriptor and another where
<var>in_fd</var> is the source and <var>out_fd</var> the destination.
The <var>offset</var> argument is a pointer to a variable holding
the input file pointer position from which reading starts.
On return, the <var>offset</var> variable will be set to the offset
of the byte following the last byte that was read.
<var>count</var> is the number of bytes to copy.
Return the number of bytes actually read/written or -1 on errors.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_open</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_open</deffunction> <defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>file</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>flags</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>mode_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>mode</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Open the filename <var>file</var> and convert it into a file handle.  The
given <var>flags</var> specify the access mode and the <var>mode</var> argument
the permissions if the <code>O_CREAT</code> flag is set.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_close</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_close</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>fd</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Close the given file handle <var>fd</var>.  Return -1 on errors.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_fstat</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_fstat</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>fd</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>struct</defparamtype><defparam>&nbsp;</defparam><defparamtype>stat</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>buf</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return information about the specified file associated with the file
descriptor <var>fd</var> returned by <code>svz_open</code>.  Store available
information in the stat buffer <var>buf</var>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_fopen</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">FILE *</deftype> <deffunction>svz_fopen</deffunction> <defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>file</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>mode</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Open the file whose name is the string pointed to by <var>file</var> and
associate a stream with it.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_fclose</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_fclose</deffunction> <defdelimiter>(</defdelimiter><defparamtype>FILE</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>f</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Dissociate the named stream <var>f</var> from its underlying file.
</para></definitionitem></deftypefun>

</subsection>
<node name="Client-connections" spaces=" "><nodename>Client connections</nodename><nodenext automatic="on">Socket management</nodenext><nodeprev automatic="on">Core functions</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Client connections</sectiontitle>

<para>Serveez tries to handle all kinds of Internet protocols like TCP
(connection oriented), UDP, ICMP and RAW (packet oriented) and
communication across named pipes (also connection oriented) in the same
way.  Therefore it uses a structure called <code>svz_socket_t</code> which is
the abstraction of any kind of communication endpoint (can be client or
server or both together).
</para>
<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::                   ">TCP sockets</menunode><menudescription><pre xml:space="preserve">TCP socket functions
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::              ">Pipe connections</menunode><menudescription><pre xml:space="preserve">Named and anonymous pipe functions
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::                   ">UDP sockets</menunode><menudescription><pre xml:space="preserve">UDP socket functions
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::                  ">ICMP sockets</menunode><menudescription><pre xml:space="preserve">ICMP socket functions
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::                   ">Raw sockets</menunode><menudescription><pre xml:space="preserve">Raw socket functions
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::       ">Passthrough connections</menunode><menudescription><pre xml:space="preserve">Passthrough connections to child processes
</pre></menudescription></menuentry></menu>

<node name="TCP-sockets" spaces=" "><nodename>TCP sockets</nodename><nodenext automatic="on">Pipe connections</nodenext><nodeup automatic="on">Client connections</nodeup></node>
<subsubsection spaces=" "><sectiontitle>TCP sockets</sectiontitle>

<para>TCP sockets provide a reliable, stream oriented, full duplex connection
between two sockets on top of the Internet Protocol (IP).  TCP
guarantees that the data arrives in order and retransmits lost packets.
It generates and checks a per packet checksum to catch transmission
errors.  TCP does not preserve record boundaries.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_tcp_connect</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_socket_t *</deftype> <deffunction>svz_tcp_connect</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_address_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>host</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>in_port_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>port</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Create a TCP connection to host <var>host</var> and set the socket descriptor
in structure <var>sock</var> to the resulting socket.  Return <code>NULL</code> on
errors.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_tcp_read_socket</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_tcp_read_socket</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Read all data from <var>sock</var> and call the <code>check_request</code>
function for the socket, if set.  Return -1 if the socket has died,
zero otherwise.
</para>
<para>This is the default function for reading from <var>sock</var>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_tcp_send_oob</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_tcp_send_oob</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>If the underlying operating system supports urgent data (out-of-band) in
TCP streams, try to send the byte in <code>sock-&gt;oob</code> through the socket
structure <var>sock</var> as out-of-band data.  Return zero on success and -1
otherwise (also if urgent data is not supported).
</para></definitionitem></deftypefun>

</subsubsection>
<node name="Pipe-connections" spaces=" "><nodename>Pipe connections</nodename><nodenext automatic="on">UDP sockets</nodenext><nodeprev automatic="on">TCP sockets</nodeprev><nodeup automatic="on">Client connections</nodeup></node>
<subsubsection spaces=" "><sectiontitle>Pipe connections</sectiontitle>

<para>The pipe implementation supports both named and anonymous pipes.  Pipe
servers are implemented as listeners on a file system FIFO on Unices or
&textldquo;Named Pipes&textrdquo; on Windows (can be shared over a Windows network).
</para>
<para>A FIFO special file is similar to a pipe, except that it is created in a
different way.  Instead of being an anonymous communications channel, a
FIFO special file is entered into the file system.
</para>
<para>Once you have created a FIFO special file in this way, any process can
open it for reading or writing, in the same way as an ordinary file.
However, it has to be open at both ends simultaneously before you can
proceed to do any input or output operations on it.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_pipe_create</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_socket_t *</deftype> <deffunction>svz_pipe_create</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_t_handle</defparamtype><defparam>&nbsp;</defparam><defparam><var>recv_fd</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_t_handle</defparamtype><defparam>&nbsp;</defparam><defparam><var>send_fd</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Create a socket structure containing both the pipe descriptors
<var>recv_fd</var> and <var>send_fd</var>.  Return <code>NULL</code> on errors.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_pipe_create_pair</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_pipe_create_pair</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_t_handle</defparamtype><defparam>&nbsp;</defparam><defparam><var>pipe_desc</var></defparam><defdelimiter>[</defdelimiter><defparamtype>2</defparamtype><defdelimiter>]</defdelimiter><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Create a (non blocking) pair of pipes.  This differs in Win32 and
Unices.  Return a non-zero value on errors.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_pipe_connect</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_socket_t *</deftype> <deffunction>svz_pipe_connect</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_pipe_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>recv</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_pipe_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>send</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Create a pipe connection socket structure to the pair of named
pipes <var>recv</var> and <var>send</var>.  Return <code>NULL</code> on errors.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_invalid_handle_p</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_invalid_handle_p</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_t_handle</defparamtype><defparam>&nbsp;</defparam><defparam><var>handle</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return 1 if <var>handle</var> is invalid, otherwise 0.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_invalidate_handle</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_invalidate_handle</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_t_handle</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>href</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Invalidate the handle pointed at by <var>href</var>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_closehandle</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_closehandle</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_t_handle</defparamtype><defparam>&nbsp;</defparam><defparam><var>handle</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Close <var>handle</var>.
Return 0 if successful, -1 otherwise.
</para></definitionitem></deftypefun>

</subsubsection>
<node name="UDP-sockets" spaces=" "><nodename>UDP sockets</nodename><nodenext automatic="on">ICMP sockets</nodenext><nodeprev automatic="on">Pipe connections</nodeprev><nodeup automatic="on">Client connections</nodeup></node>
<subsubsection spaces=" "><sectiontitle>UDP sockets</sectiontitle>

<para>The UDP sockets implement a connectionless, unreliable datagram packet
service.  Packets may be reordered or duplicated before they arrive.
UDP generates and checks checksums to catch transmission errors.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_udp_connect</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_socket_t *</deftype> <deffunction>svz_udp_connect</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_address_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>host</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>in_port_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>port</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Create a UDP connection to <var>host</var> at <var>port</var> and set the socket
descriptor in structure <var>sock</var> to the resulting socket.  Return a
<code>NULL</code> value on errors.
</para>
<para>This function can be used for port bouncing.  If you assign the
<code>handle_request</code> callback to something server specific and the
<var>cfg</var> field of the server&textrsquo;s configuration to the returned socket
structure, this socket is able to handle a dedicated UDP connection to
some other UDP server.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_udp_write</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_udp_write</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>buf</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>length</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Write <var>buf</var> into the send queue of the UDP socket <var>sock</var>.  If
<var>length</var> argument supersedes the maximum length for UDP messages it
is split into smaller packets.
</para></definitionitem></deftypefun>

</subsubsection>
<node name="ICMP-sockets" spaces=" "><nodename>ICMP sockets</nodename><nodenext automatic="on">Raw sockets</nodenext><nodeprev automatic="on">UDP sockets</nodeprev><nodeup automatic="on">Client connections</nodeup></node>
<subsubsection spaces=" "><sectiontitle>ICMP sockets</sectiontitle>

<para>The ICMP socket implementation is currently used in the tunnel server
which comes with the Serveez package.  It implements a user protocol
receiving and sending ICMP packets by opening a raw socket with the
protocol <code>IPPROTO_ICMP</code>.
</para>
<para>The types of ICMP packets passed to the socket can be filtered using the
<code>ICMP_FILTER</code> socket option (or by software as done here).  ICMP
packets are always processed by the kernel too, even when passed to a
user socket.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_icmp_connect</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_socket_t *</deftype> <deffunction>svz_icmp_connect</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_address_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>host</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>in_port_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>port</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>uint8_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>type</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Create an ICMP socket for receiving and sending.
Return <code>NULL</code> on errors, otherwise an enqueued socket structure.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_icmp_send_control</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_icmp_send_control</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>uint8_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>type</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>&textldquo;If you are calling this function we will send an empty ICMP packet
signaling that this connection is going down soon.&textrdquo;
[ttn sez: huh?]
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_icmp_write</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_icmp_write</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>buf</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>length</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Send <var>buf</var> with length <var>length</var> via this ICMP socket <var>sock</var>.
If <var>length</var> supersedes the maximum ICMP message size the buffer is
split into smaller packets.
</para></definitionitem></deftypefun>

</subsubsection>
<node name="Raw-sockets" spaces=" "><nodename>Raw sockets</nodename><nodenext automatic="on">Passthrough connections</nodenext><nodeprev automatic="on">ICMP sockets</nodeprev><nodeup automatic="on">Client connections</nodeup></node>
<subsubsection spaces=" "><sectiontitle>Raw sockets</sectiontitle>

<para>A raw socket receives or sends the raw datagram not including link-level
headers.  It is currently used by the ICMP socket implementation of the
core library.  The IPv4 layer generates an IP header when sending a
packet unless the <code>IP_HDRINCL</code> socket option is enabled on the
socket.  When it is enabled, the packet must contain an IP header.  For
receiving the IP header is always included in the packet.
</para>
<para>Only processes with an effective userid of zero (Administrator or root)
or the <code>CAP_NET_RAW</code> capability are allowed to open raw sockets.
All packets or errors matching the protocol number specified for the raw
socket are passed to this socket.  A protocol of <code>IPPROTO_RAW</code>
implies enabled <code>IP_HDRINCL</code> and receives all IP protocols.
Sending is not allowed.
</para>
<para>[FIXME: All funcs internalized!  Write something else here!]
</para>
</subsubsection>
<node name="Passthrough-connections" spaces=" "><nodename>Passthrough connections</nodename><nodeprev automatic="on">Raw sockets</nodeprev><nodeup automatic="on">Client connections</nodeup></node>
<subsubsection spaces=" "><sectiontitle>Passthrough connections</sectiontitle>

<para>The functions described in this section allow you to pass through client
connections to the standard input (stdin) and standard output (stdout)
of external programs.  Some of the routines deal with the management of
program environments.  Basically, there are two methods for passing
through a duplex connection: the Unix&textrsquo;ish <code>fork</code> and <code>exec</code>
method and the shuffle method where the main process keeps control over
the communication on the original duplex connection and passes this data
through two pairs of pipes, or yet another socket connection, to the
child process.  All of the three method are implemented calling them
<code>SVZ_PROCESS_FORK</code>, <code>SVZ_PROCESS_SHUFFLE_PIPE</code> and
<code>SVZ_PROCESS_SHUFFLE_SOCK</code>.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_process</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_sock_process</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>bin</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>dir</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>**</defparamtype><defparam><var>argv</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_envblock_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>envp</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>forkp</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>user</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Start a new program <var>bin</var>, a fully qualified executable filename,
passing the socket or pipe descriptor(s) in the socket structure
<var>sock</var> to its stdin and stdout.
</para>
<para>If <var>dir</var> is non-<code>NULL</code>, it specifies the working directory of
the new process.
</para>
<para>The program arguments and the environment of the new process are taken
from <var>argv</var> and <var>envp</var>.  Normally <code>argv[0]</code> should be set to
the program&textrsquo;s name.  If <code>NULL</code>, it defaults to <var>bin</var>.
</para>
<para>The <var>forkp</var> argument is a flag that controls the passthrough method.
If non-zero, pipe descriptors or the socket descriptor are passed to the
child process directly through <code>fork</code> and <code>exec</code>.  Otherwise,
socket transactions are passed via a pair or pipes or sockets (depending
on whether or not the system provides <code>socketpair</code>).
</para>
<para>You can pass the user and group identifications in the format
<samp>user[.group]</samp> (group is optional), as <code>SVZ_PROCESS_NONE</code> or
<code>SVZ_PROCESS_OWNER</code> in the <var>user</var> argument.  This specifies the
permissions of the new child process.  If <code>SVZ_PROCESS_OWNER</code> is
passed the permissions are set to the executable file <var>bin</var> owner;
<code>SVZ_PROCESS_NONE</code> does not change user or group.
</para>
<para>Return the new process id on success, -1 on failure.
</para></definitionitem></deftypefun>

<para><strong>Please note</strong>: On M$-Windows platforms it is not possible to pass
a socket connection to stdin/stdout of a child process.  That is why
this function creates an inheritable version of the socket and puts the
socket handle number into the environment variables <code>SEND_HANDLE</code>
and <code>RECV_HANDLE</code>.  A spawned child process can use these handles
as if they were self-created.  After calling <code>WSAStartup</code> the child
process can <code>send</code> and <code>recv</code> as usual.
</para>
<para>Relatedly, Windoze does not use <code>SIGCHLD</code> to inform the parent when
a child dies, so for that platform, you should use the next function
(which is not otherwise available):
</para><deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_mingw_child_dead_p</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_mingw_child_dead_p</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>prefix</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_t_handle</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>pid</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Check child pointed at by <var>pid</var> by waiting a bit.
If it is dead, close and invalidate its handle, and return 1.
Otherwise, return 0.
<var>prefix</var> is for error messages; it should be either the
empty string, or a string ending in colon and space.
</para></definitionitem></deftypefun>

<para>On non-Windoze, this is the function you want to use:
</para><deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_most_recent_dead_child_p</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_most_recent_dead_child_p</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_t_handle</defparamtype><defparam>&nbsp;</defparam><defparam><var>pid</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return 1 if a child process <var>pid</var> died recently, updating
other internal state by side effect.  Otherwise, return 0.
</para></definitionitem></deftypefun>

<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_envblock_setup</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_envblock_setup</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Set up internal tables for environment block wrangling.
</para>
<para>This function must be called once after <code>svz_boot</code>
so that subsequent functions
(like <code>svz_envblock_default</code>) can work correctly.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_envblock_create</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_envblock_t *</deftype> <deffunction>svz_envblock_create</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Create and return a fresh environment block, useful for passing
to <code>svz_envblock_default</code> and <code>svz_envblock_add</code>.  Its
size is initially set to zero.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_envblock_default</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_envblock_default</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_envblock_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>env</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Fill environment block <var>env</var> with the environment variables from
the current process, replacing its current contents (if any).
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_envblock_add</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_envblock_add</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_envblock_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>env</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>format</var></defparam><defdelimiter>,</defdelimiter> <defparam>&dots;</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Insert a new environment variable into environment block
<var>env</var>.  The <var>format</var> argument is a <code>printf</code>-style format
string describing how to format the optional arguments.  You specify
environment variables in the <samp>VAR=VALUE</samp> format.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_envblock_destroy</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_envblock_destroy</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_envblock_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>env</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Destroy environment block <var>env</var> completely.  Afterwards,
<var>env</var> is invalid and should therefore not be further referenced.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_envblock_get</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void *</deftype> <deffunction>svz_envblock_get</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_envblock_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>env</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Convert environment block <var>env</var> into something which can be passed to
<code>execve</code> (Unix) or <code>CreateProcess</code> (Windows).  Additionally,
under Windows, sort the environment block.
</para>
<para>(Unfortunately the layout of environment blocks in Unices and Windows
differ.  On Unices you have a NULL terminated array of character strings
(i.e., <code>char **</code>) and on Windows systems you have a simple character
string containing the environment variables in the format <samp>VAR=VALUE</samp>
each separated by a zero byte (i.e., <code>char *</code>).  The end of the list
is indicated by a further zero byte.)
</para></definitionitem></deftypefun>

</subsubsection>
</subsection>
<node name="Socket-management" spaces=" "><nodename>Socket management</nodename><nodenext automatic="on">Coserver functions</nodenext><nodeprev automatic="on">Client connections</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Socket management</sectiontitle>

<para>The functions described in this section deal with the creation,
destruction and other simple operations on socket structures called
<code>svz_socket_t</code>.  See the description of each function for details
on which kind of socket it can handle and what they are for.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_nconnections</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_sock_nconnections</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the number of currently connected sockets.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_write</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_sock_write</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>buf</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>len</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Write <var>len</var> bytes from the memory location pointed to by <var>buf</var>
to the output buffer of the socket <var>sock</var>.  Also try to flush the
buffer to the socket of <var>sock</var> if possible.  Return a non-zero value
on error, which normally means a buffer overflow.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_printf</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_sock_printf</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>fmt</var></defparam><defdelimiter>,</defdelimiter> <defparam>&dots;</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Print a formatted string on the socket <var>sock</var>.  <var>fmt</var> is the
<code>printf</code>-style format string, which describes how to format the
optional arguments.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_resize_buffers</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_sock_resize_buffers</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>send_buf_size</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>recv_buf_size</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Resize the send and receive buffers for the socket <var>sock</var>.
<var>send_buf_size</var> is the new size for the send buffer,
<var>recv_buf_size</var> for the receive buffer.  Note that data may be lost
when the buffers shrink.  For a new buffer size of 0 the buffer is
freed and the pointer set to NULL.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_check_request</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_sock_check_request</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Check for the kind of packet delimiter within <var>sock</var> and
and assign one of the default <code>check_request</code> routines
(one or more byte delimiters or a fixed size).
</para>
<para>Afterwards this function will never ever be called again because
the callback gets overwritten here.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_reduce_recv</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_sock_reduce_recv</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>len</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Shorten the receive buffer of <var>sock</var> by <var>len</var> bytes.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_reduce_send</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_sock_reduce_send</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>len</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Reduce the send buffer of <var>sock</var> by <var>len</var> bytes.
</para></definitionitem></deftypefun>

</subsection>
<node name="Coserver-functions" spaces=" "><nodename>Coserver functions</nodename><nodenext automatic="on">Codec functions</nodenext><nodeprev automatic="on">Socket management</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Coserver functions</sectiontitle>

<para>This section describes the internal coserver interface of Serveez.
Coservers are helper processes meant to perform blocking tasks.  This is
necessary because Serveez itself is single threaded.  Each coserver is
connected via a pair of pipes to the main thread of Serveez
communicating over a simple text line protocol.  Each request/response
is separated by a newline character.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_foreach_coserver</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_foreach_coserver</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_coserver_do_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>func</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>closure</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Call <var>func</var> for each coserver, passing additionally the second arg
<var>closure</var>.  If <var>func</var> returns a negative value, return immediately
with that value (breaking out of the loop), otherwise, return 0.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_coserver_check</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_coserver_check</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Under woe32 check if there was any response from an active coserver.
Moreover keep the coserver threads/processes alive.  If one of the
coservers dies due to buffer overrun or might be overloaded,
start a new one.
</para>
<para>Call this function whenever there is time, e.g., within the timeout of the
<code>select</code> system call.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_coserver_destroy</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_coserver_destroy</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>type</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Destroy specific coservers with the type <var>type</var>.
All instances of this coserver type will be stopped.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_coserver_create</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_coserver_t *</deftype> <deffunction>svz_coserver_create</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>type</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Create and return a single coserver with the given type <var>type</var>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_coserver_type_name</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">const char *</deftype> <deffunction>svz_coserver_type_name</deffunction> <defdelimiter>(</defdelimiter><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>svz_coserver_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>coserver</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the type name of <var>coserver</var>.
</para></definitionitem></deftypefun>

<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_coserver_rdns_invoke</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_coserver_rdns_invoke</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_address_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>addr</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_coserver_handle_result_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>cb</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>closure</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Enqueue a request for the reverse DNS coserver
to resolve address <var>addr</var>,
arranging for callback <var>cb</var> to be called with two args:
the hostname (a string) and the opaque data <var>closure</var>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_coserver_dns_invoke</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_coserver_dns_invoke</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>host</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_coserver_handle_result_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>cb</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>closure</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Enqueue a request for the DNS coserver to resolve <var>host</var>,
arranging for callback <var>cb</var> to be called with two args:
the ip address in dots-and-numbers notation and the opaque
data <var>closure</var>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_coserver_ident_invoke</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_coserver_ident_invoke</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_coserver_handle_result_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>cb</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>closure</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Enqueue a request for the ident coserver to resolve the client
identity at <var>sock</var>, arranging for callback <var>cb</var> to be called
with two args: the identity (string) and the opaque data <var>closure</var>.
</para></definitionitem></deftypefun>

<para>To make use of coservers, you need to start the coserver interface by
calling <code>svz_updn_all_coservers</code> once before, and once after,
entering the main server loop.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_updn_all_coservers</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_updn_all_coservers</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>direction</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>If <var>direction</var> is non-zero, init coserver internals.
Otherwise, finalize them.  Return 0 if successful.
</para>
<para>If <var>direction</var> is positive, init also starts one instance each
of the builtin servers.  If negative, it doesn&textrsquo;t.
</para></definitionitem></deftypefun>

</subsection>
<node name="Codec-functions" spaces=" "><nodename>Codec functions</nodename><nodenext automatic="on">Server types</nodenext><nodeprev automatic="on">Coserver functions</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Codec functions</sectiontitle>

<para>The codec interface of the Serveez core API supplies routines for
setting up socket structures to perform encoding or decoding of its
receive or send buffers.  It is a transparent layer of buffer
transition.  The interface itself tries to unify different types of
codecs.  In order to add a new codec the programmer needs to write some
wrapper functions around the actual implementation to fulfill certain
entry and exit semantics of this interface.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_foreach_codec</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_foreach_codec</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_codec_do_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>func</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>closure</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Call <var>func</var> for each codec, passing additionally the second arg
<var>closure</var>.  If <var>func</var> returns a negative value, return immediately
with that value (breaking out of the loop), otherwise, return 0.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_codec_get</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_codec_t *</deftype> <deffunction>svz_codec_get</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>description</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>type</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Find an appropriate codec for the given <var>description</var> and <var>type</var>
(one of either <code>SVZ_CODEC_ENCODER</code> or <code>SVZ_CODEC_DECODER</code>).
Return <code>NULL</code> if there is no such codec registered.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_codec_ratio</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_codec_ratio</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_codec_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>codec</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_codec_data_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>data</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Print a text representation of a codec&textrsquo;s current ratio in percent
if possible.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_codec_register</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_codec_register</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_codec_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>codec</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Register <var>codec</var>.  Does not register invalid or
duplicate codecs.  Return zero on success, non-zero otherwise.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_codec_unregister</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_codec_unregister</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_codec_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>codec</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Remove <var>codec</var> from the list of known codecs.  Return
zero if the codec could be successfully removed, non-zero otherwise.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_codec_sock_receive_setup</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_codec_sock_receive_setup</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_codec_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>codec</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Arrange for <var>sock</var> to decode or encode its receive data via
<var>codec</var>.  Return zero on success, non-zero otherwise.
</para>
<para>(You need to have set the <code>check_request</code> method previously
for this to work.)
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_codec_sock_receive</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_codec_sock_receive</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>&textldquo;This routine is the new <code>check_request</code> callback for reading
codecs.  It is applied in <code>svz_codec_sock_receive_setup</code>.
Usually it gets called whenever there is data in the receive buffer.
It lets the current receive buffer be the input of the codec.  The
output buffer of the codec gets the new receive buffer of <var>sock</var>.
The old <code>check_request</code> callback of <var>sock</var> gets called
afterwards.  When leaving this function, the receive buffer gets
restored again with the bytes snipped consumed by the codec itself.&textrdquo;
[ttn sez: huh?]
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_codec_sock_send_setup</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_codec_sock_send_setup</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_codec_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>codec</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Arrange for <var>sock</var> to encode or decode its send
buffer via <var>codec</var>.  Return zero on success, non-zero otherwise.
</para>
<para>(You need to have properly set the <code>write_socket</code> member of
<var>sock</var> previously for this to work.)
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_codec_sock_send</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_codec_sock_send</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>&textldquo;This is the new <code>write_socket</code> callback for <var>sock</var> which is
called whenever there is data within the send buffer available and
<var>sock</var> is scheduled for writing.  It uses the current send buffer
as input buffer for the codec.  The output buffer of the codec is
used to invoke the <code>write_socket</code> callback saved within
<code>svz_codec_sock_send_setup</code>.  After this the send buffer is
restored again without the bytes consumed by the codec.&textrdquo;
[ttn sez: huh?]
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_codec_sock_disconnect</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_codec_sock_disconnect</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Try to release the resources of both
the receiving and sending codec of <var>sock</var>.
</para>
<para>This callback is used as the <code>disconnected_socket</code> callback of
the socket structure <var>sock</var>.  It is called by default if the
codec socket structure <var>sock</var> gets disconnected for some external
reason.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_codec_sock_detect</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_codec_t *</deftype> <deffunction>svz_codec_sock_detect</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return a valid codec detected by scanning the receive buffer
of <var>sock</var>, or <code>NULL</code> if no codec could be detected.
</para></definitionitem></deftypefun>

</subsection>
<node name="Server-types" spaces=" "><nodename>Server types</nodename><nodenext automatic="on">Server functions</nodenext><nodeprev automatic="on">Codec functions</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Server types</sectiontitle>

<para>As already noted in the main Serveez manual a server type is the main
specification of the abilities and configuration items of a server which
can be instantiated.  It is represented by <code>svz_servertype_t</code> in
Serveez.  It contains server specific members like its name, different
callbacks, a single default configuration and a list of configuration
items which determine what can be configured.
</para>
<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::">Macros for setting up a new server type</menunode><menudescription><pre xml:space="preserve">
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::">General server type functionality</menunode><menudescription><pre xml:space="preserve">
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::">Dynamic server loading</menunode><menudescription><pre xml:space="preserve">
</pre></menudescription></menuentry></menu>

<node name="Macros-for-setting-up-a-new-server-type" spaces=" "><nodename>Macros for setting up a new server type</nodename><nodenext automatic="on">General server type functionality</nodenext><nodeup automatic="on">Server types</nodeup></node>
<subsubsection spaces=" "><sectiontitle>Macros for setting up a new server type</sectiontitle>

<para>When specifying a server type you also need to define configuration
items for it.  These items refer to addresses in the example
configuration of the server type.  These macros can be used to define
such items.
</para>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_REGISTER_INT</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_REGISTER_INT</deffunction> <defdelimiter>(</defdelimiter><defparam>name</defparam><defdelimiter>,</defdelimiter> <defparam>item</defparam><defdelimiter>,</defdelimiter> <defparam>defaultable</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Register a simple integer.  C-type: <code>int</code>.  The given <var>name</var>
specifies the symbolic name of the integer and <var>item</var> the integer
itself (not its address).  The <var>defaultable</var> argument can be either
<code>SVZ_ITEM_DEFAULTABLE</code> or <code>SVZ_ITEM_NOTDEFAULTABLE</code>.
</para></definitionitem></defmac>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_REGISTER_BOOL</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_REGISTER_BOOL</deffunction> <defdelimiter>(</defdelimiter><defparam>name</defparam><defdelimiter>,</defdelimiter> <defparam>item</defparam><defdelimiter>,</defdelimiter> <defparam>defaultable</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Register a boolean value.  C-type: <code>int</code>.
</para></definitionitem></defmac>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_REGISTER_INTARRAY</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_REGISTER_INTARRAY</deffunction> <defdelimiter>(</defdelimiter><defparam>name</defparam><defdelimiter>,</defdelimiter> <defparam>item</defparam><defdelimiter>,</defdelimiter> <defparam>defaultable</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Register an array of integers.  C-type: <code>svz_array_t *</code>.
</para></definitionitem></defmac>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_REGISTER_STR</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_REGISTER_STR</deffunction> <defdelimiter>(</defdelimiter><defparam>name</defparam><defdelimiter>,</defdelimiter> <defparam>item</defparam><defdelimiter>,</defdelimiter> <defparam>defaultable</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Register a simple character string.  C-type: <code>char *</code>.
</para></definitionitem></defmac>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_REGISTER_STRARRAY</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_REGISTER_STRARRAY</deffunction> <defdelimiter>(</defdelimiter><defparam>name</defparam><defdelimiter>,</defdelimiter> <defparam>item</defparam><defdelimiter>,</defdelimiter> <defparam>defaultable</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Register a string array.  C-type: <code>svz_array_t *</code>.
</para></definitionitem></defmac>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_REGISTER_HASH</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_REGISTER_HASH</deffunction> <defdelimiter>(</defdelimiter><defparam>name</defparam><defdelimiter>,</defdelimiter> <defparam>item</defparam><defdelimiter>,</defdelimiter> <defparam>defaultable</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Register a hash table associating strings with strings only.  C-type:
<code>svz_hash_t *</code>.
</para></definitionitem></defmac>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_REGISTER_PORTCFG</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_REGISTER_PORTCFG</deffunction> <defdelimiter>(</defdelimiter><defparam>name</defparam><defdelimiter>,</defdelimiter> <defparam>item</defparam><defdelimiter>,</defdelimiter> <defparam>defaultable</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Register a port configuration.  C-type: <code>svz_portcfg_t *</code>.
</para></definitionitem></defmac>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_REGISTER_END</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_REGISTER_END</deffunction> <defdelimiter>(</defdelimiter><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Indicate the end of the list of configuration items.  It is
the only mandatory item you need to specify in an example server type
configuration.
</para></definitionitem></defmac>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_CONFIG_DEFINE</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_CONFIG_DEFINE</deffunction> <defdelimiter>(</defdelimiter><defparam>description</defparam><defdelimiter>,</defdelimiter> <defparam>config</defparam><defdelimiter>,</defdelimiter> <defparam>prototypes</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Expand to a data structure that properly associates the example
configuration <var>config</var> with the name <var>description</var> and its
configuration items <var>prototypes</var>, for use within a server type
definition.
</para></definitionitem></defmac>

</subsubsection>
<node name="General-server-type-functionality" spaces=" "><nodename>General server type functionality</nodename><nodenext automatic="on">Dynamic server loading</nodenext><nodeprev automatic="on">Macros for setting up a new server type</nodeprev><nodeup automatic="on">Server types</nodeup></node>
<subsubsection spaces=" "><sectiontitle>General server type functionality</sectiontitle>

<para>The following set of functions are used to manage the list of known
server types in the Serveez core library.  Serveez itself uses some of
these functions to register its builtin server types.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_foreach_servertype</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_foreach_servertype</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_servertype_do_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>func</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>closure</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Call <var>func</var> for each servertype, passing additionally the second arg
<var>closure</var>.  If <var>func</var> returns a negative value, return immediately
with that value (breaking out of the loop), otherwise, return 0.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_servertype_add</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_servertype_add</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_servertype_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>server</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Add the server type <var>server</var> to the currently registered servers.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_servertype_get</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_servertype_t *</deftype> <deffunction>svz_servertype_get</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>name</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>dynamic</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Find a servertype definition by its short name.  If <var>dynamic</var> is
set to non-zero, try to load a shared library that provides that
servertype.  Return <code>NULL</code> if no server with the given variable
prefix <var>name</var> has been found.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_servertype_find</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_servertype_t *</deftype> <deffunction>svz_servertype_find</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_server_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>server</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Find a given server instances <var>server</var> server type.  Return
<code>NULL</code> if there is no such server type (which should never occur
since a server is a child of a server type).
</para></definitionitem></deftypefun>

</subsubsection>
<node name="Dynamic-server-loading" spaces=" "><nodename>Dynamic server loading</nodename><nodeprev automatic="on">General server type functionality</nodeprev><nodeup automatic="on">Server types</nodeup></node>
<subsubsection spaces=" "><sectiontitle>Dynamic server loading</sectiontitle>

<para>The core API of Serveez is able to register server types dynamically at
runtime.  It uses the dynamic linker capabilities of the underlying
operating system to load shared libraries (or DLLs on Win32).  This has
been successfully tested on Windows and GNU/Linux.  Other systems are
supported but yet untested.  Please tell us if you notice misbehaviour
of any sort.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_dynload_path_set</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_dynload_path_set</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_array_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>paths</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Set the additional search paths for the serveez library.  The given array
of strings gets <code>svz_free</code>d.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_dynload_path_get</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_array_t *</deftype> <deffunction>svz_dynload_path_get</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Create an array of strings containing each an additional search path.
The loadpath is hold in the environment variable <samp>SERVEEZ_LOAD_PATH</samp>
which can be set from outside the library or modified using
<code>svz_dynload_path_set</code>.  The returned array needs to be destroyed
after usage.
</para></definitionitem></deftypefun>

</subsubsection>
</subsection>
<node name="Server-functions" spaces=" "><nodename>Server functions</nodename><nodenext automatic="on">Port config funcs</nodenext><nodeprev automatic="on">Server types</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Server functions</sectiontitle>

<para>A server in Serveez is an instantiated (configured) server type.  It is
merely a copy of a specific server type with a unique server name, and
is represented by <code>svz_server_t</code> in the core library.
</para>
<menu endspaces=" ">
<menuentry leadingtext="* "><menunode separator="::  ">Server functionality</menunode><menudescription><pre xml:space="preserve">General server instance implementations
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::  ">Server configuration</menunode><menudescription><pre xml:space="preserve">Server instance configuration
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::        ">Server binding</menunode><menudescription><pre xml:space="preserve">Server instance bindings
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::           ">Server core</menunode><menudescription><pre xml:space="preserve">Core functionality for servers
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::           ">Server loop</menunode><menudescription><pre xml:space="preserve">Server loop implementation
</pre></menudescription></menuentry><menuentry leadingtext="* "><menunode separator="::         ">Server socket</menunode><menudescription><pre xml:space="preserve">Using and creating server sockets
</pre></menudescription></menuentry></menu>

<node name="Server-functionality" spaces=" "><nodename>Server functionality</nodename><nodenext automatic="on">Server configuration</nodenext><nodeup automatic="on">Server functions</nodeup></node>
<subsubsection spaces=" "><sectiontitle>Server functionality</sectiontitle>

<para>This section contains functions dealing with the list of known servers
in the core library of Serveez, also with the basics like creation and
destruction of such servers.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_foreach_server</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_foreach_server</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_server_do_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>func</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>closure</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Call <var>func</var> for each server, passing additionally the second arg
<var>closure</var>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_server_find</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_server_t *</deftype> <deffunction>svz_server_find</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>cfg</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Find a server instance by the given configuration structure <var>cfg</var>.
Return <code>NULL</code> if there is no such configuration in any server
instance.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_server_clients</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_array_t *</deftype> <deffunction>svz_server_clients</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_server_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>server</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return a list of clients (socket structures) which are associated
with the given server instance <var>server</var>.  If there is no such
socket, return <code>NULL</code>.  Caller should <code>svz_array_destroy</code>
the returned array.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_server_get</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_server_t *</deftype> <deffunction>svz_server_get</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>name</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Get the server instance with the given instance name <var>name</var>.
Return <code>NULL</code> if there is no such server yet.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_updn_all_servers</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_updn_all_servers</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>direction</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>If <var>direction</var> is non-zero, run the initializers of all
servers, returning -1 if some server did not think it is a good
idea to run.  Otherwise, run the local finalizers for all
server instances.
</para></definitionitem></deftypefun>

</subsubsection>
<node name="Server-configuration" spaces=" "><nodename>Server configuration</nodename><nodenext automatic="on">Server binding</nodenext><nodeprev automatic="on">Server functionality</nodeprev><nodeup automatic="on">Server functions</nodeup></node>
<subsubsection spaces=" "><sectiontitle>Configuration</sectiontitle>

<para>These functions provide an interface for configuring a server.  They are
used to create and modify the default configuration of a server type in
order to create a server configuration.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_config_type_instantiate</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_config_type_instantiate</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>type</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>name</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>instance</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>options</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_config_accessor_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>accessor</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>ebufsz</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>ebuf</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Instantiate a configurable type.  The <var>type</var> argument specifies
the configurable type name, <var>name</var> the name of the type (in the
domain of the configurable type) and <var>instance</var> the instance
name of the type.  Return zero on success, otherwise -1.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_config_free</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_config_free</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_config_prototype_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>prototype</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>cfg</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Release the configuration <var>cfg</var> of the given configuration
prototype <var>prototype</var>.  If <var>cfg</var> is <code>NULL</code>, do nothing.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_collect</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void *</deftype> <deffunction>svz_collect</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>type</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>count</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>data</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Create a collection of <var>type</var>, given the <var>count</var>
items of <var>data</var>.  Valid values of <var>type</var> are one of:
<code>SVZ_INTARRAY</code>, <code>SVZ_STRARRAY</code>, <code>SVZ_STRHASH</code>.
For a string hash, <var>data</var> should be alternating keys and values;
the returned hash table will have <code><var>count</var> / 2</code> elements.
The C type of <var>data</var> for an int array should be <code>int[]</code>,
and for string array or hash it should be <code>char*[]</code>.
On error (either bad <var>type</var> or odd <var>count</var> for string hash),
return <code>NULL</code>.
</para></definitionitem></deftypefun>

<noindent></noindent>
<para>Here are some convenience macros for <code>svz_collect</code>:
</para><defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_COLLECT_INTARRAY</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_COLLECT_INTARRAY</deffunction> <defdelimiter>(</defdelimiter><defparam>cvar</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return an integer array <code>svz_array_t *</code>
created from <code>int <var>cvar</var>[]</code>.
</para></definitionitem></defmac>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_COLLECT_STRARRAY</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_COLLECT_STRARRAY</deffunction> <defdelimiter>(</defdelimiter><defparam>cvar</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return a string array <code>svz_array_t *</code>
created from <code>char *<var>cvar</var>[]</code>.
</para></definitionitem></defmac>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_COLLECT_STRHASH</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_COLLECT_STRHASH</deffunction> <defdelimiter>(</defdelimiter><defparam>cvar</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return a string hash <code>svz_hash_t *</code>
created from <code>char *<var>cvar</var>[]</code>.
</para></definitionitem></defmac>

</subsubsection>
<node name="Server-binding" spaces=" "><nodename>Server binding</nodename><nodenext automatic="on">Server core</nodenext><nodeprev automatic="on">Server configuration</nodeprev><nodeup automatic="on">Server functions</nodeup></node>
<subsubsection spaces=" "><sectiontitle>Bindings</sectiontitle>

<para>The following functionality represents the relationship between port
configurations as described in <ref><xrefnodename>Port config funcs</xrefnodename></ref> and server
instances.  When binding a server to a specific port configuration the
core library creates listeners as needed by itself.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_server_bind</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_server_bind</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_server_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>server</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_portcfg_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>port</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Bind the server instance <var>server</var> to the port configuration
<var>port</var> if possible.  Return non-zero on errors, otherwise zero.
It might occur that a single server is bound to more than one network
port if, e.g., the TCP/IP address is specified by <samp>*</samp> (asterisk)
since this gets expanded to the known list of interfaces.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_server_portcfgs</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_array_t *</deftype> <deffunction>svz_server_portcfgs</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_server_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>server</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return an array of port configurations to which the server instance
<var>server</var> is currently bound to, or <code>NULL</code> if there is no such
binding.  Caller should <code>svz_array_destroy</code> the returned array
when done.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_server_listeners</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_array_t *</deftype> <deffunction>svz_server_listeners</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_server_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>server</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return an array of listening socket structures to which the server
instance <var>server</var> is currently bound to, or <code>NULL</code> if there
is no such binding.  Caller should <code>svz_array_destroy</code> the
returned array when done.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_servers</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_array_t *</deftype> <deffunction>svz_sock_servers</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the array of server instances bound to the listening
<var>sock</var>, or <code>NULL</code> if there are no bindings.  Caller
should <code>svz_array_destroy</code> the returned array when done.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_binding_contains_server</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_binding_contains_server</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_server_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>server</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Checks whether the server instance <var>server</var> is
bound to the server socket structure <var>sock</var>.
Return one if so, otherwise zero.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_pp_server_bindings</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">size_t</deftype> <deffunction>svz_pp_server_bindings</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>buf</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>size</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_server_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>server</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Format a space-separated list of current port configuration
bindings for <var>server</var> into <var>buf</var>, which has <var>size</var>
bytes.  The string is guaranteed to be nul-terminated.  Return the
length (at most <code><var>size</var> - 1</code>) of the formatted string.
</para></definitionitem></deftypefun>

</subsubsection>
<node name="Server-core" spaces=" "><nodename>Server core</nodename><nodenext automatic="on">Server loop</nodenext><nodeprev automatic="on">Server binding</nodeprev><nodeup automatic="on">Server functions</nodeup></node>
<subsubsection spaces=" "><sectiontitle>Server core</sectiontitle>

<deftypevar spaces=" " endspaces=" "><definitionterm><indexterm index="vr" mergedindex="cp">svz_child_died</indexterm><defcategory automatic="on">Variable</defcategory> <deftype bracketed="on">svz_t_handle</deftype> <defvariable>svz_child_died</defvariable></definitionterm>
<definitionitem><para>Set to a non-zero value whenever the server
receives a SIGCHLD signal.
</para></definitionitem></deftypevar>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_shutting_down_p</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_shutting_down_p</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return non-zero if the core is in the process of shutting down
(typically as a result of a signal).
</para></definitionitem></deftypefun>

<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_foreach_socket</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_foreach_socket</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_do_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>func</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>closure</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Call <var>func</var> for each socket, passing additionally the second arg
<var>closure</var>.  If <var>func</var> returns a negative value, return immediately
with that value (breaking out of the loop), otherwise, return 0.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_find</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_socket_t *</deftype> <deffunction>svz_sock_find</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>id</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>version</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the socket structure for the socket id <var>id</var> and the version
<var>version</var>, or <code>NULL</code> if no such socket exists.  If <var>version</var>
is -1 it is not checked.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_schedule_for_shutdown</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_sock_schedule_for_shutdown</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Mark socket <var>sock</var> as killed.  That means that no further operations
except disconnecting and freeing are allowed.  All marked sockets will be
deleted once the server loop is through.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_enqueue</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_sock_enqueue</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Enqueue the socket <var>sock</var> into the list of sockets handled by
the server loop.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_setparent</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_sock_setparent</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>child</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>parent</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Set the <var>child</var> socket&textrsquo;s parent to <var>parent</var>.
</para>
<para>This should be called whenever a listener accepts a
connection and creates a new child socket.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_getparent</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_socket_t *</deftype> <deffunction>svz_sock_getparent</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>child</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the <var>child</var> socket&textrsquo;s parent socket structure, or <code>NULL</code>
if this socket does not exist anymore.  This might happen if a listener
dies for some reason.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_setreferrer</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_sock_setreferrer</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>referrer</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Set the referring socket structure of <var>sock</var> to <var>referrer</var>.
If <var>referrer</var> is <code>NULL</code> the reference will be invalidated.
</para>
<para>This can be used to create some relationship
between two socket structures.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_getreferrer</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_socket_t *</deftype> <deffunction>svz_sock_getreferrer</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Get the referrer of the socket structure <var>sock</var>.
Return <code>NULL</code> if there is no such socket.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_sock_portcfg</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_portcfg_t *</deftype> <deffunction>svz_sock_portcfg</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_socket_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>sock</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the parent&textrsquo;s port configuration of <var>sock</var>,
or <code>NULL</code> if the given socket has no parent, i.e. is a listener.
</para></definitionitem></deftypefun>

</subsubsection>
<node name="Server-loop" spaces=" "><nodename>Server loop</nodename><nodenext automatic="on">Server socket</nodenext><nodeprev automatic="on">Server core</nodeprev><nodeup automatic="on">Server functions</nodeup></node>
<subsubsection spaces=" "><sectiontitle>Server loop</sectiontitle>

<para>This section describes the main server loop functionality.  There two
modes of operation.  The default mode as used in Serveez is to jump into
the loop and wait until the core library drops out of it.  In the other
mode, the caller tells the Serveez core library to scan (and process)
its socket chain once and return immediately.  Thus, caller is able to
issue additional functionality in between each pass, useful if such
functionality cannot be handled within the timers (notifiers) of servers
and sockets.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_loop_pre</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_loop_pre</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Initialize top-of-cycle state.
</para>
<para>Call this function once before using <code>svz_loop_one</code>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_loop_post</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_loop_post</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Clean up bottom-of-cycle state.
</para>
<para>Call this function once after using <code>svz_loop_one</code>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_loop</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_loop</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Loop, serving.  In other words, handle all signals, incoming and outgoing
connections and listening server sockets.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_loop_one</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_loop_one</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Handle all things once.
</para>
<para>This function is called regularly by <code>svz_loop</code>.
</para></definitionitem></deftypefun>

</subsubsection>
<node name="Server-socket" spaces=" "><nodename>Server socket</nodename><nodeprev automatic="on">Server loop</nodeprev><nodeup automatic="on">Server functions</nodeup></node>
<subsubsection spaces=" "><sectiontitle>Server sockets</sectiontitle>

<para>This section deals with creating and handling listeners.  These
functions provide the default routines invoked when accepting a new
connection on a listener.  This is necessary for connection oriented
protocols (TCP and named pipes) only.
</para>
<para>[FIXME: All funcs internalized!  Write something else here!]
</para>
</subsubsection>
</subsection>
<node name="Port-config-funcs" spaces=" "><nodename>Port config funcs</nodename><nodenext automatic="on">Booting</nodenext><nodeprev automatic="on">Server functions</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Port configurations</sectiontitle>

<para>A port configuration is a structure defining a network or file system
configuration.  Depending on the type of a server, it can be bound to
one or more port configurations.  There are two major types of port
configurations: connection oriented (TCP and PIPE), and packet oriented
(ICMP, UDP and RAW).
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_portcfg_addr</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">struct sockaddr_in *</deftype> <deffunction>svz_portcfg_addr</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_portcfg_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>port</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the pointer of the <code>sockaddr_in</code> structure of the given
port configuration <var>port</var> if it is a network port configuration.
Otherwise return <code>NULL</code>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_portcfg_port</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">in_port_t</deftype> <deffunction>svz_portcfg_port</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_portcfg_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>port</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the UDP or TCP port of the given port configuration or zero
if it neither TCP nor UDP.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_portcfg_ipaddr</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">char *</deftype> <deffunction>svz_portcfg_ipaddr</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_portcfg_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>port</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the pointer to the ip address <code>ipaddr</code> of the given
port configuration <var>port</var> if it is a network port configuration.
Otherwise return <code>NULL</code>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_portcfg_device</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">char *</deftype> <deffunction>svz_portcfg_device</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_portcfg_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>port</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the network device name stored in the given port
configuration <var>port</var> if it is a network port configuration.
Return <code>NULL</code> if there is no such device set
or if the port configuration is not a network port configuration.
</para></definitionitem></deftypefun>

<para>Serveez maintains an internal list of port configurations, with each
identified by its name.  When you bind a server to a port configuration,
it does not get bound to a certain name but to its content.  If there
are two or more port configuration specifying the same network or file
system configuration just a single one gets actually used.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_portcfg_create</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_portcfg_t *</deftype> <deffunction>svz_portcfg_create</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Create a new blank port configuration.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_portcfg_equal</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_portcfg_equal</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_portcfg_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>a</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_portcfg_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>b</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Check if two given port configurations structures are equal, i.e.
specifying the same network port or pipe files.  Return
<code>SVZ_PORTCFG_EQUAL</code> if <var>a</var> and <var>b</var> are identical,
<code>SVZ_PORTCFG_MATCH</code> if the network address of either port
configuration contains the other (INADDR_ANY match), and otherwise
<code>SVZ_PORTCFG_NOMATCH</code> or possibly <code>SVZ_PORTCFG_CONFLICT</code>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_portcfg_add</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_portcfg_t *</deftype> <deffunction>svz_portcfg_add</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>name</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>svz_portcfg_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>port</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Add the given port configuration <var>port</var> associated with the name
<var>name</var> to the list of known port configurations.  Return <code>NULL</code>
on errors.  If the return port configuration equals the given port
configuration the given one has been successfully added.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_portcfg_get</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_portcfg_t *</deftype> <deffunction>svz_portcfg_get</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>name</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the port configuration associated with the given name <var>name</var>.
Return <code>NULL</code> on errors.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_portcfg_destroy</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_portcfg_destroy</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_portcfg_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>port</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Make the given port configuration <var>port</var> completely unusable,
removing it from the list of known port configurations.
Do nothing if <var>port</var> is <code>NULL</code>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_portcfg_mkaddr</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_portcfg_mkaddr</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_portcfg_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>this</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Construct the <code>sockaddr_in</code> fields from the <code>ipaddr</code> field.
Return zero if it worked.  If it does not work, the <code>ipaddr</code> field
did not consist of an ip address in dotted decimal form.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_portcfg_dup</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">svz_portcfg_t *</deftype> <deffunction>svz_portcfg_dup</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_portcfg_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>port</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Make a copy of the given port configuration <var>port</var>.
</para></definitionitem></deftypefun>

</subsection>
<node name="Booting" spaces=" "><nodename>Booting</nodename><nodenext automatic="on">Interface</nodenext><nodeprev automatic="on">Port config funcs</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Boot functions</sectiontitle>

<para>The most important functions are <code>svz_boot</code> and <code>svz_halt</code>
which must be the first and the last call to the core API.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_boot</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_boot</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>client</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Initialize the core library.
<var>client</var> is typically a program&textrsquo;s <code>argv[0]</code>.
If <code>NULL</code>, take it to be <samp>anonymous</samp>.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_uptime</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">long</deftype> <deffunction>svz_uptime</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the number of seconds since <code>svz_boot</code> was called,
or -1 if <code>svz_boot</code> has not yet been called.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_halt</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">void</deftype> <deffunction>svz_halt</deffunction> <defdelimiter>(</defdelimiter><defparamtype>void</defparamtype><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Finalization of the core library.
</para></definitionitem></deftypefun>

<subsubsection spaces=" "><sectiontitle>Runtime parameters</sectiontitle>

<para>There are several runtime parameters indicating the abilities of the
libserveez core API:
</para>
<table commandarg="code" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="code">SVZ_RUNPARM_VERBOSITY</itemformat></item>
</tableterm><tableitem><para>The log-level verbosity.
</para></tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="code">SVZ_RUNPARM_MAX_SOCKETS</itemformat></item>
</tableterm><tableitem><para>Maxium number of clients allowed to connect.
</para></tableitem></tableentry></table>

<para>These are manipulated by <code>svz_runparm</code> and two convenience macros,
both of which accept <dfn>nick</dfn>, a C token without the prefix
<samp>SVZ_RUNPARM_</samp> (e.g., <code>VERBOSITY</code>).
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_runparm</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_runparm</deffunction> <defdelimiter>(</defdelimiter><defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>a</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>b</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Set or get a runtime parameter.
If <var>a</var> is -1, return the value of runtime parameter
<var>b</var>.  If <var>a</var> specifies a runtime parameter,
set it to <var>b</var> and return 0.  Otherwise, return -1.
</para></definitionitem></deftypefun>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_RUNPARM</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_RUNPARM</deffunction> <defdelimiter>(</defdelimiter><defparam>nick</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Return the value of runtime parameter <var>nick</var>.
</para></definitionitem></defmac>
<defmac spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">SVZ_RUNPARM_X</indexterm><defcategory automatic="on">Macro</defcategory> <deffunction>SVZ_RUNPARM_X</deffunction> <defdelimiter>(</defdelimiter><defparam>nick</defparam><defdelimiter>,</defdelimiter> <defparam>val</defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Set the runtime paramater <var>nick</var>
to have value <var>val</var>, an integer.
</para></definitionitem></defmac>

</subsubsection>
</subsection>
<node name="Interface" spaces=" "><nodename>Interface</nodename><nodenext automatic="on">Windoze</nodenext><nodeprev automatic="on">Booting</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Network interface functions</sectiontitle>

<para>The network interface functions of the Serveez core API allow access to
the network devices on your system.  The system administrator can set up
these devices to be bound to different Internet addresses and thereby
split the network configuration into different <dfn>domains</dfn>.  Thus, the
system is able to separate the traffic of different networks.  If set up
correctly, Serveez can follow these rules.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_foreach_interface</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_foreach_interface</deffunction> <defdelimiter>(</defdelimiter><defparamtype>svz_interface_do_t</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>func</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>closure</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Call <var>func</var> for each interface, passing additionally the second arg
<var>closure</var>.  If <var>func</var> returns a negative value, return immediately
with that value (breaking out of the loop), otherwise, return 0.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_interface_add</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_interface_add</deffunction> <defdelimiter>(</defdelimiter><defparamtype>size_t</defparamtype><defparam>&nbsp;</defparam><defparam><var>index</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>desc</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>family</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>const</defparamtype><defparam>&nbsp;</defparam><defparamtype>void</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>bits</var></defparam><defdelimiter>,</defdelimiter> <defparamtype>int</defparamtype><defparam>&nbsp;</defparam><defparam><var>detected</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Add a network interface to the current list of known interfaces.  Drop
duplicate entries.  The given arguments <var>index</var> specifies the network
interface index number, <var>desc</var> an interface desription,
<var>family</var> an address-family (e.g., <code>AF_INET</code>), <var>bits</var> the
address data in network-byte order, and the <var>detected</var> flag if
the given network interface has been detected by Serveez itself or not.
</para></definitionitem></deftypefun>

</subsection>
<node name="Windoze" spaces=" "><nodename>Windoze</nodename><nodeprev automatic="on">Interface</nodeprev><nodeup automatic="on">Embedding API</nodeup></node>
<subsection spaces=" "><sectiontitle>Useful Windows functions</sectiontitle>

<para>Serveez is meant to run on Windows systems as well (with some
restrictions of course).  These functions are available with the Windows
implementation of the Serveez core API only.  They allow access to the
Windows registry database and some other useful things.
</para>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_windoze_daemon_control</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">int</deftype> <deffunction>svz_windoze_daemon_control</deffunction> <defdelimiter>(</defdelimiter><defparamtype>char</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>prog</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>If <var>prog</var> is non-NULL, start the daemon thread with it.
Otherwise (if <var>prog</var> is NULL), stop the daemon thread.
Return 0 on success, -1 on failure.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_windoze_asc2uni</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">WCHAR *</deftype> <deffunction>svz_windoze_asc2uni</deffunction> <defdelimiter>(</defdelimiter><defparamtype>CHAR</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>asc</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Convert an ASCII string into a UNICODE string.
</para></definitionitem></deftypefun>
<deftypefun spaces=" " endspaces=" "><definitionterm><indexterm index="fn" mergedindex="cp">svz_windoze_uni2asc</indexterm><defcategory automatic="on">Function</defcategory> <deftype bracketed="on">CHAR *</deftype> <deffunction>svz_windoze_uni2asc</deffunction> <defdelimiter>(</defdelimiter><defparamtype>WCHAR</defparamtype><defparam>&nbsp;</defparam><defparamtype>*</defparamtype><defparam><var>unicode</var></defparam><defdelimiter>)</defdelimiter></definitionterm>
<definitionitem><para>Convert a UNICODE string into an ASCII string.
</para></definitionitem></deftypefun>

</subsection>
</section>
</chapter>
<node name="Porting-issues" spaces=" "><nodename>Porting issues</nodename><nodenext automatic="on">Bibliography</nodenext><nodeprev automatic="on">Embedding</nodeprev><nodeup automatic="on">Top</nodeup></node>
<chapter spaces=" "><sectiontitle>Porting issues</sectiontitle>

<para>Serveez was always designed with an eye on maximum
portability.  Autoconf and Automake have done a great job at this.
A lot of <code>#define</code>&textrsquo;s help to work around some of the different
Unix&textrsquo; oddities.  Have a look at <file>config.h</file> for a complete list
of all these conditionals.
</para>
<para>Most doubtful might be the Win32 port.  There are two different ways of
compiling Serveez on Win32: Cygwin and MinGW.  The Cygwin version of
Serveez depends on the Unix emulation layer DLL <file>cygwin1.dll</file>.
Both versions work but it is preferable to use MinGW for performance
reasons.  The Cygwin version is slow and limited to a very low number
(some 64) of open files/network connections.<footnote><para>This was written
circa 2003&textmdash;maybe the situation is now improved.</para></footnote>
</para>
<para>There are major differences between the Win32 and Unix implementations due
to the completely different API those systems provide.
</para>
<table commandarg="asis" spaces=" " endspaces=" ">
<tableentry><tableterm><item spaces=" "><itemformat command="asis">Processes and Threads</itemformat></item>
</tableterm><tableitem><para>Because process communication is usually done by a pair of unidirectional
pipes we chose that method in order to implement the coservers in Unix.
The Win32 implementation are threads which are still part of the main
process.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Sockets and Handles</itemformat></item>
</tableterm><tableitem><para>On Win32 systems there is a difference in network sockets and file
descriptors.  Thus we had to implement quite a complex main socket loop.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Named Pipes</itemformat></item>
</tableterm><tableitem><para>Both systems Unix and Win32 do provide this functionality (Windows NT 4.0
and above).  The main differences here are the completely different APIs.
On a common Unix you create a named pipe within the filesystem via
<code>mkfifo</code>.  On Win32 you have to <code>CreateNamedPipe</code> which
will create some special network device.  A further difference is what you
can do with these pipes.  On Win32 systems this <samp>network device</samp> is
valid on remote machines.
Named pipes on Unix are unidirectional, on Win32 they are bidirectional
and instantiatable.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Winsock Versions</itemformat></item>
</tableterm><tableitem><para>There are some difference between the original Winsock 1.1 API and the new
version 2.2.x.  In a nutshell, WinSock 2 is WinSock 1.1 on steroids, it&textrsquo;s
a superset of 1.1&textrsquo;s APIs and architecture.  In addition to its new features,
it also clarifies existing ambiguities in the 1.1 WinSock specification
and adds new extensions that take advantage of operating system features
and enhance application performance and efficiency.  Finally, WinSock 2
includes a number of new protocol-specific extensions.  These extensions
&textndash;such as multicast socket options&textndash; are relegated to a separate annex,
since the main WinSock 2 protocol specification is protocol-independent.
</para>
<para>The Winsock DLL and import library for version 1.1 are <file>wsock32.dll</file>
and <file>wsock32.lib</file> and for version 2.2 it is <file>ws2_32.dll</file> and
<file>ws2_32.lib</file>.  Serveez is currently using version 2.2.
</para>
<para>The Winsock API is still a bit buggy.  Connected datagram behaviors are
not pertinent to any WinSock 2 features, but to generic WinSock.  On Win95
it is possible to use <code>recvfrom</code>/<code>WSARecvFrom</code> on a &textldquo;connected&textrdquo;
UDP socket, but on NT4 <code>recvfrom</code>/<code>WSARecvFrom</code> fail with 10056
(<code>WSAEISCONN</code>).  NOTE: <code>sendto</code>/<code>WSASendTo</code> fail with
<code>WSAEISCONN</code> on both (which I do not see any reason for, but
anyway ...).
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Raw sockets on Windows systems</itemformat></item>
</tableterm><tableitem><para>Raw sockets require Winsock 2.  To use them under Windows NT/2000, you must
be logged in as an Administrator.  On any other Microsoft&textrsquo;s we were trying
to use the <file>ICMP.DLL</file> (an idiotic and almost useless API) without
success.  Microsoft says they will replace it as soon as something better
comes along.  (Microsoft&textrsquo;s been saying this since the Windows 95 days,
however, yet this functionality still exists in Windows 2000.)
It seems like you cannot send ICMP or even raw packets from the userspace
of Windows (except via the <file>ICMP.DLL</file> which is limited to echo
requests).  We also noticed that you cannot receive any packets previously
sent.  The only thing which works on all Windows systems (9x/ME/NT/2000/XP)
is receiving packets the &textldquo;kernel&textrdquo; itself generated (like echo replies).
One good thing we noticed about Windows 2000 is that the checksums of
fragmented ICMP packets get correctly recalculated.  That is not the case
in the current Linux kernels.
</para>
</tableitem></tableentry><tableentry><tableterm><item spaces=" "><itemformat command="asis">Miscellaneous</itemformat></item>
</tableterm><tableitem><para>To use the Win32 Winsock in the Cygwin port, you just need to
<code>#define Win32_Winsock</code> and <code>#include &quot;windows.h&quot;</code> at the top
of your source file(s).  You will also want to add <code>-lwsock32</code> to
the compiler&textrsquo;s command line so you link against <file>libwsock32.a</file>.
</para>
<para>What preprocessor macros do I need to know about ?
We use <code>_WIN32</code> to signify access to the Win32 API and
<code>__CYGWIN__</code> for access to the Cygwin environment provided by the dll.
We chose <code>_WIN32</code> because this is what Microsoft defines in VC++ and we
thought it would be a good idea for compatibility with VC++ code to
follow their example.  We use <code>_MFC_VER</code> to indicate code that should be
compiled with VC++.
</para>
<para>Why we do not use pipes for coservers ?
Windows differentiates between sockets and file descriptors, that is why
you can not <code>select</code> file descriptors.  Please <code>close</code> the
pipe&textrsquo;s descriptors via <code>CloseHandle</code> and not <code>closesocket</code>,
because this will fail.
</para>
<para>The C run-time libraries have a preset limit for the number of files that
can be open at any one time.  The limit for applications that link with the
single-thread static library (<file>LIBC.LIB</file>) is 64 file handles or 20 file
streams.  Applications that link with either the static or dynamic
multithread library (<file>LIBCMT.LIB</file> or <file>MSVCRT.LIB</file> and
<file>MSVCRT.DLL</file>), have a limit of 256 file handles or 40 file streams.
Attempting to open more than the maximum number of file handles or file
streams causes program failure.
</para>
<para>As far as I know, one of the big limitations of Winsock is that
the SOCKET type is *not* equivalent to file descriptor.  It is
however with BSD and POSIX sockets.  That is one of the major reasons for
using a separate data type, SOCKET, not an int, a typical type for a
file descriptor.  This implies that you cannot mix SOCKETs and stdio,
sorry.  This is the case when you use <code>-mno-cygwin</code>.
</para>
<para>Actually they are regular file handles, just like any other.  There is a
bug in all 9x/kernel32 libc/msv/crtdll interface implementations
<code>GetFileType</code> returns <code>TYPE_UNKNOWN</code> for socket handles.  Since
this is AFAIK the only unknown type there is, you know you have a socket
handle.  There is a fix in the more recent perl distributions that you can
use as a general solution.  <code>-loldnames -lperlcrt -lmsvcrt</code> will get
you <code>TYPE_CHAR</code> for socket handles.
</para></tableitem></tableentry></table>

<para>Now follows the list on which operating systems and architectures
Serveez has been build and tested successfully.
</para>
<itemize commandarg="bullet" spaces=" " endspaces=" "><itemprepend><formattingcommand command="bullet" /></itemprepend>
<beforefirstitem>
</beforefirstitem><listitem spaces=" "><prepend>&bullet;</prepend><para>FreeBSD 3.3, 4.0, 4.3, 4.4, 4.5, 4.6, 4.7 on Intel
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>FreeBSD 4.0, 4.4, 4.6 on Alpha
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>NetBSD 1.5, 1.6 on Alpha
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>OpenBSD 3.0, 3.1 on Alpha
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>OpenBSD 3.1 on Intel
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>GNU/Linux 2.x.x on Intel
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>GNU/Linux 2.x.x on Alpha
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>GNU/Linux 2.2.x on Sparc64 (UltraSparcII + MachV)
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>GNU/Linux 2.x.x on PowerPC (RS/6000)
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>GNU/Linux 2.4.x on ia64 (Itanium)
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>GNU/Linux 2.4.x on StrongARM (iPAQ)
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>GNU/Linux 2.4.x on Motorola 680x0
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>GNU/Linux 2.4.x on IBM S/390
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>GNU/Linux 2.4.x on HP PA-RISC
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>GNU/Linux 2.4.x on MIPS
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>Solaris 2.6, 2.7 on Sparc32, Sparc64
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>SunOS 5.8 on Sparc32
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>SunOS 5.6 on Intel
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>AIX 4.3 on RS/6000
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>MacOS X10.1/Darwin 1.4, 5.4, 5.5 on PowerPC (Macintosh)
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>Windows 95 on Intel
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>Windows 98 on Intel
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>Windows Millennium Edition on Intel
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>Windows NT 4.0 on Intel
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>Windows 2000 on Intel
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>Windows XP on Intel
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>IRIX 6.x on MIPS
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>Tru64/OSF1 UNIX V4.0 (former Digital UNIX) on Alpha
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>Tru64/OSF1 UNIX V5.x (former Digital UNIX) on Alpha
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>HP-UX B.11.11 on HP PA-RISC (PA-8700/PA-8600)
</para></listitem><listitem spaces=" "><prepend>&bullet;</prepend><para>HP-UX B.11.22 on ia64 (Itanium)
</para>
</listitem></itemize>

</chapter>
<node name="Bibliography" spaces=" "><nodename>Bibliography</nodename><nodenext automatic="on">GNU Free Documentation License</nodenext><nodeprev automatic="on">Porting issues</nodeprev><nodeup automatic="on">Top</nodeup></node>
<chapter spaces=" "><sectiontitle>Bibliography</sectiontitle>

<para>This section contain some of the documents and resources we read and used
to implement various parts of this package.  They appear in no specific
order.
</para>
<enumerate first="1" endspaces=" ">
<listitem>
<para>RFC 760&linebreak;
The Internet Protocol
</para></listitem><listitem>
<para>RFC 1071&linebreak;
Computing the Internet Checksum
</para></listitem><listitem>
<para>RFC 1413&linebreak;
Identification Protocol
</para></listitem><listitem>
<para>RFC 1459&linebreak;
Internet Relay Chat Protocol
</para></listitem><listitem>
<para>RFC 1945&linebreak;
Hypertext Transfer Protocol &textndash; HTTP/1.0
</para></listitem><listitem>
<para>RFC 2068&linebreak;
Hypertext Transfer Protocol &textndash; HTTP/1.1
</para></listitem><listitem>
<para>RFC 2616&linebreak;
Hypertext Transfer Protocol &textndash; HTTP/1.1
</para></listitem><listitem>
<para>RFC 768&linebreak;
User Datagram Protocol
</para></listitem><listitem>
<para>RFC 791&linebreak;
Internet Protocol
</para></listitem><listitem>
<para>RFC 777&linebreak;
Internet Control Message Protocol
</para></listitem><listitem>
<para><uref><urefurl>http://www.mingw.org/</urefurl></uref>&linebreak;
Home of the MinGW (Minimal GNU for Windows) project
</para></listitem><listitem>
<para><uref><urefurl>http://gnutelladev.wego.com/</urefurl></uref>&linebreak;
The Gnutella Protocol
</para></listitem><listitem>
<para><uref><urefurl>http://www.efnet.org/</urefurl></uref>&linebreak;
The official EFNet site (includes Hybrid IRC server)
</para></listitem><listitem>
<para><uref><urefurl>http://www.sockets.com/</urefurl></uref>&linebreak;
Winsock Development Information
</para></listitem><listitem>
<para><uref><urefurl>http://tangentsoft.net/wskfaq/</urefurl></uref>&linebreak;
Winsock Programmer&textrsquo;s FAQ
</para></listitem></enumerate>

</chapter>
<node name="GNU-Free-Documentation-License" spaces=" "><nodename>GNU Free Documentation License</nodename><nodenext automatic="on">Index</nodenext><nodeprev automatic="on">Bibliography</nodeprev><nodeup automatic="on">Top</nodeup></node>
<appendix spaces=" "><sectiontitle>GNU Free Documentation License</sectiontitle>

<!-- c The GNU Free Documentation License. -->
<center spaces=" ">Version 1.3, 3 November 2008</center>

<!-- c This file is intended to be included within another document, -->
<!-- c hence no sectioning command or @node. -->

<display endspaces=" ">
<pre xml:space="preserve">Copyright &copyright; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
<uref><urefurl>http://fsf.org/</urefurl></uref>

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</pre></display>

<enumerate spaces=" " endspaces=" "><enumeratefirst>0</enumeratefirst>
<listitem>
<para>PREAMBLE
</para>
<para>The purpose of this License is to make a manual, textbook, or other
functional and useful document <dfn>free</dfn> in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.
</para>
<para>This License is a kind of &textldquo;copyleft&textrdquo;, which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.
</para>
<para>We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.
</para>
</listitem><listitem>
<para>APPLICABILITY AND DEFINITIONS
</para>
<para>This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The &textldquo;Document&textrdquo;, below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as &textldquo;you&textrdquo;.  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.
</para>
<para>A &textldquo;Modified Version&textrdquo; of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.
</para>
<para>A &textldquo;Secondary Section&textrdquo; is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document&textrsquo;s overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.
</para>
<para>The &textldquo;Invariant Sections&textrdquo; are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.
</para>
<para>The &textldquo;Cover Texts&textrdquo; are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.
</para>
<para>A &textldquo;Transparent&textrdquo; copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not &textldquo;Transparent&textrdquo; is called &textldquo;Opaque&textrdquo;.
</para>
<para>Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, La&tex; input
format, SGML or XML using a publicly available
DTD, and standard-conforming simple HTML,
PostScript or PDF designed for human modification.  Examples
of transparent image formats include PNG, XCF and
JPG.  Opaque formats include proprietary formats that can be
read and edited only by proprietary word processors, SGML or
XML for which the DTD and/or processing tools are
not generally available, and the machine-generated HTML,
PostScript or PDF produced by some word processors for
output purposes only.
</para>
<para>The &textldquo;Title Page&textrdquo; means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, &textldquo;Title Page&textrdquo; means
the text near the most prominent appearance of the work&textrsquo;s title,
preceding the beginning of the body of the text.
</para>
<para>The &textldquo;publisher&textrdquo; means any person or entity that distributes copies
of the Document to the public.
</para>
<para>A section &textldquo;Entitled XYZ&textrdquo; means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as &textldquo;Acknowledgements&textrdquo;,
&textldquo;Dedications&textrdquo;, &textldquo;Endorsements&textrdquo;, or &textldquo;History&textrdquo;.)  To &textldquo;Preserve the Title&textrdquo;
of such a section when you modify the Document means that it remains a
section &textldquo;Entitled XYZ&textrdquo; according to this definition.
</para>
<para>The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.
</para>
</listitem><listitem>
<para>VERBATIM COPYING
</para>
<para>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.
</para>
<para>You may also lend copies, under the same conditions stated above, and
you may publicly display copies.
</para>
</listitem><listitem>
<para>COPYING IN QUANTITY
</para>
<para>If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document&textrsquo;s license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.
</para>
<para>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.
</para>
<para>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.
</para>
<para>It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.
</para>
</listitem><listitem>
<para>MODIFICATIONS
</para>
<para>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:
</para>
<enumerate first="A" spaces=" " endspaces=" "><enumeratefirst>A</enumeratefirst>
<listitem>
<para>Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.
</para>
</listitem><listitem>
<para>List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has fewer than five),
unless they release you from this requirement.
</para>
</listitem><listitem>
<para>State on the Title page the name of the publisher of the
Modified Version, as the publisher.
</para>
</listitem><listitem>
<para>Preserve all the copyright notices of the Document.
</para>
</listitem><listitem>
<para>Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.
</para>
</listitem><listitem>
<para>Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.
</para>
</listitem><listitem>
<para>Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document&textrsquo;s license notice.
</para>
</listitem><listitem>
<para>Include an unaltered copy of this License.
</para>
</listitem><listitem>
<para>Preserve the section Entitled &textldquo;History&textrdquo;, Preserve its Title, and add
to it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section Entitled &textldquo;History&textrdquo; in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.
</para>
</listitem><listitem>
<para>Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the &textldquo;History&textrdquo; section.
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.
</para>
</listitem><listitem>
<para>For any section Entitled &textldquo;Acknowledgements&textrdquo; or &textldquo;Dedications&textrdquo;, Preserve
the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgements and/or
dedications given therein.
</para>
</listitem><listitem>
<para>Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.
</para>
</listitem><listitem>
<para>Delete any section Entitled &textldquo;Endorsements&textrdquo;.  Such a section
may not be included in the Modified Version.
</para>
</listitem><listitem>
<para>Do not retitle any existing section to be Entitled &textldquo;Endorsements&textrdquo; or
to conflict in title with any Invariant Section.
</para>
</listitem><listitem>
<para>Preserve any Warranty Disclaimers.
</para></listitem></enumerate>

<para>If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version&textrsquo;s license notice.
These titles must be distinct from any other section titles.
</para>
<para>You may add a section Entitled &textldquo;Endorsements&textrdquo;, provided it contains
nothing but endorsements of your Modified Version by various
parties&textmdash;for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.
</para>
<para>You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.
</para>
<para>The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.
</para>
</listitem><listitem>
<para>COMBINING DOCUMENTS
</para>
<para>You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.
</para>
<para>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.
</para>
<para>In the combination, you must combine any sections Entitled &textldquo;History&textrdquo;
in the various original documents, forming one section Entitled
&textldquo;History&textrdquo;; likewise combine any sections Entitled &textldquo;Acknowledgements&textrdquo;,
and any sections Entitled &textldquo;Dedications&textrdquo;.  You must delete all
sections Entitled &textldquo;Endorsements.&textrdquo;
</para>
</listitem><listitem>
<para>COLLECTIONS OF DOCUMENTS
</para>
<para>You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.
</para>
<para>You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.
</para>
</listitem><listitem>
<para>AGGREGATION WITH INDEPENDENT WORKS
</para>
<para>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an &textldquo;aggregate&textrdquo; if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation&textrsquo;s users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.
</para>
<para>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document&textrsquo;s Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.
</para>
</listitem><listitem>
<para>TRANSLATION
</para>
<para>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.
</para>
<para>If a section in the Document is Entitled &textldquo;Acknowledgements&textrdquo;,
&textldquo;Dedications&textrdquo;, or &textldquo;History&textrdquo;, the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.
</para>
</listitem><listitem>
<para>TERMINATION
</para>
<para>You may not copy, modify, sublicense, or distribute the Document
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense, or distribute it is void, and
will automatically terminate your rights under this License.
</para>
<para>However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.
</para>
<para>Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.
</para>
<para>Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, receipt of a copy of some or all of the same material does
not give you any rights to use it.
</para>
</listitem><listitem>
<para>FUTURE REVISIONS OF THIS LICENSE
</para>
<para>The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
<uref><urefurl>http://www.gnu.org/copyleft/</urefurl></uref>.
</para>
<para>Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License &textldquo;or any later version&textrdquo; applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.  If the Document
specifies that a proxy can decide which future versions of this
License can be used, that proxy&textrsquo;s public statement of acceptance of a
version permanently authorizes you to choose that version for the
Document.
</para>
</listitem><listitem>
<para>RELICENSING
</para>
<para>&textldquo;Massive Multiauthor Collaboration Site&textrdquo; (or &textldquo;MMC Site&textrdquo;) means any
World Wide Web server that publishes copyrightable works and also
provides prominent facilities for anybody to edit those works.  A
public wiki that anybody can edit is an example of such a server.  A
&textldquo;Massive Multiauthor Collaboration&textrdquo; (or &textldquo;MMC&textrdquo;) contained in the
site means any set of copyrightable works thus published on the MMC
site.
</para>
<para>&textldquo;CC-BY-SA&textrdquo; means the Creative Commons Attribution-Share Alike 3.0
license published by Creative Commons Corporation, a not-for-profit
corporation with a principal place of business in San Francisco,
California, as well as future copyleft versions of that license
published by that same organization.
</para>
<para>&textldquo;Incorporate&textrdquo; means to publish or republish a Document, in whole or
in part, as part of another Document.
</para>
<para>An MMC is &textldquo;eligible for relicensing&textrdquo; if it is licensed under this
License, and if all works that were first published under this License
somewhere other than this MMC, and subsequently incorporated in whole
or in part into the MMC, (1) had no cover texts or invariant sections,
and (2) were thus incorporated prior to November 1, 2008.
</para>
<para>The operator of an MMC Site may republish an MMC contained in the site
under CC-BY-SA on the same site at any time before August 1, 2009,
provided the MMC is eligible for relicensing.
</para>
</listitem></enumerate>

<page></page>
<heading spaces=" ">ADDENDUM: How to use this License for your documents</heading>

<para>To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:
</para>
<smallexample endspaces=" ">
<group endspaces=" ">
<pre xml:space="preserve">  Copyright (C)  <var>year</var>  <var>your name</var>.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.3
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
</pre></group>
</smallexample>

<para>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the &textldquo;with&dots;Texts.&textrdquo; line with this:
</para>
<smallexample endspaces=" ">
<group endspaces=" ">
<pre xml:space="preserve">    with the Invariant Sections being <var>list their titles</var>, with
    the Front-Cover Texts being <var>list</var>, and with the Back-Cover Texts
    being <var>list</var>.
</pre></group>
</smallexample>

<para>If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.
</para>
<para>If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.
</para>
<!-- c Local Variables: -->
<!-- c ispell-local-pdict: "ispell-dict" -->
<!-- c End: -->


</appendix>
<node name="Index" spaces=" "><nodename>Index</nodename><nodeprev automatic="on">GNU Free Documentation License</nodeprev><nodeup automatic="on">Top</nodeup></node>
<unnumbered spaces=" "><sectiontitle>Index</sectiontitle>

<printindex value="cp" line=" cp"></printindex>

</unnumbered>
<bye></bye>
</texinfo>
