<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE texinfo PUBLIC "-//GNU//DTD TexinfoML V4.13//EN" "http://www.gnu.org/software/texinfo/dtd/4.13/texinfo.dtd">
<texinfo xml:lang="en">
  <setfilename>serveez.xml</setfilename>
  <settitle>GNU Serveez</settitle>
  <setvalue name="txideftypefnnl"></setvalue>
<!-- %** end of header -->
  <setvalue name="UPDATED">29 November 2012</setvalue>
  <setvalue name="UPDATED-MONTH">November 2012</setvalue>
  <setvalue name="EDITION">0.1.7</setvalue>
  <setvalue name="VERSION">0.1.7</setvalue>
  <para>This manual documents GNU Serveez 0.1.7, released 29 November 2012.</para>
  <para>Copyright &copyright; 2011, 2012 Thien-Thi Nguyen&linebreak; Copyright &copyright; 2000&ndash;2002 Stefan Jahn &lt;stefan@lkcc.org&gt;&linebreak; Copyright &copyright; 2000&ndash;2002 Raimund Jacob &lt;raimi@lkcc.org&gt;&linebreak; Copyright &copyright; 1999 Martin Grabmueller &lt;mgrabmue@cs.tu-berlin.de&gt;</para>
  <quotation>
    <para>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation. A copy of the license is included in the section entitled &ldquo;GNU Free Documentation License&rdquo;.</para>
  </quotation>
  <setvalue name="PACKAGE">Serveez</setvalue>
  <setvalue name="s_PACKAGE">serveez</setvalue>
  <dircategory>Serveez - A server framework.</dircategory>
  <titlepage>
    <booktitle>GNU Serveez</booktitle>
    <booksubtitle>A server framework</booksubtitle>
    <booksubtitle>Edition 0.1.7, 29 November 2012</booksubtitle>
    <author>Stefan Jahn</author>
    <author>Raimund Jacob</author>
    <author>Thien-Thi Nguyen</author>
    <para>This manual documents GNU Serveez 0.1.7, released 29 November 2012.</para>
    <para>Copyright &copyright; 2011, 2012 Thien-Thi Nguyen&linebreak; Copyright &copyright; 2000&ndash;2002 Stefan Jahn &lt;stefan@lkcc.org&gt;&linebreak; Copyright &copyright; 2000&ndash;2002 Raimund Jacob &lt;raimi@lkcc.org&gt;&linebreak; Copyright &copyright; 1999 Martin Grabmueller &lt;mgrabmue@cs.tu-berlin.de&gt;</para>
    <quotation>
      <para>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation. A copy of the license is included in the section entitled &ldquo;GNU Free Documentation License&rdquo;.</para>
    </quotation>
  </titlepage>
  <contents></contents>
  <node>
    <nodename>Top</nodename>
    <nodenext>Using Serveez</nodenext>
    <nodeup>(dir)</nodeup>
    <unnumbered>
      <title>GNU Serveez</title>
      <para>This manual documents GNU Serveez 0.1.7, released 29 November 2012.</para>
<!-- blurb.texi - standard GNU Serveez description -->
<!-- Copyright (C) 2011, 2012 Thien-Thi Nguyen -->
<!-- Copyright (C) 2000, 2001, 2002 Stefan Jahn <stefan@lkcc.org> -->
<!-- Copyright (C) 2000, 2001, 2002 Raimund Jacob <raimi@lkcc.org> -->
<!-- Copyright (C) 1999 Martin Grabmueller <mgrabmue@cs.tu-berlin.de> -->
<!-- Permission is granted to copy, distribute and/or modify this document -->
<!-- under the terms of the GNU Free Documentation License, Version 1.1 -->
<!-- or any later version published by the Free Software Foundation. -->
<!-- A copy of the license is included in the section entitled "GNU -->
<!-- Free Documentation License". -->
<!--  -->
<!-- The following text is found in various places, not only in texinfo -->
<!-- documentation, so we keep it simple (don't include any markup). -->
      <para>GNU Serveez is a server framework.  It provides routines and help for implementing IP-based servers (currently TCP, UDP and ICMP). It supports named pipes for all connection-oriented protocols.</para>
      <para>We think it is worth the effort because many people need server functionality within their applications.  However, many people experience problems with select(2) or poll(2) loops, and with non-blocking operations.</para>
      <para>GNU Serveez demonstrates various aspects of advanced network programming in a portable manner.  It is known to compile and run on GNU/Linux systems, as well as on other 32-bit and 64-bit flavours of Unix and on Microsoft Windows (9x/ME/NT/2000/XP).</para>
      <para>You can use it for implementing your own servers or for understanding how certain network services and operations work.</para>
      <para>The package includes a number of servers that work already: an HTTP server, an IRC server, a Gnutella spider and some others. One of the highlights is that you can run all protocols on the same port.  The application itself is single threaded but it uses helper processes for concurrent name resolution and ident lookups.</para>
      <menu>
        <menuentry>
          <menunode>Using Serveez</menunode>
          <menutitle>Using Serveez</menutitle>
          <menucomment>Startup and command line options</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Concept</menunode>
          <menutitle>Concept</menutitle>
          <menucomment>Conceptual thoughts</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Server</menunode>
          <menutitle>Server</menutitle>
          <menucomment>Server implementation</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Coserver</menunode>
          <menutitle>Coserver</menutitle>
          <menucomment>Coserver implementation</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Embedding</menunode>
          <menutitle>Embedding</menutitle>
          <menucomment>Using libserveez in your own program</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Porting issues</menunode>
          <menutitle>Porting issues</menutitle>
          <menucomment>Support of different platforms and operating systems</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Bibliography</menunode>
          <menutitle>Bibliography</menutitle>
          <menucomment>Useful documents we refer to</menucomment>
        </menuentry>
        <menuentry>
          <menunode>GNU Free Documentation License</menunode>
          <menutitle>GNU Free Documentation License</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Index</menunode>
          <menutitle>Index</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </unnumbered>
  </node>
  <node>
    <nodename>Using Serveez</nodename>
    <nodenext>Concept</nodenext>
    <nodeprev>Top</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Using Serveez</title>
      <para>We know, you usually don't read the documentation.  Who does.  But please, read at the very least this chapter.  It contains information on the basic concepts.  Larger parts of the manual can be used as a reference manual for the various servers.</para>
      <menu>
        <menuentry>
          <menunode>Build and install</menunode>
          <menutitle>Build and install</menutitle>
          <menucomment>Making Serveez a part of your system</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Environment variables</menunode>
          <menutitle>Environment variables</menutitle>
          <menucomment>Hints for the dynamic module loader</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Starting Serveez</menunode>
          <menutitle>Starting Serveez</menutitle>
          <menucomment>The moment of truth</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Command line options</menunode>
          <menutitle>Command line options</menutitle>
          <menucomment>Specifying the config file and other params</menucomment>
        </menuentry>
        <menuentry>
          <menunode>The config file</menunode>
          <menutitle>The config file</menutitle>
          <menucomment>Defining servers, ports, and how they relate</menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Build and install</nodename>
    <nodenext>Environment variables</nodenext>
    <nodeup>Using Serveez</nodeup>
    <section>
      <title>Building and installing</title>
      <subsection>
        <title>Rebuild the package from the sources</title>
        <para>You can skip this section if you are familiar with the GNU'ish way of configuring, compiling and installing a GNU package.</para>

        <subsubsection>
          <title>Getting the source</title>
          <para>Serveez can be found on <uref><urefurl>http://ftp.gnu.org/gnu/serveez/</urefurl></uref>, on one of the mirrors (<uref><urefurl>http://www.gnu.org/prep/ftp.html</urefurl></uref>) or at its original location <uref><urefurl>http://www.lkcc.org/~ela/download/</urefurl></uref>.</para>
        </subsubsection>

        <subsubsection>
          <title>Requirements</title>
          <para>Serveez needs GNU Guile (Ubiquitous Intelligent Language for Extensions). The current version of Serveez is known to work with Guile 1.3 and later. Guile can be downloaded at <uref><urefurl>http://ftp.gnu.org/gnu/guile/</urefurl></uref>.</para>
          <para>When installing Guile, consider specifying to its <file>configure</file> script options along the lines of:</para>
          <example xml:space="preserve">--enable-static --disable-shared
--disable-debug-freelist
--disable-debug-malloc
--disable-guile-debug
--disable-arrays --disable-posix
--enable-networking --disable-regex
--without-threads --enable-ltdl-convenience</example>
          <para>This option set is tuned for Guile 1.4 and may or may not work for your particular installation; you may need to experiment a bit. Most important is that the program <samp>guile-config</samp> be findable in a directory named in the <code>PATH</code> environment variable. If not, configuration will fail with message &ldquo;Guile not found&rdquo;.</para>
        </subsubsection>

        <subsubsection>
          <title>Installation</title>
          <table>
            <tableitem>
              <tableterm>Unpack the distribution tarball:</tableterm>
              <item>
                <example xml:space="preserve">sleepless ~&gt; gzip -cd serveez-0.1.7.tar.gz | tar xvf -</example>
              </item>
            </tableitem>
            <tableitem>
              <tableterm>Change into the source directory:</tableterm>
              <item>
                <example xml:space="preserve">sleepless ~&gt; cd serveez-0.1.7</example>
              </item>
            </tableitem>
            <tableitem>
              <tableterm>Configure the source package for your system:</tableterm>
              <item>
                <para>Normally, this is done by running the <file>configure</file> script in the top-level directory. GNU Serveez needs a reasonably conformant C99 compiler to build. If the <file>configure</file> script is not able to automatically find and enable such a compiler, you can specify it directly using the <samp>CC</samp> command-line option.  For example:</para>
                <example xml:space="preserve">sleepless ~&gt; ./configure --prefix /gnu CC='/gnu/bin/gcc'</example>
                <para>Note that in this example you can achieve the same results by making sure <file>/gnu/bin</file> is in the <code>PATH</code> env var.</para>
                <para>In previous Serveez releases, the <file>configure</file> script had some builtin compiler flags for warnings and optimizations, conveniently exposed via command-line options.  These are no longer available; instead, you can use <code>CFLAGS</code> for such purposes (see below). Here is a complete list of the <file>configure</file> script options.  The list of known options can the obtained via <samp>./configure --help</samp>.</para>
                <table>
                  <tableitem>
                    <tableterm><samp>--enable-debug</samp></tableterm>
                    <item>
                      <para>All of the debug messages (debug: some annoying crap text) can be suppressed by setting the debug level (-v).  If you do not want these messages built in at all then disable this feature.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-control-proto</samp></tableterm>
                    <item>
                      <para>If you enable this feature the control protocol will be supported by Serveez.  This protocol is for remote control of the server.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-irc-proto</samp></tableterm>
                    <item>
                      <para>Enabling this feature tells the software package to support the IRC (Internet Relay Chat) protocol.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-irc-ts</samp></tableterm>
                    <item>
                      <para>This feature is only available if you enabled the IRC protocol. If you enabled both of them then Serveez will support the so called TimeStamp protocol, which is an EFNet extension of the original IRC protocol.  In order to connect to EFNet you MUST use this option.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-http-proto</samp></tableterm>
                    <item>
                      <para>When using Serveez as part of the textSure (C) chat system you will will have need of an additional web server.  This option makes Serveez support a simple HTTP protocol.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-flood</samp></tableterm>
                    <item>
                      <para>If you enable this feature Serveez will support a simple built-in flood protection.  It is always useful to protect the software from flood clients.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--with-mingw=DIR</samp></tableterm>
                    <item>
                      <para>When compiling under M$-Windows the <var>DIR</var> argument specifies the path to the extra MinGW32 library and header files.  If you want the final executable to use the Cygwin project's <file>cygwin1.dll</file> instead, you have to disable this option by passing the configure script <samp>--without-mingw</samp> or <samp>--with-mingw=no</samp>.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-sntp-proto</samp></tableterm>
                    <item>
                      <para>This option enables support for a simple network time protocol server.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-poll</samp></tableterm>
                    <item>
                      <para>If the target system supports <code>poll</code> and this feature is enabled the main file descriptor loop is done via <code>poll</code>. This helps to work around the (g)libc's file descriptor limit. Otherwise Serveez always falls back to the <code>select</code> system call.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-sendfile</samp></tableterm>
                    <item>
                      <para>This option enables the use of the <code>sendfile</code> system call. Disabling it using <samp>--disable-sendfile</samp> provides a work-around for bogus implementations of <code>sendfile</code>.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-gnutella</samp></tableterm>
                    <item>
                      <para>If you do *not* want the Gnutella spider client compiled in you need to *disable* this option.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-crypt</samp></tableterm>
                    <item>
                      <para>This option tells Serveez to process any passwords as <code>crypt</code>ed.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-tunnel</samp></tableterm>
                    <item>
                      <para>If you enable this feature the port forwarder will be included. This is useful if you plan to use Serveez as a gateway or firewall workaround.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-fakeident</samp></tableterm>
                    <item>
                      <para>By enabling this you will get a fake ident server included in the binary executable.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-guile-server</samp></tableterm>
                    <item>
                      <para>If you enable this feature the user is able to write servers using Guile.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-passthrough</samp></tableterm>
                    <item>
                      <para>This includes the program passthrough server in the Serveez binary.  The server provides basic inetd functionality.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-iflist</samp></tableterm>
                    <item>
                      <para>If Serveez is unable to detect the correct list of local network interfaces (<samp>serveez -i</samp>) you can disable this option and setup them manually in the configuration file.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-heap-count</samp></tableterm>
                    <item>
                      <para>This option depends on <samp>--enable-debug</samp>.  With the debugging option disabled there is also no support for heap counters.  The heap counters are used to detect memory leaks in Serveez.</para>
                    </item>
                  </tableitem>
                  <tableitem>
                    <tableterm><samp>--enable-libserveez-install</samp></tableterm>
                    <item>
                      <para>This causes <samp>make install</samp> to also copy libserveez and its header files to <code>$(libdir)</code> and <code>$(includedir)</code>, respectively. While Serveez is in alpha (version less than <samp>0.8.0</samp>), this option is disabled by default.</para>
                    </item>
                  </tableitem>
                </table>
                <para>For maximum flexibility and reproducibility, we recommend enabling warnings and optimizations specifying <code>CFLAGS</code> as a command-line option to the <file>configure</file> script.  For reference, here is the collected set of flags built into previous Serveez releases:</para>
                <example xml:space="preserve"><r>(warnings)</r>
  -W -fullwarn -pedantic -ansi
  -Wall -Wcast-align -Wstrict-prototypes
  -Wformat -Wno-unused -Wno-long-long

<r>(optimizations)</r>
  -O2 -fomit-frame-pointer -fstrength-reduce
  -funroll-loops -finline-functions
  -fexpensive-optimizations -fcaller-saves
  -frerun-loop-opt -foptimize-register-move
  -ffunction-cse -fpeephole -momit-leaf-frame-pointer
  -fschedule-insns2 -m486 -march=pentiumpro -O3</example>
                <para>Note that not all flags may be compatible with your compiler or even each other.  That's one of the reasons we no longer take this approach. See <xref><xrefnodename>Defining Variables</xrefnodename><xrefinfofile>autoconf</xrefinfofile><xrefprintedname>The Autoconf Manual</xrefprintedname></xref>.</para>
                <example xml:space="preserve">sleepless ~/serveez-0.1.7&gt; ./configure \
  CFLAGS='-g -O3 -Wall -Wextra'</example>
              </item>
            </tableitem>
            <tableitem>
              <tableterm>Now compile the package:</tableterm>
              <item>
                <example xml:space="preserve">sleepless ~/serveez-0.1.7&gt; make</example>
              </item>
            </tableitem>
            <tableitem>
              <tableterm>Install serveez:</tableterm>
              <item>
                <para>You must have root privileges if you want to install the package in the standard location <file>/usr/local</file> or in any location that is only writable by root.</para>
                <example xml:space="preserve">sleepless ~/serveez-0.1.7&gt; make install</example>
              </item>
            </tableitem>
          </table>
          <para>If you have problems building the package out of the box this is due to GNU libtool's inability to handle dynamic linking in most cases.  That is why we recommend to try to configure the package with <samp>--disable-shared</samp>.</para>
        </subsubsection>
      </subsection>
    </section>
  </node>
  <node>
    <nodename>Environment variables</nodename>
    <nodenext>Starting Serveez</nodenext>
    <nodeprev>Build and install</nodeprev>
    <nodeup>Using Serveez</nodeup>
    <section>
      <title>Environment variables</title>
      <para>When using the serveezopt package or playing around with the dynamic server module loader of Serveez you can tell the core API of Serveez (which is the <file>libserveez.[so|dll]</file> library) to use an additional load path to find these server modules.  The environment variable <samp>SERVEEZ_LOAD_PATH</samp> holds this information.  You can set it up via:</para>
      <example xml:space="preserve">  on Unices
sleepless ~&gt; export SERVEEZ_LOAD_PATH=/home/lib:/usr/local/lib

  or on Windows
C:\HOME&gt; set SERVEEZ_LOAD_PATH=C:\HOME\LIB;C:\USR\LOCAL\LIB</example>
    </section>
  </node>
  <node>
    <nodename>Starting Serveez</nodename>
    <nodenext>Command line options</nodenext>
    <nodeprev>Environment variables</nodeprev>
    <nodeup>Using Serveez</nodeup>
    <section>
      <title>Starting Serveez</title>
      <para>When Serveez is started it reads its configuration from a file called <file>serveez.cfg</file> in the current directory and runs the server loop afterwards.  Press <key>^C</key>  to abort the execution of this program. Serveez is not interactive and does not automatically detach from the terminal.</para>
    </section>
  </node>
  <node>
    <nodename>Command line options</nodename>
    <nodenext>The config file</nodenext>
    <nodeprev>Starting Serveez</nodeprev>
    <nodeup>Using Serveez</nodeup>
    <section>
      <title>Command line options</title>
      <table>
        <tableitem>
          <tableterm><code>-h, --help</code></tableterm>
          <item>
            <para>Display this help and exit.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-V, --version</code></tableterm>
          <item>
            <para>Display version information and exit.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-i, --iflist</code></tableterm>
          <item>
            <para>List local network interfaces and exit.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-f, --cfg-file=FILENAME</code></tableterm>
          <item>
            <para>File to use as configuration file (serveez.cfg).</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-v, --verbose=LEVEL</code></tableterm>
          <item>
            <para>Set level of logging verbosity.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-l, --log-file=FILENAME</code></tableterm>
          <item>
            <para>Use <code>FILENAME</code> for logging (default is stderr).</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-P, --password=STRING</code></tableterm>
          <item>
            <para>Set the password for control connections. This option is available only if the control protocol is enabled. See <xref><xrefnodename>Control Protocol Server</xrefnodename></xref>.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-m, --max-sockets=COUNT</code></tableterm>
          <item>
            <para>Set the maximum number of socket descriptors.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-d, --daemon</code></tableterm>
          <item>
            <para>Start as daemon in background.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-c, --stdin</code></tableterm>
          <item>
            <para>Use standard input as configuration file.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-s, --solitary</code></tableterm>
          <item>
            <para>Do not start any builtin coserver instances.</para>
          </item>
        </tableitem>
      </table>
    </section>
  </node>
  <node>
    <nodename>The config file</nodename>
    <nodeprev>Command line options</nodeprev>
    <nodeup>Using Serveez</nodeup>
    <section>
      <title>Configuring Serveez</title>
      <para>As noted above Serveez is configured via a configuration file which is by default <file>serveez.cfg</file> and can be set by passing the <samp>-f</samp> command line argument.  When you pipe a file into Serveez or pass the <samp>-c</samp> argument on the command line the input stream will be used as configuration file no matter whether you passed a <samp>-f</samp> command line switch or not.</para>
      <para>To make configuring more fun we did not invent yet another configuration file format.  Instead we use a dialect of the Scheme programming language called GNU Guile (<uref><urefurl>http://www.gnu.org/software/guile/</urefurl></uref>).  There is no need to be worried if you are not a programmer.  What you have to do is really simple and this document shows you everything you need to know.  We also provide many examples.  However there are some simple concepts you have to understand.  The following paragraphs will explain them.</para>
      <para>The idea of the configuration file is this: Serveez starts, runs the configuration file (other applications usually just read them and remember the settings) and finally enters its main loop doing the things you wanted it to.</para>
      <para>There are three things you have to do in the configuration file.</para>
      <menu>
        <menuentry>
          <menunode>Define ports</menunode>
          <menutitle>Define ports</menutitle>
          <menucomment>Port configuration definition</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Define servers</menunode>
          <menutitle>Define servers</menutitle>
          <menucomment>Server definition</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Bind servers to ports</menunode>
          <menutitle>Bind servers to ports</menutitle>
          <menucomment>How to bind servers to port configurations</menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>Define ports</nodename>
    <nodenext>Define servers</nodenext>
    <nodeup>The config file</nodeup>
    <subsection>
      <title>Define ports</title>
      <para>A <code>port</code> (in Serveez) is a transport endpoint.  You might know them from other TCP or UDP server applications.  For example: web servers (HTTP) usually listen on TCP port 80.  However, there is more than TCP ports: we have UDP, ICMP and named pipes each with different options to set.  Every port has a unique name you assign to it.  The name of the port is later used to bind servers to it.</para>
      <para>The following examples show how you setup different types of port configurations.  You start to define such a port using the procedure <code>define-port!</code>.  The first argument specifies the name of the port configuration.  The remaining argument describes the port in detail.</para>

      <subsubsection>
        <title>Port configuration items</title>
        <para>This table describes each configuration item for a port in Serveez.  Note that not each item applies to every kind of port configuration.</para>
        <table>
          <tableitem>
            <tableterm><code>proto (string)</code></tableterm>
            <item>
              <para>This is the main configuration item for a port configuration setting up the type of port.  Valid values are <samp>tcp</samp>, <samp>udp</samp>, <samp>icmp</samp>, <samp>raw</samp> and <samp>pipe</samp>.  This configuration item decides which of the remaining configuration items apply and which do not.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>port (integer in the range 0..65535)</code></tableterm>
            <item>
              <para>The <code>port</code> item determines the network port number on which TCP and UDP servers will listen.  Thus it does not make sense for ICMP and named pipes. If you pass <samp>0</samp> Serveez will determine a free port in the range between 1 and 65535.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>recv (string or associative list)</code></tableterm>
            <item>
              <para>This item describes the receiving (listening) end of a named pipe connection, i.e., the filename of a fifo node to which a client can connect by opening it for writing.  Both the <code>recv</code> and <code>send</code> item apply to named pipes only.  The value can either be an associative list or a simple filename.  Using a simple filename leaves additional options to use default values.  They deal mainly with file permissions and are described below.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>send (string or associative list)</code></tableterm>
            <item>
              <para>This item is the sending end of a named pipe connection.  It is used to send data when the receiving (listening) end has detected a connection. The following table enumerates the additional options you can setup if you pass an associative list and not a simple filename.</para>
              <table>
                <tableitem>
                  <tableterm><code>name (string)</code></tableterm>
                  <item>
                    <para>The filename of the named pipe.  On Windows systems you can also specify the hostname on which the pipe should be created in the format <samp>\\hostname\pipe\name</samp>.  By default (if you leave the leading <samp>\\hostname\pipe\</samp> part) the pipe will be created on <samp>\\.\pipe\name</samp> which refers to a pipe on the local machine.</para>
                  </item>
                </tableitem>
                <tableitem>
                  <tableterm><code>permission (octal integer)</code></tableterm>
                  <item>
                    <para>This specifies the file permissions a named pipe should be created with. The given number is interpreted in a Unix'ish style (e.g., <samp>#o0666</samp> is a permission field for reading and writing for the creating user, all users in the same group and all other users).</para>
                  </item>
                </tableitem>
                <tableitem>
                  <tableterm><code>user (string)</code></tableterm>
                  <item>
                    <para>The file owner (username) of the named pipe in textual form.</para>
                  </item>
                </tableitem>
                <tableitem>
                  <tableterm><code>group (string)</code></tableterm>
                  <item>
                    <para>The file owner group (groupname) of the named pipe in textual form.  If this item is left it defaults to the file owner's primary group.</para>
                  </item>
                </tableitem>
                <tableitem>
                  <tableterm><code>uid (integer)</code></tableterm>
                  <item>
                    <para>The file owner of the named pipe as a user id.  You are meant to specify either the <code>uid</code> item or the <code>user</code> item.  Serveez will complain about conflicting values.</para>
                  </item>
                </tableitem>
                <tableitem>
                  <tableterm><code>gid (integer)</code></tableterm>
                  <item>
                    <para>The file owner group of the named pipe as a group id.  This item defaults to the file owner's primary group id.  You are meant to specify either the <code>gid</code> item or the <code>group</code> item.  Serveez will croak about conflicting values.</para>
                  </item>
                </tableitem>
              </table>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>ipaddr (string)</code></tableterm>
            <item>
              <para>This configuration item specifies the IP address (either in dotted decimal form e.g., <samp>192.168.2.1</samp> or as a device description which can be obtained via <samp>serveez -i</samp>) to which a server is bound to.  The <samp>*</samp> keyword for all known IP addresses and the <samp>any</samp> keyword for any IP address are also valid values.  The default value is <samp>*</samp>.  The configuration item applies to network ports (TCP, UDP and ICMP) only.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>device (string)</code></tableterm>
            <item>
              <para>The <code>device</code> configuration item also refers to the IP address a server can be bound to.  It overrides the <code>ipaddr</code> item.  Valid values are network device descriptions (probably no aliases and no loopback devices). It applies to network ports (TCP, UDP and ICMP) only.</para>
              <para>A note on device bindings:  Device bindings are based on the <code>SO_BINDTODEVICE</code> socket layer option.  This option is not available on all systems.  We only tested it on GNU/Linux (2.2.18 and 2.4.17 as of this writing).  Device bindings are very restrictive: only root can do it and only physical devices are possible.  The loopback device cannot be used and no interface alias (i.e., <samp>eth0:0</samp>).  A device binding can only be reached from the physical outside but it includes all aliases for the device.  So if you bind to device <samp>eth0</samp> even <samp>eth0:0</samp> (and all other aliases) are used.  The connection has to be made from a remote machine.  The advantage of this kind of binding is that it survives changes of IP addresses.  This is tested for ethernet networks (i.e., eth*) and isdn dialups (i.e., ippp*).  It does not work for modem dialups (i.e., ppp*) (at least for Stefan's PCMCIA modem).  The problem seems to be the dialup logic actually destroying ppp*.  Other opinions are welcome. Device bindings always win: If you bind to <samp>*</samp> (or an individual IP address) and to the corresponding device, connections are made with the device binding.  The order of the <code>bind-server!</code> statements do not matter.  This feature is not thoroughly tested.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>backlog (integer)</code></tableterm>
            <item>
              <para>The <code>backlog</code> parameter defines the maximum length the queue of pending connections may grow to.  If a connection request arrives with the queue full the client may receive an error.  This parameter applies to TCP ports only.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>type (integer in the range 0..255)</code></tableterm>
            <item>
              <para>This item applies to ICMP ports only.  It defines the message type identifier used to send ICMP packets (e.g., <samp>8</samp> is an echo message i.e., PING).</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>send-buffer-size (integer)</code></tableterm>
            <item>
              <para>The <code>send-buffer-size</code> configuration item defines the maximum number of bytes the send queue of a client is allowed to grow to.  The item influences the &ldquo;send buffer overrun error condition&rdquo;.  For packet oriented protocols (UDP and ICMP) you need to specify at least the maximum number of bytes a single packets can have.  For UDP and ICMP this is 64 KByte. The value specified here is an initial value.  It is used unless the server bound to this port changes it.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>recv-buffer-size (integer)</code></tableterm>
            <item>
              <para>The <code>recv-buffer-size</code> configuration item defines the maximum number of bytes the receive queue of a client is allowed to grow to. The item influences the &ldquo;receive buffer underrun error condition&rdquo;.  The value specified here is an initial value.  It is used unless the server bound to this port changes it.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>connect-frequency (integer)</code></tableterm>
            <item>
              <para>This item determines the maximum number of connections per second the port will accept.  It is a kind of &ldquo;hammer protection&rdquo;.  The item is evaluated for each remote client machine separately.  It applies to TCP ports.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>allow (list of strings)</code></tableterm>
            <item>
              <para>Both the <code>allow</code> and <code>deny</code> lists are lists of IP addresses in dotted decimal form (e.g., <samp>192.168.2.1</samp>).  The <code>allow</code> list defines the remote machines which are allowed to connect to the port.  It applies to TCP ports.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>deny (list of strings)</code></tableterm>
            <item>
              <para>The <code>deny</code> list defines the remote machines which are not allowed to connect to the port.  Each connection from one of these IP addresses will be refused and shut down immediately.  It applies to TCP ports.</para>
            </item>
          </tableitem>
        </table>
      </subsubsection>

      <subsubsection>
        <title>TCP port definition</title>
        <para>Definition of a TCP port configuration with the name <code>foo-tcp-port</code>.  The enhanced settings are all optional including the <var>ipaddr</var> property which defaults to <samp>*</samp>.  The <var>ipaddr</var> item can contain any form of a dotted decimal internet address, a <samp>*</samp>, <samp>any</samp> or an interface description which you can obtain by running <samp>serveez -i</samp>.</para>
        <example xml:space="preserve">(define-port! 'foo-tcp-port '(
    ;; usual settings
    (proto  . tcp)              ;; protocol is tcp
    (port   . 42421)            ;; network port 42421
    (ipaddr . *)                ;; bind to all known interfaces
    (device . eth0)             ;; bind to network card

    ;; enhanced settings
    (backlog           . 5)     ;; enqueue max. 5 connections
    (connect-frequency . 1)     ;; allow 1 connect per second
    (send-buffer-size  . 1024)  ;; initial send buffer size in bytes
    (recv-buffer-size  . 1024)  ;; initial receive buffer size in bytes

    ;; allow connections from these ip addresses
    (allow             . (127.0.0.1 127.0.0.2))

    ;; refuse connections from this ip address
    (deny              . (192.168.2.7))
  ))</example>
      </subsubsection>

      <subsubsection>
        <title>Pipe port definition</title>
        <para>Definition of a pipe port configuration with the name <code>foo-pipe-port</code>. When bound to a server it creates the receiving end and listens on that. If some client accesses this named pipe the server opens the sending end which the client has to open for reading previously.</para>
        <para>The only mandatory item is the file name of each pipe.  If you want to specify a user creating the named pipe (file ownership) use either the <var>user</var> or the <var>uid</var> setting.  Same goes for the items <var>group</var> and <var>gid</var>.</para>
        <example xml:space="preserve">(define-port! 'foo-pipe-port `(
    (proto . pipe)                   ;; protocol is named pipe

    ;; specify the receiving endpoint
    (recv . ((name . ".foo-recv")    ;; name of the pipe
             (permissions . #o0666)  ;; create it with these permissions
             (user . "calvin")       ;; as user "calvin"
             (uid . 50)              ;; with the user id 50
             (group . "heros")       ;; which is in the group "heros"
             (gid . 100)))           ;; with the group id 100

    ;; specify the sending endpoint
    (send . ((name . ".foo-send")
             (permissions . #o0666)
             (user . "hobbes")
             (uid . 51)
             (group . "stuffed")
             (gid . 101)))
   ))</example>
      </subsubsection>

      <subsubsection>
        <title>ICMP port definition</title>
        <para>Define an ICMP port configuration which will accept connections from the network interface <samp>127.0.0.1</samp> only and communicates via the message type 8 as described in the <xref><xrefnodename>Tunnel Server</xrefnodename></xref> chapter.  The name of this port configuration is <code>foo-icmp-port</code>.  When you are going to bind some server to this kind of port you have to ensure root (or Administrator under Windows) privileges.</para>
        <example xml:space="preserve">(define-port! 'foo-icmp-port '((proto  . icmp)
                               (ipaddr . 127.0.0.1)
                               (type   . 8)))</example>
      </subsubsection>

      <subsubsection>
        <title>UDP port definition</title>
        <para>Simple definition of a UDP port configuration with the name <code>foo-udp-port</code>.</para>
        <example xml:space="preserve">(define-port! 'foo-udp-port `((proto . udp)
                              (port  . 27952)))</example>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Define servers</nodename>
    <nodenext>Bind servers to ports</nodenext>
    <nodeprev>Define ports</nodeprev>
    <nodeup>The config file</nodeup>
    <subsection>
      <title>Define servers</title>
      <para>A <code>server</code> (in Serveez) is a snippet of code that implements some protocol.  There are many servers built into Serveez but you can implement your own, too.  For example we provide a webserver implementing the Hypertext Transfer Protocol (HTTP).  Each server has a different set of options you can change.  You can have many instances of every server, each with a different set of options.  For example: You can create a webserver on TCP port 42420 publishing the Serveez documentation and also have another webserver on a different port publishing something else.  Every server has a unique name you assign to it.  The name of the server is later used to bind it to a port.</para>
      <para>The following example instantiates a server with the short name &ldquo;foo&rdquo;.  Each server in Serveez has got a short name.  See <xref><xrefnodename>Existing servers</xrefnodename></xref>, for the details.  This example demonstrates everything which is possible in server configurations.  You start a definition of a server with the procedure <code>define-server!</code>.  The following argument specifies the name of the server instance (in this case <code>foo-server</code>) which starts with the short name.  The second argument describes the server in detail.  Each configuration item is setup with a <code>(key . value)</code> pair where <var>key</var> is the name of the configuration item and <var>value</var> is the value which depends on the type of the item.  See <xref><xrefnodename>Configuring servers</xrefnodename></xref>, for a detailed description of each type of value.</para>
      <example xml:space="preserve">(define-server! 'foo-server '(
    (bar . 100)                             ;; number
    (reply . "Booo")                        ;; character string
    (messages .                             ;; list of strings
      ("Welcome to the foo test server."
       "This one echos your lines."))
    (ports . (5 6 7 8 9))                   ;; list of numbers
    (port . foo-tcp-port)                   ;; a port configuration
    (assoc . (( "GNU" . "great" )           ;; associative list
              ( "Tree" . "tall" )))
    (truth . #f)                            ;; boolean value
  ))</example>
      <para>Serveez provides a number of server types.  Each of them has a short name. The name of the server instance has to begin with this short name followed by a dash (-).  You can append any suffix then.  In the example above &ldquo;foo&rdquo; is the short name and <code>foo-server</code> the name of the server instance.</para>
    </subsection>
  </node>
  <node>
    <nodename>Bind servers to ports</nodename>
    <nodeprev>Define servers</nodeprev>
    <nodeup>The config file</nodeup>
    <subsection>
      <title>Bind servers to ports</title>
      <para>Finally you can bind servers to ports.  When you do so the server you created listens on the port, accepts connections and serves clients.  It does so as soon as Serveez enters its main loop right after running the configuration file.  Serveez won't stop until you interrupt it (e.g., by pressing <key>^C</key> in the terminal you started it in).</para>
      <para>This example binds the server <code>foo-server</code> (s.a.) to the port <code>foo-tcp-port</code> which was described above.  Therefore you need to call the procedure <code>bind-server!</code> which takes two arguments specifying the name of a port configuration and a server instance.  Both need to be defined before you can write this statement.</para>
      <example xml:space="preserve">(bind-server! 'foo-tcp-port 'foo-server)</example>
      <para>One of the main features of Serveez is that you can bind multiple servers to the same port.  This for example is useful to pass braindead firewall configurations or proxy servers.  It is also possible to bind servers to ports they are actually not designed for.  This might be used for debugging servers or other funny things (again, think about the firewall).  This is the point we have to warn you: Some protocols cannot share the same port (e.g., the tunnel server) and some protocols simply won't work on 'wrong' ports.  Additionally, you will not get error messages when that happens.  The server just will not work then.</para>
    </subsection>

    <subsection>
      <title>Additional configuration possibilities</title>
      <para>The three procedures <code>define-port!</code>, <code>define-server!</code> and <code>bind-server!</code> return <code>#t</code> on success and <code>#f</code> on failure. For your convenience we provide some more built-in procedures, some of which are based upon those above.</para>
<!-- guile-boot.texh - a -*-texinfo-*- fragment for built-in procedures -->
<!-- Copyright (C) 2011, 2012 Thien-Thi Nguyen -->
<!-- This file is provided under the same terms as serveez.texi. -->
      <subsubsection>
        <title>output</title>
        <setvalue name="TSINCURMOD">(guile)</setvalue>
        <definition>
          <definitionterm><indexterm index="cp">println</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>println</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>object</defparam>
            <defparam>&dots;</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Do <code>display</code> on each <var>object</var>. Then, output a newline.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">printsln</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>printsln</deffunction> 
            <defparam>spacer</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>object</defparam>
            <defparam>&dots;</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>For each <var>object</var>, do <code>display</code> on it and on <var>spacer</var>, as well.  Then, output a newline.</para>
          </definitionitem>
        </definition>
      </subsubsection>

      <subsubsection>
        <title>augmenting</title>
        <definition>
          <definitionterm><indexterm index="cp">interface-add!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>interface-add!</deffunction> 
            <defparam>interface</defparam>
          </definitionterm>
          <definitionitem>
            <para>Add <var>interface</var> to the list of known network interfaces. You can get the list of known interfaces by running the shell command <samp>serveez -i</samp>.  The <var>interface</var> argument must be in dotted decimal form (e.g., <samp>127.0.0.1</samp>).  Serveez provides this procedure for systems where it is unable to detect the list of network interface automatically.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">loadpath-add!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>loadpath-add!</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>dir</defparam>
            <defparam>&dots;</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Append <var>dir</var>&dots; to the server modules load path.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">serveez-load</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>serveez-load</deffunction> 
            <defparam>filename</defparam>
          </definitionterm>
          <definitionitem>
            <para>Try to load <var>filename</var> (via <code>primitive-load</code>). If <var>filename</var> is not absolute, search for it in the list of directories returned by <code>serveez-loadpath</code>. Return <code>#t</code> if successful, <code>#f</code> otherwise.</para>
          </definitionitem>
        </definition>
      </subsubsection>

      <subsubsection>
        <title>abstractions</title>
        <definition>
          <definitionterm><indexterm index="cp">bind-servers!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>bind-servers!</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>args</defparam>
            <defparam>&dots;</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Bind all servers and ports in <var>args</var> to each other. This is a cross-product operation; given <var>s</var> servers, and <var>p</var> ports, <code><var>s</var> * <var>p</var></code> bindings will be created.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">create-tcp-port!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>create-tcp-port!</deffunction> 
            <defparam>basename</defparam> 
            <defparam>port</defparam>
          </definitionterm>
          <definitionitem>
            <para>Define a new TCP port named by concatenating <var>basename</var> and <var>port</var>.  Return the new name.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">bind-tcp-port-range!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>bind-tcp-port-range!</deffunction> 
            <defparam>from</defparam> 
            <defparam>to</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>servers</defparam>
            <defparam>&dots;</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Bind the list of <var>servers</var> to simple TCP port configurations whose network ports range between <var>from</var> and <var>to</var> both inclusive.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">create-udp-port!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>create-udp-port!</deffunction> 
            <defparam>basename</defparam> 
            <defparam>port</defparam>
          </definitionterm>
          <definitionitem>
            <para>Define a new UDP port named by concatenating <var>basename</var> and <var>port</var>.  Return the new name.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">bind-udp-port-range!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>bind-udp-port-range!</deffunction> 
            <defparam>from</defparam> 
            <defparam>to</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>servers</defparam>
            <defparam>&dots;</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Bind the list of <var>servers</var> to simple UDP port configurations whose network ports range between <var>from</var> and <var>to</var> both inclusive.</para>
          </definitionitem>
        </definition>
      </subsubsection>

      <subsubsection>
        <title>rpc</title>
        <definition>
          <definitionterm><indexterm index="cp">getrpcent</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>getrpcent</deffunction>
          </definitionterm>
          <definitionitem>
            <para>Return the next RPC entry as a vector of the form: <code>#(<var>name</var> <var>aliases</var> <var>program-number</var>)</code>. <var>name</var> is a symbol, <var>aliases</var> is a list (possibly empty) of symbols, and <var>program-number</var> is an integer. If the list is exhausted, return <code>#f</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">getrpcbyname</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>getrpcbyname</deffunction> 
            <defparam>name</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return the RPC entry for <var>name</var>, a string. (FIXME: Should be able to handle a symbol, too.) If no such service exists, signal error.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">getrpcbynumber</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>getrpcbynumber</deffunction> 
            <defparam>number</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return the RPC entry for <var>number</var>, an integer. If no such service exists, signal error.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">setrpcent</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>setrpcent</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>stayopen</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Open and rewind the file <file>/etc/rpc</file>. If optional arg <var>stayopen</var> (an integer) is non-zero, the database will not be closed after each call to <code>getrpc</code> (or its derivatives <code>getrpcent</code>, <code>getrpcbyname</code>, <code>getrpcbynumber</code>).</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">endrpcent</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>endrpcent</deffunction>
          </definitionterm>
          <definitionitem>
            <para>Close the file <file>/etc/rpc</file>.</para>
          </definitionitem>
        </definition>
      </subsubsection>

      <subsubsection>
        <title>misc</title>
        <definition>
          <definitionterm><indexterm index="cp">serveez-verbosity</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>serveez-verbosity</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>level</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Return the verbosity level (an integer).  Optional arg <var>level</var> means set it to that level, instead.  This setting is overridden by the command-line <samp>-v</samp> option.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">serveez-maxsockets</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>serveez-maxsockets</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>max</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Return the maximum number of open sockets permitted (an integer). Optional arg <var>max</var> means set it to that number, instead. This setting is overridden by the command-line <samp>-m</samp> option.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">serveez-passwd</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>serveez-passwd</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>pw</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Return the control password (a string). Optional arg <var>pw</var> sets it to that, instead.  This effectively does nothing if the control protocol is not enabled.</para>
          </definitionitem>
        </definition>
        <para>We now have a closer look at the internals of Serveez.  If you are not interested in that have a look at the existing servers (See <xref><xrefnodename>Existing servers</xrefnodename></xref>.).</para>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Concept</nodename>
    <nodenext>Server</nodenext>
    <nodeprev>Using Serveez</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Concept</title>
      <section>
        <title>Overall concept</title>
        <para>The primary functionality Serveez provides is a framework for Internet services.  It can act as a kind of server collection and may even replace super-servers such as the inetd daemon.</para>
        <para>Its key features and benefits are:</para>
        <itemize>
          <itemfunction>&bullet;</itemfunction>
          <item>
            <para>support for packet and connection oriented protocols&linebreak; Serveez currently supports two server types.  TCP and named pipe servers are connection oriented servers.  This type of server accepts a client's connection request and communicates with it using a dedicated connection.  The format of the incoming and outgoing data streams are irrelevant to Serveez.  Packet oriented servers (like UDP and ICMP) receive data packets and respond to the sender with data packets.  A server in Serveez can detect whether it is bound to a packet or connection oriented port configuration and thus can act as the expected type.</para>
          </item>
          <item>
            <para>server and client functionality&linebreak; Besides a wide variety of server capabilities, Serveez also contains some client functionality.  This may be necessary when a server is meant to establish a connection to another server in response to an incoming request.  For example, imagine a protocol where a client tells the server, &ldquo;Let me be the server.  Please connect to this <var>host</var> at this <var>port</var>&rdquo;.  You are also able to implement pure clients.</para>
          </item>
          <item>
            <para>platform portability&linebreak; When writing this software the authors were always mindful of platform portability.  Serveez compiles and runs on various Unix platforms as well as on Windows systems.  See <xref><xrefnodename>Porting issues</xrefnodename></xref>, for details.  Most of the routines in the core library can be used without regard to the platform on which you are programming or the details of its underlying system calls.  Exceptions are noted in the documentation.  Platform portability also means that the server code you write will run on other systems, too.</para>
          </item>
          <item>
            <para>powerful configuration capabilities&linebreak; Server configuration has always been a complicated but very important issue.  When Serveez starts up it runs the configuration file using the programming language Guile.  In contradiction, other (server) applications just read their configuration files and remember the settings in it.  This makes them powerful enough to adapt the Serveez settings dynamically.  Using the Guile interpreter also means that you can split your configuration into separate files and load these, perhaps conditionally, from the main configuration file.</para>
          </item>
          <item>
            <para>easy server implementation&linebreak; Serveez is a server framework.  When implementing a new server the programmer need pay little or no attention to the networking code but is free to direct his attention to the protocol the server is meant to support.  That protocol may be an established one such as HTTP, or may be a custom protocol fitting the specific application's requirements. The <xref><xrefnodename>Writing servers</xrefnodename></xref> section describes this process in detail.</para>
          </item>
          <item>
            <para>code reusability&linebreak; The Serveez package comes along with a core library (depending on the system this is a static library, shared library or a DLL) and its API which contains most of the functionality necessary to write an Internet server.  Most probably, a programmer can also use the library for other (network programming related) purposes.</para>
          </item>
          <item>
            <para>server instantiation and network port sharing&linebreak; Once you have written a protocol server and integrated into Serveez's concept of servers the user can instantiate (multiply) the server.  At the first glimpse this sounds silly, but with different server configurations it does not.  If, for example, an administrator wishes to run multiple HTTP servers with different document roots, Serveez will handle them all in a single process.  Also if the same administrator wants to run a HTTP server and some other server on the same network port this is possible with Serveez.  You can run a single server on different network ports, too.</para>
          </item>
        </itemize>
      </section>

      <section>
        <title>I/O Strategy</title>
        <para>Serveez's I/O strategy is the traditional <code>select</code> method.  It is serving many clients in a single server thread.  This is done by setting all network handles to non-blocking mode.  We then use <code>select</code> to tell which network handles have data waiting.  This is the traditional Unix style multiplexing.</para>
        <para>An important bottleneck in this method is that a <code>read</code> or <code>sendfile</code> from disk blocks if the data is not in core at the moment.  Setting non-blocking mode on a disk file handle has no effect. The same thing applies to memory-mapped disk files.  The first time a server needs disk I/O, its process blocks, all clients have to wait, and raw non-threaded performance may go to waste.</para>
        <para>Unfortunately, <code>select</code> is limited to the number of <code>FD_SETSIZE</code> handles.  This limit is compiled into the standard library, user programs and sometimes the kernel.  Nevertheless, Serveez is able to serve about one thousand and more clients on GNU/Linux, a hundred on Win95 and more on later Windows systems.</para>
        <para>We chose this method anyway because it seems to be the most portable.</para>
        <para>An alternative method to multiplex client network connections is <code>poll</code>.  It is automatically used when <samp>configure</samp> finds <code>poll</code> to be available.  This will work around the builtin (g)libc's <code>select</code> file descriptor limit.</para>

        <subsection>
          <title>Limits on open filehandles</title>
          <table>
            <tableitem>
              <tableterm><code>Any Unix</code></tableterm>
              <item>
                <para>The limits set by <code>ulimit</code> or <code>setrlimit</code>.</para>
              </item>
            </tableitem>
            <tableitem>
              <tableterm><code>Solaris</code></tableterm>
              <item>
                <para>See the Solaris FAQ, question 3.45.</para>
              </item>
            </tableitem>
            <tableitem>
              <tableterm><code>FreeBSD</code></tableterm>
              <item>
                <para>Use sysctl -w kern.maxfiles=nnnn to raise limit.</para>
              </item>
            </tableitem>
            <tableitem>
              <tableterm><code>GNU/Linux</code></tableterm>
              <item>
                <para>See Bodo Bauer's /proc documentation.  On current 2.2.x kernels,</para>
                <example xml:space="preserve">echo 32768 &gt; /proc/sys/fs/file-max</example>
                <para>increases the system limit on open files, and</para>
                <example xml:space="preserve">ulimit -n 32768</example>
                <para>increases the current process' limit.  We verified that a process on Linux kernel 2.2.5 (plus patches) can open at least 31000 file descriptors this way.  It has also been verified that a process on 2.2.12 can open at least 90000 file descriptors this way (with appropriate limits).  The upper bound seems to be available memory.</para>
              </item>
            </tableitem>
            <tableitem>
              <tableterm><code>Windows 9x/ME</code></tableterm>
              <item>
                <para>On Win9x machines, there is quite a low limit imposed by the kernel: 100 connections system wide (!).  You can increase this limit by editing the registry key HKLM\System\CurrentControlSet\Services\VxD\MSTCP\MaxConnections. On Windows 95, the key is a DWORD; on Windows 98, it's a string. We have seen some reports of instability when this value is increased to more than a few times its default value.</para>
              </item>
            </tableitem>
            <tableitem>
              <tableterm><code>Windows NT/2000</code></tableterm>
              <item>
                <para>More than 2000 connections tested.  It seems like the limit is due to available physical memory.</para>
              </item>
            </tableitem>
          </table>
        </subsection>
      </section>

      <section>
        <title>Alternatives to Serveez's I/O strategy</title>
        <para>One of the problems with the traditional <code>select</code> method with non-blocking file descriptors occurs when passing a large number of descriptors to the <code>select</code> system call.  The server loop then goes through all the descriptors, decides which has pending data, then reads and handles this data.  For a large number of connections (say, 90000) this results in temporary CPU load peaks even if there is no network traffic.</para>
        <para>Along with this behaviour comes the problem of &ldquo;starving&rdquo; connections. Connections which reside at the beginning of the <code>select</code> set are processed immediately while those at the end are processed significantly later and may possibly die because of buffer overruns.  This is the reason why Serveez features priority connection: it serves listening sockets first and rolls the order of the remaining connections.  In this way, non-priority connections are handled in a &ldquo;round robin&rdquo; fashion.</para>
        <para>Other server implementations solve these problems differently.  Some start a new process for each connection (fully-threaded server) or split the <code>select</code> set into pieces and let different processes handle them (threaded server).  This method shifts the priority scheduling to the underlying operating system.  Another method is the use of asynchronous I/O based upon signals where the server process receives a signal when data arrives for a connection.  The signal handler queues these events in order of arrival and the main server loop continuously processes this queue.</para>
      </section>
    </chapter>
  </node>
  <node>
    <nodename>Server</nodename>
    <nodenext>Coserver</nodenext>
    <nodeprev>Concept</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Server</title>
      <menu>
        <menuentry>
          <menunode>Introduction to servers</menunode>
          <menutitle>Introduction to servers</menutitle>
          <menucomment>Protocol servers in Serveez</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Writing servers</menunode>
          <menutitle>Writing servers</menutitle>
          <menucomment>How to write Internet protocol servers</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Configuring servers</menunode>
          <menutitle>Configuring servers</menutitle>
          <menucomment>How do I configure an existing server ?</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Existing servers</menunode>
          <menutitle>Existing servers</menutitle>
          <menucomment>Which kind of servers do we have already ?</menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Introduction to servers</nodename>
    <nodenext>Writing servers</nodenext>
    <nodeup>Server</nodeup>
    <section>
      <title>Introduction to servers</title>
      <para>Serveez is a kind of server server.  It allows different protocol servers to listen on various TCP/UDP ports, on ICMP sockets and on named pipes.  Servers are instantiated with a certain configuration.  It is possible to run multiple different servers on the same port.</para>
      <para>This chapter covers all questions about how to write your own Internet protocol server with this package.  Most of the common tasks of such a server have got a generic solution (default routines) which could be &ldquo;overridden&rdquo; by your own routines.  There are some examples within this package.  They are showing the possibilities with this package and how to implement servers.</para>
      <para>The <samp>foo</samp> server does not do anything at all and is of no actual use but could be a basis for a new protocol server.  We are now going to describe how this specific server works.  Eventually the reader might get an impression of what is going on.</para>
      <para>For better understanding the text below we will use the following terminology:</para>
      <table>
        <tableitem>
          <tableterm>server definition</tableterm>
          <item>
            <para>A server definition is a <code>svz_servertype_t</code> structure which contains server specific members like its name, different callbacks, a single default configuration and a list of configuration items which determines what can be configured.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>server configuration</tableterm>
          <item>
            <para>A server configuration can be any kind of structure.  The default server configuration must be specified within the server definition (see above). When instantiating a server (which is done via the configuration file) the configuration items specified in the server definition get processed and are put into a copy of the default configuration.  Thus we get an instance.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>server instance</tableterm>
          <item>
            <para>A server instance is a copy of the server definition including the modified server configuration.  A server gets instantiated by the configuration file parser.  The concept of server instances has been introduced because we wanted Serveez to have the following features.  A single server can have multiple instances with different behaviour due to different server configurations.  A server instance can be bound to multiple port configurations.  Different server instances (of the same and/or different server type) can share the same port configuration.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>port configuration</tableterm>
          <item>
            <para>A port configuration in Serveez is represented by the <code>svz_portcfg_t</code> structure.  Depending on a shared flag it contains different type of information specifying a transport endpoint.  See <xref><xrefnodename>Define ports</xrefnodename></xref>, for more on this topic.  It also can be a special configuration item within a server configuration.  This is necessary if a server needs for some reason a remote transport endpoint.  A server instance does not usually need to know about the port configuration it is bound to.</para>
          </item>
        </tableitem>
      </table>
    </section>
  </node>
  <node>
    <nodename>Writing servers</nodename>
    <nodenext>Configuring servers</nodenext>
    <nodeprev>Introduction to servers</nodeprev>
    <nodeup>Server</nodeup>
    <section>
      <title>Writing servers</title>
      <para>Serveez is meant to be a server framework.  That is why it supports various ways to implement Internet servers.  First of all there are some servers already included in the main serveez package (see <xref><xrefnodename>Existing servers</xrefnodename></xref>). These are called <samp>Builtin servers</samp>.  Another possibility to add a new server are <samp>Embedded servers</samp> which are shared libraries (or DLL's) containing the server implementation.  These can be dynamically loaded by Serveez at runtime.  This kind of server is also called <samp>Server modules</samp>. A third possibility are the <samp>Guile servers</samp> which allow even unexperienced schemers to write an Internet server.</para>
      <para>This section describes each of the above possibilities in detail.</para>
      <menu>
        <menuentry>
          <menunode>Embedded servers</menunode>
          <menutitle>Embedded servers</menutitle>
          <menucomment>How to write dynamic server modules</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Guile servers</menunode>
          <menutitle>Guile servers</menutitle>
          <menucomment>Servers using Serveez's guile interface</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Builtin servers</menunode>
          <menutitle>Builtin servers</menutitle>
          <menucomment>Servers located in the main project</menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>Embedded servers</nodename>
    <nodenext>Guile servers</nodenext>
    <nodeup>Writing servers</nodeup>
    <subsection>
      <title>Embedded servers</title>
      <para>The core library of Serveez can be used to write standalone server modules. Serveez defines a certain interface for shared libraries which contain such server modules.  If Serveez detects an unknown server type (server type which is not builtin) in its configuration file it tries to load a shared library containing this server type during startup.</para>

      <subsubsection>
        <title>Prerequisites</title>
        <para>In order to implement a server module you need an existing installation of Serveez.  This can be achieved issuing the following commands:</para>
        <example xml:space="preserve">$ ./configure --enable-shared --prefix=/usr/local
$ make
$ make install</example>
        <para>After successful installation you are able to compile and link against the Serveez core API.  The headers should be available in <file>/usr/local/include</file> and the library itself (<file>libserveez.so</file> or <file>libserveez.dll</file>) is located in <file>/usr/local/lib</file> if you passed the configure script <samp>--prefix=/usr/local</samp>.</para>
      </subsubsection>

      <subsubsection>
        <title>Server definition</title>
        <para>The interface mentioned in the introduction is defined via the extern declaration of the server type in the shared library of the server module. Imagine you want to implement a server type called <samp>foo</samp>.  This requires the external symbol <code>foo_server_definition</code> in the shared library. You can achieve this inserting the following lines into your header file:</para>
        <example xml:space="preserve">/* Either Unices.  */
extern svz_servertype_t foo_server_definition;

/* Or Windows.  */
__declspec (dllexport) extern svz_servertype_t foo_server_definition;</example>
        <para>The data symbol <code>foo_server_definition</code> must be statically filled with the proper content (See <xref><xrefnodename>Builtin servers</xrefnodename></xref>.)</para>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Guile servers</nodename>
    <nodenext>Builtin servers</nodenext>
    <nodeprev>Embedded servers</nodeprev>
    <nodeup>Writing servers</nodeup>
    <subsection>
      <title>Guile servers</title>
<!-- *-texinfo-*- -->
<!-- This file includes the documentation about the Guile servers.  It is -->
<!-- included by `serveez.texi'. -->
      <para>This section describes the Guile interface to Serveez which provides the ability to write servers with Guile.  Of course, you could do this without any help from Serveez, but it makes the task a lot easier. This interface reduces the Guile implementation of an Internet server to a simple data processor.</para>

      <subsubsection>
        <title>Underlying libserveez</title>
        <definition>
          <definitionterm><indexterm index="cp">libserveez-features</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>libserveez-features</deffunction>
          </definitionterm>
          <definitionitem>
            <para>Return a list of symbols representing the features of the underlying libserveez.  For details, See <xref><xrefnodename>Library features</xrefnodename></xref>.</para>
          </definitionitem>
        </definition>
      </subsubsection>

      <subsubsection>
        <title>Special Data Types</title>
        <para>Serveez extends Guile by various new data types which represent internal data structures of Serveez's core API.</para>
        <itemize>
          <itemfunction>&bullet;</itemfunction>
          <item>
            <para><code>#&lt;svz-servertype&gt;</code> represents a server type.</para>
          </item>
          <item>
            <para><code>#&lt;svz-server&gt;</code> represents a server (an instance of a server type).</para>
          </item>
          <item>
            <para><code>#&lt;svz-socket&gt;</code> represents a socket structure.</para>
          </item>
        </itemize>
      </subsubsection>

      <subsubsection>
        <title>Passing Binary Data</title>
        <para>The new binary data type (<code>#&lt;svz-binary&gt;</code>) provides access to any kind of unstructured data.  It manages the data exchange between Guile and Serveez.  There are some conversion procedures for strings and lists which help to process this binary data in a more complex (guile'ish) way.</para>
        <definition>
          <definitionterm><indexterm index="cp">binary-&gt;string</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-&gt;string</deffunction> 
            <defparam>binary</defparam>
          </definitionterm>
          <definitionitem>
            <para>Convert the given binary smob <var>binary</var> into a string. Return the string itself.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">string-&gt;binary</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>string-&gt;binary</deffunction> 
            <defparam>string</defparam>
          </definitionterm>
          <definitionitem>
            <para>Convert the given <var>string</var> into a binary smob.  The data pointer of the binary smob is marked as garbage which must be <code>free</code>'d in the sweep phase of the garbage collector.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary?</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary?</deffunction> 
            <defparam>obj</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return <code>#t</code> if <var>obj</var> is an instance of the binary smob type.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">list-&gt;binary</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>list-&gt;binary</deffunction> 
            <defparam>list</defparam>
          </definitionterm>
          <definitionitem>
            <para>Convert the scheme list <var>list</var> into a binary smob.  Each of the elements of <var>list</var> is checked for validity.  The elements can be either exact numbers in a byte's range or characters.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-&gt;list</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-&gt;list</deffunction> 
            <defparam>binary</defparam>
          </definitionterm>
          <definitionitem>
            <para>Convert the given binary smob <var>binary</var> into a scheme list.  The list is empty if the size of <var>binary</var> is zero.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-search</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-search</deffunction> 
            <defparam>binary</defparam> 
            <defparam>needle</defparam>
          </definitionterm>
          <definitionitem>
            <para>Search through the binary smob <var>binary</var> for <var>needle</var>, which can be an exact number, character, string or another binary smob.  Return <code>#f</code> if the needle could not be found, or a positive number indicating the position of the first occurrence of <var>needle</var> in the binary smob <var>binary</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-set!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-set!</deffunction> 
            <defparam>binary</defparam> 
            <defparam>index</defparam> 
            <defparam>value</defparam>
          </definitionterm>
          <definitionitem>
            <para>Set the byte at position <var>index</var> of the binary smob <var>binary</var> to the value given in <var>value</var> which can be either a character or an exact number.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-ref</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-ref</deffunction> 
            <defparam>binary</defparam> 
            <defparam>index</defparam>
          </definitionterm>
          <definitionitem>
            <para>Obtain the byte at position <var>index</var> of the binary smob <var>binary</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-length</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-length</deffunction> 
            <defparam>binary</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return the size in bytes of the binary smob <var>binary</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-concat!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-concat!</deffunction> 
            <defparam>binary</defparam> 
            <defparam>append</defparam>
          </definitionterm>
          <definitionitem>
            <para>Append either the binary smob or string <var>append</var> onto the binary smob <var>binary</var>.  If <var>binary</var> has been a simple data pointer reference it is then a standalone binary smob as returned by <code>string-&gt;binary</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-subset</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-subset</deffunction> 
            <defparam>binary</defparam> 
            <defparam>start</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>end</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Create a subset binary smob from the given binary smob <var>binary</var>.  The range of this subset is specified by <var>start</var> and <var>end</var> both inclusive (thus the resulting size is <code><var>end</var> - <var>start</var> + 1</code>). With a single exception: If <var>end</var> is not given or specified with -1, return all data until the end of <var>binary</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-reverse</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-reverse</deffunction> 
            <defparam>binary</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return a new binary smob with the reverse byte order of the given binary smob <var>binary</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-reverse!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-reverse!</deffunction> 
            <defparam>binary</defparam>
          </definitionterm>
          <definitionitem>
            <para>Perform an in-place reversal of the given binary smob <var>binary</var> and return it.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-long-ref</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-long-ref</deffunction> 
            <defparam>binary</defparam> 
            <defparam>index</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return the <code>long</code> value of the binary smob <var>binary</var> at the array index <var>index</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-long-set!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-long-set!</deffunction> 
            <defparam>binary</defparam> 
            <defparam>index</defparam> 
            <defparam>value</defparam>
          </definitionterm>
          <definitionitem>
            <para>Set the <code>long</code> value of the binary smob <var>binary</var> at the array index <var>index</var> to the given value <var>value</var>. Return the previous (overridden) value.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-int-ref</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-int-ref</deffunction> 
            <defparam>binary</defparam> 
            <defparam>index</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return the <code>int</code> value of the binary smob <var>binary</var> at the array index <var>index</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-int-set!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-int-set!</deffunction> 
            <defparam>binary</defparam> 
            <defparam>index</defparam> 
            <defparam>value</defparam>
          </definitionterm>
          <definitionitem>
            <para>Set the <code>int</code> value of the binary smob <var>binary</var> at the array index <var>index</var> to the given value <var>value</var>. Return the previous (overridden) value.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-short-ref</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-short-ref</deffunction> 
            <defparam>binary</defparam> 
            <defparam>index</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return the <code>short</code> value of the binary smob <var>binary</var> at the array index <var>index</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-short-set!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-short-set!</deffunction> 
            <defparam>binary</defparam> 
            <defparam>index</defparam> 
            <defparam>value</defparam>
          </definitionterm>
          <definitionitem>
            <para>Set the <code>short</code> value of the binary smob <var>binary</var> at the array index <var>index</var> to the given value <var>value</var>. Return the previous (overridden) value.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-char-ref</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-char-ref</deffunction> 
            <defparam>binary</defparam> 
            <defparam>index</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return the <code>char</code> value of the binary smob <var>binary</var> at the array index <var>index</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">binary-char-set!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>binary-char-set!</deffunction> 
            <defparam>binary</defparam> 
            <defparam>index</defparam> 
            <defparam>value</defparam>
          </definitionterm>
          <definitionitem>
            <para>Set the <code>char</code> value of the binary smob <var>binary</var> at the array index <var>index</var> to the given value <var>value</var>. Return the previous (overridden) value.</para>
          </definitionitem>
        </definition>
      </subsubsection>

      <subsubsection>
        <title>Server Definition</title>
        <para>In order to set up a new server type, you use the procedure <code>define-servertype!</code>.  This procedure takes one argument which must be an associative list specifying the server type in detail. There are optional and mandatory elements you can set up in this alist.</para>
        <para>The following example shows the overall syntax of this procedure:</para>
        <lisp xml:space="preserve">(define-servertype! '(

  ;; Mandatory: server type prefix for later use in (define-server!)
  (prefix          . "foo")

  ;; Mandatory: server type description
  (description     . "guile foo server")

  ;; Mandatory for TCP and PIPE servers: protocol detection
  (detect-proto    . foo-detect-proto)

  ;; Optional: global server type initialisation
  (global-init     . foo-global-init)

  ;; Optional: server instance initialisation
  (init            . foo-init)

  ;; Optional: server instance finalisation
  (finalize        . foo-finalize)

  ;; Optional: global server type finalisation
  (global-finalize . foo-global-finalize)

  ;; Mandatory for TCP and PIPE servers: socket connection
  (connect-socket  . foo-connect-socket)

  ;; Optional: server instance info
  (info-server     . foo-info-server)

  ;; Optional: client info
  (info-client     . foo-info-client)

  ;; Optional: server instance reset callback
  (reset           . foo-reset)

  ;; Optional: server instance notifier
  (notify          . foo-notify)

  ;; Mandatory for UDP and ICMP servers: packet handler
  (handle-request  . foo-handle-request)

  ;; Mandatory: server type configuration (may be an empty list)
  (configuration   . (

    ;; The server configuration is an alist (associative list) again.
    ;; Each item consists of an item name and a list describing the
    ;; item itself.
    ;; Syntax: (key . (type defaultable default))
    (foo-integer       . (integer  #t 0))
    (foo-integer-array . (intarray #t (1 2 3 4 5)))
    (foo-string        . (string   #t "default-foo-string"))
    (foo-string-array  . (strarray #t ("guile" "foo" "server")))
    (foo-hash          . (hash     #t (("foo" . "bar"))))
    (foo-port          . (portcfg  #t foo-port))
    (foo-boolean       . (boolean  #t #t))
  ))))</lisp>
        <definition>
          <definitionterm><indexterm index="cp">define-servertype!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>define-servertype!</deffunction> 
            <defparam>args</defparam>
          </definitionterm>
          <definitionitem>
            <para>Define a new server type based on <var>args</var>.  (If everything works fine you have a freshly registered server type afterwards.) Return <code>#t</code> on success.</para>
          </definitionitem>
        </definition>
      </subsubsection>

      <subsubsection>
        <title>Predefined Procedures</title>
        <para>The following subset of procedures may be used to implement a Guile server.  They should be used within the callbacks defined in the <code>define-servertype!</code> procedure.  Each of these callbacks gets passed the appropriate arguments needed to stuff into the following procedures.  Please have a look at the example Guile servers for the details.</para>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock?</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock?</deffunction> 
            <defparam>sock</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return <code>#t</code> if the given cell <var>sock</var> is an instance of a valid <code>#&lt;svz-socket&gt;</code>, otherwise <code>#f</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:check-request</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:check-request</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>proc</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Set the <code>check-request</code> member of the socket structure <var>sock</var> to <var>proc</var>.  Return the previously handler if there is any.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:check-oob-request</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:check-oob-request</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>proc</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Set the <code>check-oob-request</code> callback of the given socket structure <var>sock</var> to <var>proc</var>, returning the previous callback (if there was any set before). The callback is run whenever urgent data (out-of-band) has been detected on the socket.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:send-oob</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:send-oob</deffunction> 
            <defparam>sock</defparam> 
            <defparam>oob</defparam>
          </definitionterm>
          <definitionitem>
            <para>Send byte <var>oob</var> as urgent (out-of-band) data through the underlying TCP stream of TCP <var>sock</var>. Return <code>#t</code> on successful completion and otherwise (either it failed to send the byte or the passed socket is not a TCP socket) <code>#f</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:handle-request</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:handle-request</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>proc</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Set the <code>handle-request</code> member of the socket structure <var>sock</var> to <var>proc</var>.  Return the previously set handler if there is any.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:boundary</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:boundary</deffunction> 
            <defparam>sock</defparam> 
            <defparam>boundary</defparam>
          </definitionterm>
          <definitionitem>
            <para>Setup the packet boundary of the socket <var>sock</var>.  The given string value <var>boundary</var> can contain any kind of data.  If <var>boundary</var> is an exact number, set up the socket to parse fixed sized packets. More precisely, set the <code>check-request</code> callback of the given socket structure <var>sock</var> to an internal routine which runs the socket's <code>handle-request</code> callback when it detects a complete packet specified by <var>boundary</var>.</para>
            <para>For instance, you can arrange for Serveez to pass the <code>handle-request</code> procedure lines of text by calling <code>(svz:sock:boundary sock "\n")</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:floodprotect</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:floodprotect</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>flag</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Set or unset the flood protection bit of the given socket <var>sock</var>. Return the previous value of this bit (<code>#t</code> or <code>#f</code>).  The <var>flag</var> argument must be either boolean or an exact number and is optional.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:print</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:print</deffunction> 
            <defparam>sock</defparam> 
            <defparam>buffer</defparam>
          </definitionterm>
          <definitionitem>
            <para>Write <var>buffer</var> (string or binary smob) to the socket <var>sock</var>. Return <code>#t</code> on success and <code>#f</code> on failure.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:final-print</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:final-print</deffunction> 
            <defparam>sock</defparam>
          </definitionterm>
          <definitionitem>
            <para>Schedule the socket <var>sock</var> for shutdown after all data within the send buffer queue has been sent.  You should call this right <strong>before</strong> the last call to <code>svz:sock:print</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:no-delay</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:no-delay</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>enable</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Turn the Nagle algorithm for the TCP socket <var>sock</var> on or off depending on the optional <var>enable</var> argument.  Return the previous state of this flag (<code>#f</code> if Nagle is active, <code>#t</code> otherwise).  By default this flag is switched off.  This socket option is useful when dealing with small packet transfer in order to disable unnecessary delays.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:send-buffer</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:send-buffer</deffunction> 
            <defparam>sock</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return the send buffer of the socket <var>sock</var> as a binary smob.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:send-buffer-size</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:send-buffer-size</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>size</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Return the current send buffer size and fill status in bytes of the socket <var>sock</var> as a pair of exact numbers.  If the optional argument <var>size</var> is given, set the send buffer to the specified size in bytes.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:receive-buffer</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:receive-buffer</deffunction> 
            <defparam>sock</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return the receive buffer of the socket <var>sock</var> as a binary smob.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:receive-buffer-size</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:receive-buffer-size</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>size</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Return the current receive buffers size and fill status in bytes of the socket <var>sock</var> as a pair of exact numbers.  If the optional argument <var>size</var> is given, set the receive buffer to the specified size in bytes.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:receive-buffer-reduce</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:receive-buffer-reduce</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>length</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Dequeue <var>length</var> bytes from the receive buffer of the socket <var>sock</var>, or all bytes if <var>length</var> is omitted. Return the number of bytes actually shuffled away.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:connect</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:connect</deffunction> 
            <defparam>host</defparam> 
            <defparam>proto</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>port</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Establish a network connection to the given <var>host</var> [ :<var>port</var> ]. If <var>proto</var> equals <code>PROTO_ICMP</code> the <var>port</var> argument is ignored.  Valid identifiers for <var>proto</var> are <code>PROTO_TCP</code>, <code>PROTO_UDP</code> and <code>PROTO_ICMP</code>.  The <var>host</var> argument must be either a string in dotted decimal form, a valid hostname or an exact number in host byte order.  When giving a hostname this operation might block. The <var>port</var> argument must be an exact number in the range from 0 to 65535, also in host byte order.  Return a valid <code>#&lt;svz-socket&gt;</code> or <code>#f</code> on failure.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:disconnected</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:disconnected</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>proc</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Set the <code>disconnected-socket</code> member of the socket structure <var>sock</var> to <var>proc</var>.  The given callback runs whenever the socket is lost for some external reason. Return the previously set handler if there is one.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:kicked</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:kicked</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>proc</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Set the <code>kicked-socket</code> callback of the given socket structure <var>sock</var> to <var>proc</var> and return any previously set procedure.  This callback gets called whenever the socket gets closed by Serveez intentionally.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:trigger</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:trigger</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>proc</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Set the <code>trigger</code> callback of the socket structure <var>sock</var> to <var>proc</var> and return any previously set procedure. The callback is run when the <code>trigger-condition</code> callback returns <code>#t</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:trigger-condition</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:trigger-condition</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>proc</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Set the <code>trigger-condition</code> callback for the socket structure <var>sock</var> to <var>proc</var>.  Return the previously set procedure if available.  The callback is run once every server loop indicating whether the <code>trigger</code> callback should be run or not.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:idle</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:idle</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>proc</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Set the <code>idle</code> callback of the socket structure <var>sock</var> to <var>proc</var>.  Return any previously set procedure.  The callback is run by the periodic task scheduler when the <code>idle-counter</code> of the socket structure drops to zero.  If this counter is not zero it gets decremented once a second.  The <code>idle</code> callback can reset <code>idle-counter</code> to some value and thus can re-schedule itself for a later task.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:idle-counter</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:idle-counter</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>counter</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Return the socket structure <var>sock</var>'s current <code>idle-counter</code> value.  If the optional argument <var>counter</var> is given, the set the <code>idle-counter</code>.  Please have a look at the <code>svz:sock:idle</code> procedure for the exact meaning of this value.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:data</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:data</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>data</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Associate any kind of data (any object) given in the argument <var>data</var> with the socket <var>sock</var>.  The <var>data</var> argument is optional.  Return a previously stored value or an empty list. [Do not use; will be deleted; use object properties, instead.  &ndash;ttn]</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:parent</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:parent</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>parent</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Return the given socket's <var>sock</var> parent and optionally set it to the socket <var>parent</var>.  Return either a valid <code>#&lt;svz-socket&gt;</code> object or an empty list.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:referrer</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:referrer</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>referrer</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Return the given socket's <var>sock</var> referrer and optionally set it to the socket <var>referrer</var>.  Return either a valid <code>#&lt;svz-socket&gt;</code> or an empty list.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:server</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:server</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>server</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Return the <code>#&lt;svz-server&gt;</code> object associated with the given argument <var>sock</var>.  The optional argument <var>server</var> can be used to redefine this association and must be a valid <code>#&lt;svz-server&gt;</code> object.  For a usual socket callback like <code>connect-socket</code> or <code>handle-request</code>, the association is already in place.  But for sockets created by <code>svz:sock:connect</code>, you can use it in order to make the returned socket object part of a server.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:local-address</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:local-address</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>address</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Return the current local address as a pair like <code>(host . port)</code> with both entries in network byte order.  If you pass the optional argument <var>address</var>, you can set the local address of the socket <var>sock</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:remote-address</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:remote-address</deffunction> 
            <defparam>sock</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>address</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Return the current remote address as a pair like <code>(host . port)</code> with both entries in network byte order.  If you pass the optional argument <var>address</var>, you can set the remote address of the socket <var>sock</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:find</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:find</deffunction> 
            <defparam>ident</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return the <code>#&lt;svz-socket&gt;</code> specified by <var>ident</var>, a pair of integers in the form <code>(identification . version)</code>. If that socket no longer exists, return <code>#f</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:ident</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:ident</deffunction> 
            <defparam>sock</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return a pair of numbers identifying the given <code>#&lt;svz-socket&gt;</code> <var>sock</var>, which can be passed to <code>svz:sock:find</code>.  This may be necessary when you are passing a <code>#&lt;svz-socket&gt;</code> through coserver callback arguments in order to verify that the passed <code>#&lt;svz-socket&gt;</code> is still valid when the coserver callback runs.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:sock:protocol</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:sock:protocol</deffunction> 
            <defparam>sock</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return one of the <code>PROTO_TCP</code>, <code>PROTO_UDP</code>, <code>PROTO_ICMP</code>, <code>PROTO_RAW</code> or <code>PROTO_PIPE</code> constants indicating the type of the socket structure <var>sock</var>.  If there is no protocol information available, return <code>#f</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:read-file</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:read-file</deffunction> 
            <defparam>port</defparam> 
            <defparam>size</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return either a binary smob containing a data block read from the open input port <var>port</var> with a maximum number of <var>size</var> bytes, or the end-of-file object if the underlying ports end has been reached.  The size of the returned binary smob may be less than the requested size <var>size</var> if it exceed the current size of the given port <var>port</var>.  Throw an exception if an error occurred while reading from the port.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:server?</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:server?</deffunction> 
            <defparam>server</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return <code>#t</code> if the given cell <var>server</var> is an instance of a valid <code>#&lt;svz-server&gt;</code>, otherwise <code>#f</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:server:listeners</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:server:listeners</deffunction> 
            <defparam>server</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return a list of listening <code>#&lt;svz-socket&gt;</code> smobs to which the given server instance <var>server</var> is currently bound, or an empty list if there is no such binding yet.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:server:clients</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:server:clients</deffunction> 
            <defparam>server</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return a list of <code>#&lt;svz-socket&gt;</code> client smobs associated with the given server instance <var>server</var> in arbitrary order, or an empty list if there is no such client.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:server:config-ref</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:server:config-ref</deffunction> 
            <defparam>server</defparam> 
            <defparam>key</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return the configuration item specified by <var>key</var> of the given server instance <var>server</var>.  You can pass this procedure a socket, too, in which case the appropriate server instance is looked up.  If the given string <var>key</var> is invalid (not defined in the configuration alist in <code>define-servertype!</code>), then return an empty list.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:server:state-set!</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:server:state-set!</deffunction> 
            <defparam>server</defparam> 
            <defparam>key</defparam> 
            <defparam>value</defparam>
          </definitionterm>
          <definitionitem>
            <para>Associate the Guile object <var>value</var> with the string <var>key</var>.  The given <var>server</var> argument can be both, a <code>#&lt;svz-server&gt;</code> or a <code>#&lt;svz-socket&gt;</code>.  Return the previously associated object or an empty list if there was no such association.  This procedure is useful for server instance state savings.  [Actually, it is superfluous since Guile provides object properties and closures.  Probably this procedure will be deleted soon. &mdash;ttn]</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:server:state-ref</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:server:state-ref</deffunction> 
            <defparam>server</defparam> 
            <defparam>key</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return the Guile object associated with the string value <var>key</var> which needs to be have been set via <code>svz:server:state-set!</code> previously. Otherwise return an empty list.  The given <var>server</var> argument must be either a valid <code>#&lt;svz-server&gt;</code> object or a <code>#&lt;svz-socket&gt;</code>. [NB: See comment in <code>svz:server:state-set!</code>. &mdash;ttn]</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:server:state-&gt;hash</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:server:state-&gt;hash</deffunction> 
            <defparam>server</defparam>
          </definitionterm>
          <definitionitem>
            <para>Convert the <var>server</var> instance's state into a Guile hash. Return an empty list if there is no such state yet.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">serveez-port?</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>serveez-port?</deffunction> 
            <defparam>name</defparam>
          </definitionterm>
          <definitionitem>
            <para>Return <code>#t</code> if the given string <var>name</var> corresponds with a registered port configuration, otherwise <code>#f</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">serveez-server?</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>serveez-server?</deffunction> 
            <defparam>name</defparam>
          </definitionterm>
          <definitionitem>
            <para>Check whether the given string <var>name</var> corresponds with an instantiated server name and return <code>#t</code> if so.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">serveez-servertype?</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>serveez-servertype?</deffunction> 
            <defparam>name</defparam>
          </definitionterm>
          <definitionitem>
            <para>Check whether the given string <var>name</var> is a valid server type prefix known in Serveez and return <code>#t</code> if so. Otherwise return <code>#f</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">serveez-exceptions</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>serveez-exceptions</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>enable</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Control the use of exception handlers for the Guile procedure calls of Guile server callbacks.  If the optional argument <var>enable</var> is <code>#t</code>, enable exception handling; if <code>#f</code>, disable it. Return the current (boolean) setting.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">serveez-nuke</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>serveez-nuke</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>exit-value</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Shutdown all network connections and terminate after the next event loop.  You should use this instead of calling <code>quit</code>. Optional arg <var>exit-value</var> specifies an exit value for the serveez program.  It is mapped to a number via <code>scm_exit_value</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">serveez-loadpath</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>serveez-loadpath</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>args</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Make the search path for the Serveez core library accessible to Scheme. Return a list a each path as previously defined.  If <var>args</var> is specified, override the current definition of this load path with it. The load path is used to tell Serveez where it can find additional server modules.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">serveez-interfaces</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>serveez-interfaces</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>args</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Make the list of local interfaces accessible to Scheme.  Return the local interfaces as a list of ip addresses in dotted decimal form.  If <var>args</var> are specified, they are added as additional local interfaces.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">getrpc</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>getrpc</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>arg</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Lookup a network rpc service <var>arg</var> (name or service number), and return a network rpc service object. If given no arguments, it behave like <code>getrpcent</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">setrpc</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>setrpc</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>stayopen</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Open and rewind the file <file>/etc/rpc</file>. If the <var>stayopen</var> flag is non-zero, the net data base will not be closed after each call to <code>getrpc</code>.  If <var>stayopen</var> is omitted, this is equivalent to calling <code>endrpcent</code>.  Otherwise it is equivalent to calling <code>setrpcent</code> with arg 1.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">portmap</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>portmap</deffunction> 
            <defparam>prognum</defparam> 
            <defparam>versnum</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>protocol</defparam> 
            <defdelimiter>[</defdelimiter>
            <defparam>port</defparam>
            <defdelimiter>]</defdelimiter>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Establish a (portmap service) mapping between the triple [<var>prognum</var>,<var>versnum</var>,<var>protocol</var>] and <var>port</var> on the machine's portmap service.  The value of <var>protocol</var> is most likely <code>IPPROTO_UDP</code> or <code>IPPROTO_TCP</code>. If instead <var>protocol</var> and <var>port</var> are omitted, destroy all mapping between the triple [<var>prognum</var>,<var>versnum</var>,*] and ports on the machine's portmap service.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">portmap-list</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>portmap-list</deffunction> 
            <defdelimiter>[</defdelimiter>
            <defparam>address</defparam>
            <defdelimiter>]</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Return a list of the current RPC program-to-port mappings on the host located at IP address <var>address</var>, which defaults to the local machine's IP address. Return an empty list if either there is no such list available or an error occurred while fetching the list.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:coserver:dns</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:coserver:dns</deffunction> 
            <defparam>host</defparam> 
            <defparam>callback</defparam>
          </definitionterm>
          <definitionitem>
            <para>Enqueue the <var>host</var> string argument into the internal DNS coserver queue.  When the coserver responds, the procedure <var>callback</var> is run as <code>(callback addr)</code>.  The <var>addr</var> argument passed to the callback is a string representing the appropriate IP address for the given hostname <var>host</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:coserver:reverse-dns</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:coserver:reverse-dns</deffunction> 
            <defparam>addr</defparam> 
            <defparam>callback</defparam>
          </definitionterm>
          <definitionitem>
            <para>Enqueue the given <var>addr</var> argument, which must be an IP address in network byte order, into the internal reverse DNS coserver queue.  When the coserver responds, the procedure <var>callback</var> is run as <code>(callback host)</code> where <var>host</var> is the hostname of the requested IP address <var>addr</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">svz:coserver:ident</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>svz:coserver:ident</deffunction> 
            <defparam>sock</defparam> 
            <defparam>callback</defparam>
          </definitionterm>
          <definitionitem>
            <para>Enqueue the given <code>#&lt;svz-socket&gt;</code> <var>sock</var> into the internal ident coserver queue.  When the coserver responds, it runs the procedure <var>callback</var> as <code>(callback user)</code>, where <var>user</var> is the corresponding username for the client connection <var>sock</var>.</para>
          </definitionitem>
        </definition>
      </subsubsection>

      <subsubsection>
        <title>Callback Prototypes</title>
        <para>The Guile interface of Serveez is completely callback driven. Callbacks can be set up in the associative list passed to <code>define-servertype!</code>, or by using the predefined procedures described in the previous section.  Each of the callbacks is passed certain arguments and is meant to return specific values to indicate success or failure.  This section describes each of these callbacks.</para>
        <definition>
          <definitionterm><indexterm index="cp">global-init</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>global-init</deffunction> 
            <defparam>servertype</defparam>
          </definitionterm>
          <definitionitem>
            <para>This callback is invoked once for every type of server right after the <code>define-servertype!</code> statement.  Here you can initialise resources shared between all instances of your server type.  The callback is optional and can be set up in <code>define-servertype!</code>.  It should return zero to indicate success and non-zero to indicate failure.  If the global initialiser fails, Serveez will refuse to register the server type.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">global-finalize</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>global-finalize</deffunction> 
            <defparam>servertype</defparam>
          </definitionterm>
          <definitionitem>
            <para>If you want to free shared resources, which were possibly allocated within the global initialiser, you can do so here.  The callback is invoked when Serveez shuts down (issued by <code>serveez-nuke</code>) or the server type gets unregistered for some reason.  It should return zero to signal success.  The callback can be set up in <code>define-servertype!</code> and is optional.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">init</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>init</deffunction> 
            <defparam>server</defparam>
          </definitionterm>
          <definitionitem>
            <para>Within this callback you can initialise everything you might need for a single instance of your server.  The callback is invoked for each server instance which has been created by <code>define-server!</code> and should return zero to indicate success, otherwise Serveez rejects the server instance.  The callback can be set up in <code>define-servertype!</code> and is optional.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">finalize</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>finalize</deffunction> 
            <defparam>server</defparam>
          </definitionterm>
          <definitionitem>
            <para>The server instance finaliser gets its instance representation passed as argument.  You need to free all resources used by this server instance which might have been allocated within the server instance initialiser or consumed while running.  You can set this callback in the <code>define-servertype!</code> statement.  The callback is optional and should return zero to indicate success.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">detect-proto</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>detect-proto</deffunction> 
            <defparam>server</defparam> 
            <defparam>socket</defparam>
          </definitionterm>
          <definitionitem>
            <para>Connection oriented protocols like TCP and PIPE allow more than one server to be listening on the same network port.  Therefore, it is necessary to be able to detect the type of client connecting to a port.</para>
            <para>This callback takes two arguments; the first is the server instance and the second is the client socket object containing the client connection information.  You can set up this callback in the <code>define-servertype!</code> statement.</para>
            <para>Serveez may invoke this callback several times as data becomes available from the client until one of the servers recognises it. The servers can retrieve the data received so far using the <code>svz:sock:receive-buffer</code> call.</para>
            <para>To indicate successful client detection, you need to return a non-zero value.  (Note that for historical reasons, this is inconsistent with other procedures which return zero on successful completion.)  Once the server has indicated success, Serveez invokes any further callbacks for the connection only on that server.</para>
            <para>If no server has recognised the client after the first 16 bytes, Serveez will close the connection.  The connection will also be closed if the client has not sent enough data for a server to recognise it within 30 seconds of connecting.</para>
            <para>If multiple servers are listening on the same network port, Serveez invokes this callback for each of them in an arbitrary order.  Only one server at most should indicate successful detection.</para>
            <para>This callback is mandatory for servers which get bound to connection oriented protocol (TCP and PIPE) port configurations by <code>bind-server!</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">connect-socket</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>connect-socket</deffunction> 
            <defparam>server</defparam> 
            <defparam>socket</defparam>
          </definitionterm>
          <definitionitem>
            <para>If the client detection signalled success, this callback is invoked to assign the client connection to a server instance.  The arguments are the same as the detection callback.  In this callback you can assign all the connection specific callbacks for your server and perform some initial tasks.  Basically you should specify the <code>handle-request</code> and/or <code>check-request</code> callback.  This can be achieved by calling <code>svz:sock:handle-request</code> and <code>svz:sock:check-request</code>. The <code>connect-socket</code> callback is also mandatory for connection oriented protocols and must be defined in <code>define-servertype!</code>. On success you should return zero, otherwise the connection will be shutdown by Serveez.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">info-server</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>info-server</deffunction> 
            <defparam>server</defparam>
          </definitionterm>
          <definitionitem>
            <para>This callback gets invoked when requested by the builtin <xref><xrefnodename>Control Protocol Server</xrefnodename></xref>.  The callback is optional and can be set up in <code>define-servertype!</code>.  The returned character string can be multiple lines separated by <code>\r\n</code> (but without a trailing separator).  Usually you will return information about the server instance configuration and/or state.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">info-client</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>info-client</deffunction> 
            <defparam>server</defparam> 
            <defparam>socket</defparam>
          </definitionterm>
          <definitionitem>
            <para>This callback is optional.  You can set it up in the <code>define-servertype!</code> procedure.  It is meant to provide socket structure specific information.  (The socket structure is a client/child of the given server instance.)  You need to return a single line character string without trailing newlines.  The information provided can be requested by the builtin <xref><xrefnodename>Control Protocol Server</xrefnodename></xref>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">notify</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>notify</deffunction> 
            <defparam>server</defparam>
          </definitionterm>
          <definitionitem>
            <para>The server instance notifier callback will be invoked whenever there is idle time available.  In practice, it is run approximately once a second. A server instance can use it to perform periodic tasks.  The callback is optional and can be set up in <code>define-servertype!</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">reset</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>reset</deffunction> 
            <defparam>server</defparam>
          </definitionterm>
          <definitionitem>
            <para>This callback is invoked when the Serveez process receives a <code>SIGHUP</code> signal which can be issued via <samp>killall -HUP serveez</samp> from user land.  If the underlying operating system does not provide <code>SIGHUP</code> there is no use for this callback.  It provides the possibility to perform asynchronous tasks scheduled from outside Serveez.  You can optionally set it up in the <code>define-servertype!</code> procedure.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">handle-request</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>handle-request</deffunction> 
            <defparam>socket</defparam> 
            <defparam>binary</defparam> 
            <defparam>size</defparam>
          </definitionterm>
          <definitionitem>
            <para>This callback is invoked whenever a complete packet has been detected in the receive buffer.  The packet data is passed to the callback as a <code>#&lt;svz-binary&gt;</code>.  The <var>size</var> argument is passed for convenience and specifies the length of the packet in bytes.</para>
            <para>The detection, and therefore the invocation, can be made in one of two ways.  When Serveez can determine itself when a packet is complete, the callback will be invoked directly.  Serveez can make this determination for connections with packet oriented protocols such as UDP and ICMP, or if you tell Serveez how to parse the packet using <code>svz:sock:boundary sock delimiter</code> or <code>svz:sock:boundary sock size</code> and do not specify a <code>check-request</code> callback.</para>
            <para>Whenever you specify a <code>check-request</code> callback to determine when a packet is complete, it becomes the responsiblity of that callback to invoke <code>handle-request</code> itself.</para>
            <para>Serveez recognises two different return value meanings.  For connection oriented protocols (TCP and PIPE), zero indicates success and non-zero failure; on failure, Serveez will shutdown the connection.  For packet oriented protocols (UDP and ICMP), a non-zero return value indicates that your server was able to process the passed packet data, otherwise (zero return value) the packet can be passed to other servers listening on the same port configuration.</para>
            <para>This callback must be specified in <code>define-servertype!</code> for packet oriented protocols (UDP and ICMP) but is optional otherwise. You can modify the callback by calling <code>svz:sock:handle-request</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">check-request</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>check-request</deffunction> 
            <defparam>socket</defparam>
          </definitionterm>
          <definitionitem>
            <para>This callback is invoked whenever new data has arrived in the receive buffer. The receive buffer of the given <code>#&lt;svz-socket&gt;</code> can be obtained using <code>svz:sock:receive-buffer</code>.  The callback is initially not set and can be set up with <code>svz:sock:check-request</code>.  Its purpose is to check whether a complete request was received.  If so, it should be handled (by running the <code>handle-request</code> callback) and removed from the receive buffer (using <code>svz:sock:receive-buffer-reduce</code>). The callback is for connection oriented protocols (TCP and PIPE) only. You should return zero to indicate success and non-zero to indicate failure.  On failure Serveez shuts the connection down.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">disconnected</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>disconnected</deffunction> 
            <defparam>socket</defparam>
          </definitionterm>
          <definitionitem>
            <para>The <code>disconnected</code> callback gets invoked whenever the socket is lost for some external reason and is going to be shutdown by Serveez. It can be set up with <code>svz:sock:disconnected</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">kicked</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>kicked</deffunction> 
            <defparam>socket</defparam> 
            <defparam>reason</defparam>
          </definitionterm>
          <definitionitem>
            <para>This callback gets invoked whenever the socket gets closed by Serveez intentionally.  It can be set up with <code>svz:sock:kicked</code>.  The <var>reason</var> argument can be either <code>KICK_FLOOD</code>, indicating the socket is a victim of the builtin flood protection, or <code>KICK_QUEUE</code> which indicates a send buffer overflow.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">idle</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>idle</deffunction> 
            <defparam>socket</defparam>
          </definitionterm>
          <definitionitem>
            <para>The <code>idle</code> callback gets invoked from the periodic task scheduler, which maintains a <code>idle-counter</code> for each socket structure. This counter is decremented whenever Serveez becomes idle and the callback is invoked when it drops to zero.  The <code>idle</code> callback can set its socket's <code>idle-counter</code> to some value with the procedure <code>svz:sock:idle-counter</code> and thus re-schedule itself for a later task.  You can set up this callback with <code>svz:sock:idle</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">trigger-condition</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>trigger-condition</deffunction> 
            <defparam>socket</defparam>
          </definitionterm>
          <definitionitem>
            <para>This callback is invoked once every server loop for the socket structure. If you return <code>#f</code> nothing else is happening.  Otherwise the <code>trigger</code> callback will be invoked immediately.  You can set up the callback using the procedure <code>svz:sock:trigger-condition</code>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">trigger</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>trigger</deffunction> 
            <defparam>socket</defparam>
          </definitionterm>
          <definitionitem>
            <para>The <code>trigger</code> callback is invoked when the <code>trigger-condition</code> returns <code>#t</code>.  The callback can be set up with the procedure <code>svz:sock:trigger</code>.  Returning a non-zero value shuts the connection down.  A zero return value indicates success.  This callback can be used to perform connection related updates, e.g., you can ensure a certain send buffer fill.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">check-oob-request</indexterm>
            <defcategory>Scheme Procedure</defcategory> 
            <deffunction>check-oob-request</deffunction> 
            <defparam>socket</defparam> 
            <defparam>oob-byte</defparam>
          </definitionterm>
          <definitionitem>
            <para>This callback is invoked whenever urgent data (out-of-band) has been detected on a socket.  Initially this event is ignored and the callback can be set up with the procedure <code>svz:sock:check-oob-request</code>.  The <var>oob-byte</var> argument is a number containing the received out-of-band data byte ranging from 0 to 255.  If the callback returns non-zero the connection will be shutdown.  A zero return value indicates success.  You can use <code>svz:sock:send-oob</code> to send a single out-of-band data byte.</para>
            <para><strong>Please note</strong>: The urgent data is not supported by all operating systems.  Also it does not work for all types of network protocols.  We verified it to be working for TCP streams on GNU/Linux 2.x.x and Windows 95; let us know if/how it works on other platforms.</para>
          </definitionitem>
        </definition>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Builtin servers</nodename>
    <nodeprev>Guile servers</nodeprev>
    <nodeup>Writing servers</nodeup>
    <subsection>
      <title>Builtin servers</title>
      <para>All of the servers listed in <xref><xrefnodename>Existing servers</xrefnodename></xref> are builtin servers. The following sections describe in detail how to setup a new builtin server type.  This kind of server will be part of the Serveez executable.  That is why you should make it configurable in the configure script via a <samp>--enable-xxxserver</samp> argument.</para>

      <subsubsection>
        <title>Making and configuring preparations</title>
        <para>Serveez is configured and built via automake and autoconf.  That is why you are not supposed to write your own Makefiles but simplified <file>Makefile.am</file>s.  Automake will automatically generate dependencies and compiler/linker command lines.  Here are the steps you basically need to follow:</para>
        <itemize>
          <itemfunction>&bullet;</itemfunction>
          <item>
            <para>Change to the <file>src/</file> directory in the source tree.</para>
          </item>
          <item>
            <para>Edit the <file>Makefile.am</file>.  Add your sub directory name and library name which you are going to create.</para>
          </item>
          <item>
            <para>Now create the sub directory and change into it.</para>
          </item>
          <item>
            <para>You need to create a new <file>Makefile.am</file> therein.  If you want to have this file <file>configure</file>d you need to add a further line to the <code>AC_OUTPUT</code> statement in <file>configure.ac</file> which is in the top level directory.  You have to put at least the following into the newly created <file>Makefile.am</file>:</para>
            <example xml:space="preserve">noinst_LIBRARIES = libfoo.a
libfoo_a_SOURCES = foo-proto.h foo-proto.c
INCLUDES = $(SERVEEZ_CFLAGS) -I$(top_srcdir)/src
CLEANFILES = *~
MAINTAINERCLEANFILES = Makefile.in</example>
          </item>
          <item>
            <para>Just have a look at all the other server directories.  For more information about automake read the info pages.</para>
          </item>
        </itemize>
      </subsubsection>

      <subsubsection>
        <title>Server header file <file>foo-proto.h</file></title>
        <para>This file contains at least your server's <code>extern</code> declaration of your server definition which must be available from the outside. The <code>foo</code> server implements all kinds of configuration items which can be integers, integer arrays, strings, string arrays, port configurations, booleans and hash maps.  Every item of the server configuration can later be manipulated from the configuration file.</para>
      </subsubsection>

      <subsubsection>
        <title>Server implementation file <file>foo-proto.c</file></title>
        <para>If you want to define default values for your configuration you have to define them somewhere and put them into the default configuration structure.  This structure will be used to instantiate your server.  For this example we simply called it simply <code>foo_config</code>.</para>
        <para>In order to associate the configuration items in a server configuration to keywords within the configuration file you have to define an array of key-value-pairs.  This is done in the <code>foo_config_prototype</code> field.  There are several macros which make different associations.  These are the <code>SVZ_REGISTER_*</code> macros which take three arguments.  The first argument is the keyword which will occur in the configuration file, the second is the associated item in your default configuration structure and the last argument specifies if this item is defaultable or not.</para>
      </subsubsection>

      <subsubsection>
        <title>Server definition</title>
        <para>The server definition is in a way the <samp>class</samp> of your server.  Together with the default values (<code>foo_config_prototype</code>) it serves as a template for newly instantiated servers.  The structure contains a long and a short description of your server.  The short name is used as the prefix for all server instances of this specific type.  The long description is used in the control protocol (See <xref><xrefnodename>Control Protocol Server</xrefnodename></xref>.).  The server definition also contains the callbacks your server (mandatorily) provides.</para>
      </subsubsection>

      <subsubsection>
        <title>Server callbacks</title>
        <para>There are several callback routines, which get called in order to instantiate the server and for describing the actual behaviour of your server.  Here are the description of all of these callbacks.  Some of them have to be implemented.  Others have reasonable default values.</para>
        <table>
          <tableitem>
            <tableterm><code>global initializer (optional)</code></tableterm>
            <item>
              <para>This callback is executed once for every type of server.  Here you can initialize data or whatever is shared between all instances of your server. For instance the HTTP server initializes its file cache here.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>global finalizer (optional)</code></tableterm>
            <item>
              <para>If you want to free shared resources which were possibly allocated within the global initializer you can do so here.  The foo server frees its default hash previously allocated in the global initializer.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>instance initializer (mandatory)</code></tableterm>
            <item>
              <para>Within this routine you can initialize everything you might need for one instance of your server.  The foo server does not do anything in this callback.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>instance finalizer (optional)</code></tableterm>
            <item>
              <para>The server instance finalizer gets its instance representation as argument. You have to free all resources used by this server instance.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>protocol detection (mandatory)</code></tableterm>
            <item>
              <para>Because it is possible to have more than one server listening on one network port we need to detect the type of client which is connecting to this port.  The foo server checks if the first five bytes the client was sending is identifying it as a foo client.  This routine is getting two arguments where the first one is a pointer to this servers instance and the second is the client socket object containing all information of the client connection.  This structure is described a bit later.  Be patient.  For successful client detection return non-zero value.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>socket connection (mandatory)</code></tableterm>
            <item>
              <para>If the client detection signaled success this routine is called to assign the client connection to the server instance.  The arguments are just the same as in the detection routine.  In this callback you can assign all the connection specific callbacks for your server and do some initial things.  The foo server sets the <code>check_request</code> callback to the default <code>svz_sock_check_request</code> which is using the packet delimiter information to find whole packets.  When a client sent such a packet the <code>handle_request</code> callback is executed.  That is why the foo server assigns the <code>handle_request</code> method.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>client info (optional)</code></tableterm>
            <item>
              <para>If this callback is given the control protocol (See <xref><xrefnodename>Control Protocol Server</xrefnodename></xref>.) can give information about a specific client if requested with <samp>stat id NUM</samp>.  The first argument given is the server instance and the second one the client's socket structure.  You have to return a static single line character string.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>server info (optional)</code></tableterm>
            <item>
              <para>This function is called when listing the server instances via <samp>stat all</samp> from the control protocol (See <xref><xrefnodename>Control Protocol Server</xrefnodename></xref>.). The returned character string might be multilined separated by <code>\r\n</code> (no trailing separator).  Usually you will return all the server configuration information.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>notifier (optional)</code></tableterm>
            <item>
              <para>If this callback is not <code>NULL</code> it is called whenever there is some time left.  It gets the server instance itself as argument.  Actually it gets called every second.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>handle request (mandatory for UDP and ICMP servers)</code></tableterm>
            <item>
              <para>The arguments to this callback are the client's socket structure, the address of the packet data and its length.  When implementing a UDP or ICMP server you need to return non-zero if your server could process the packet.  Thus it is possible that there are multiple UDP servers on a single port.</para>
            </item>
          </tableitem>
        </table>
      </subsubsection>

      <subsubsection>
        <title>Make your server available</title>
        <para>You distribute your server by editing the <file>cfgfile.c</file> file in the <file>src/</file> directory.  There you have to include the servers header file and add the server definition by calling <code>svz_servertype_add</code></para>
      </subsubsection>

      <subsubsection>
        <title>More detailed description of the callback system and structures</title>
        <para>The client connection information is stored within the <code>svz_socket_t</code> object.  All of the client connection specific callbacks get this object as first argument.  Following is a description of the most important elements of this object.</para>
        <table>
          <tableitem>
            <tableterm><code>int id</code></tableterm>
            <item>
              <para>The socket id is a unique id for a client connection.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>int version</code></tableterm>
            <item>
              <para>This item validates this socket structure.  If you pass the <code>id</code> and <code>version</code> to a coserver you can check if the delivered socket structure is the original or not within the coserver callback.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>int proto</code></tableterm>
            <item>
              <para>The <code>proto</code> flag determines a server sockets protocol type which can be <code>PROTO_PIPE</code>, <code>PROTO_TCP</code>, <code>PROTO_UDP</code>, <code>PROTO_ICMP</code> or <code>PROTO_RAW</code>.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>int flags</code></tableterm>
            <item>
              <para>The flag field of the client connection contains informations about the state of this connection.  See <file>socket.h</file> in the <file>src/libserveez/</file> directory for more information.  Basically this bitfield specifies how this object is handled by the main server loop.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>int userflags</code></tableterm>
            <item>
              <para>This bitfield could be used for protocol specific information.  You can use it for any information.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>char *boundary, int boundary_size</code></tableterm>
            <item>
              <para>If you are going to write a packet oriented protocol server you can use the <code>svz_sock_check_request</code> method to parse packets.  These two properties describe the packet delimiter.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>char *send_buffer, int send_buffer_size, int send_buffer_fill</code></tableterm>
            <item>
              <para>This is the outgoing data for a client connection object.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>char *recv_buffer, int recv_buffer_size, int recv_buffer_fill</code></tableterm>
            <item>
              <para>Within the receive buffer all incoming data for a connection object is stored.  This buffer is at least used for the client detection callback.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>int read_socket (svz_socket_t)</code></tableterm>
            <item>
              <para>This callback gets called whenever data is available on the socket. Normally, this is set to a default function which reads all available data from the socket and feeds it to <code>check_request</code>, but specific sockets may need other policies.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>int write_socket (svz_socket_t)</code></tableterm>
            <item>
              <para>This routine is called when data is is valid in the output buffer and the socket gets available for writing.  You normally leave this callback untouched.  It simply writes as much data as possible to the socket and removes the data from the send buffer.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>int disconnected_socket (svz_socket_t)</code></tableterm>
            <item>
              <para>This gets called whenever the socket is lost for some external reason.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>int connected_socket (svz_socket_t)</code></tableterm>
            <item>
              <para>If some piece of code tries to connect to another host via <code>svz_tcp_connect</code> this connection might be established some time later. This callback gets called when the socket is finally connected.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>int kicked_socket (svz_socket_t, int)</code></tableterm>
            <item>
              <para>We call this whenever the socket gets closed by us.  The second argument specifies a reason.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>int check_request (svz_socket_t)</code></tableterm>
            <item>
              <para>This gets called whenever data was read from the socket. Its purpose is to check whether a complete request was read, and if it was, it should be handled and removed from the input buffer.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>int handle_request (svz_socket_t, char *, int)</code></tableterm>
            <item>
              <para>This gets called when the <code>check_request</code> got a valid packet.  The request arguments contains the actual packet and the second argument is the length of this packet including the packet delimiter.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>int idle_func (svz_socket_t)</code></tableterm>
            <item>
              <para>This callback gets called from the periodic task scheduler.  Whenever <code>idle_counter</code> (see below) is non-zero, it is decremented and <code>idle_func</code> gets called when it drops to zero.  <code>idle_func</code> can reset <code>idle_counter</code> to some value and thus can re-schedule itself for a later task.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>int idle_counter</code></tableterm>
            <item>
              <para>Counter for calls to <code>idle_func</code>.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>void *data</code></tableterm>
            <item>
              <para>Miscellaneous field.  Listener keeps array of server instances here. This array is <code>NULL</code> terminated.  Some servers store server specific information here.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>void *cfg</code></tableterm>
            <item>
              <para>When the final protocol detection has been done <code>cfg</code> should contain a pointer to the actual configuration hash map taken from the server instance object.</para>
            </item>
          </tableitem>
        </table>
      </subsubsection>

      <subsubsection>
        <title>Using coservers</title>
        <para>Coservers are designed to complete blocking tasks.  Each coserver runs in its own thread/process.  There are several coservers implemented: the dns, reverse dns and ident coserver.  You need to implement the callback which gets called when a coserver completed its task.  This routine must be a <code>svz_coserver_handle_result_t</code>.  The first argument is the actual coserver result which might be <code>NULL</code> if the request could not  be fulfilled and the latter two arguments are the arguments you specified  yourself when issuing the request.  To invoke a coserver you use one of the <code>svz_coserver_*</code> macros.  The foo server uses the reverse dns coserver to identify the host name of the remote client.</para>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Configuring servers</nodename>
    <nodenext>Existing servers</nodenext>
    <nodeprev>Writing servers</nodeprev>
    <nodeup>Server</nodeup>
    <section>
      <title>Some words about server configuration</title>
      <para>If you define a server you basically pass an instance name and a list of items to the <code>define-server!</code> procedure.  Each item has a name and a value.  A value has a type.  We provide several types: integers (numbers), integer arrays, strings, string arrays, booleans (yes/no-values), hashes (associations) and port configurations.</para>
      <para>The following table shows how each kind of value is set up in the configuration file.  <var>item</var> is the name of the item to be configured.</para>
      <table>
        <tableitem>
          <tableterm>Integer&linebreak;</tableterm>
          <item>
            <para>Example: (item . 42)</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>Integer array&linebreak;</tableterm>
          <item>
            <para>Example: (item . (0 1 2 3))</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>String&linebreak;</tableterm>
          <item>
            <para>Example: (item . "a character string")</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>String array&linebreak;</tableterm>
          <item>
            <para>Example: (item . ("abc" "cba" "bca" "acb"))</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>Boolean&linebreak;</tableterm>
          <item>
            <para>A normal boolean in guile is represented by #t or #f.  But the configuration file parser additional understand some bare words and numbers.&linebreak; Example: (item . #f)</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>Hash&linebreak;</tableterm>
          <item>
            <para>Hash maps associate keys with values.  Both must be character strings.&linebreak; Example: (item . (key1 . "value1") (key2 . "value2"))</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>Port configuration&linebreak;</tableterm>
          <item>
            <para>See <xref><xrefnodename>Define ports</xrefnodename></xref>, for more information on this.  When configuring a port configuration you need to define it via <code>define-port!</code> previously and put its symbolic name into the configuration.&linebreak; Example: (item . foo-tcp-port)</para>
          </item>
        </tableitem>
      </table>
      <para>The next chapter describes the servers currently implemented using Serveez.  The configuration items used by each of them are described in the following format:</para>
      <table>
        <tableitem>
          <tableterm><code>NameOfTheItem (Type, default: DefaultValue, Comments)</code></tableterm>
          <item>
            <para>Description of the configuration item named <samp>NameOfTheItem</samp> (case sensitive).  <samp>Type</samp> can be either <samp>integer</samp>, <samp>integer array</samp>, <samp>string</samp>, <samp>string array</samp>, <samp>boolean</samp>, <samp>hash</samp> or <samp>port configuration</samp>.  The <samp>Comments</samp> is an optional text.</para>
          </item>
        </tableitem>
      </table>
      <para>The example configuration file <file>data/serveez.cfg</file> contains an example definition of each server already implemented.  You can copy and modify the example for an easy start.</para>
    </section>
  </node>
  <node>
    <nodename>Existing servers</nodename>
    <nodeprev>Configuring servers</nodeprev>
    <nodeup>Server</nodeup>
    <section>
      <title>Existing servers</title>
      <menu>
        <menuentry>
          <menunode>HTTP Server</menunode>
          <menutitle>HTTP Server</menutitle>
          <menucomment>Integrated Web Server description</menucomment>
        </menuentry>
        <menuentry>
          <menunode>IRC Server</menunode>
          <menutitle>IRC Server</menutitle>
          <menucomment>EFNet IRC Server</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Control Protocol Server</menunode>
          <menutitle>Control Protocol Server</menutitle>
          <menucomment>Serveez control center</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Foo Server</menunode>
          <menutitle>Foo Server</menutitle>
          <menucomment>Example server implementation</menucomment>
        </menuentry>
        <menuentry>
          <menunode>SNTP Server</menunode>
          <menutitle>SNTP Server</menutitle>
          <menucomment>Simple network time protocol server</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Gnutella Spider</menunode>
          <menutitle>Gnutella Spider</menutitle>
          <menucomment>Gnutella Client description</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Tunnel Server</menunode>
          <menutitle>Tunnel Server</menutitle>
          <menucomment>Description of the port forwarder</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Fake Ident Server</menunode>
          <menutitle>Fake Ident Server</menutitle>
          <menucomment>Description of a simple ident server</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Passthrough Server</menunode>
          <menutitle>Passthrough Server</menutitle>
          <menucomment>Description of the program passthrough server</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Mandel Server</menunode>
          <menutitle>Mandel Server</menutitle>
          <menucomment>Distributed Mandelbrot server</menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>HTTP Server</nodename>
    <nodenext>IRC Server</nodenext>
    <nodeup>Existing servers</nodeup>
    <subsection>
      <title>HTTP Server</title>
      <subsubsection>
        <title>General description</title>
        <para>The integrated HTTP server was originally meant to be a simple but fast document server.  But now it can even execute CGI scripts.  The GET, HEAD and POST methods are fully functional.  Additionally Serveez produces directory listings when no standard document file (e.g., <file>index.html</file>) has been found at the requested document node (directory).  Furthermore it implements a file cache for speeding up repetitive HTTP request.</para>
        <para>In comparison to other web server projects like Apache and Roxen this web server is really fast.  Comparative benchmarks will follow. The benchmark system is a 233 MHz Mobile Pentium MMX.  Both the server and the client (http_load - multiprocessing http test client) ran on the same computer.</para>
        <table>
          <tableitem>
            <tableterm><code>Small files</code></tableterm>
            <item>
              <para>The small-file test load consists of 1000 files, each 1KB long, requested randomly.</para>
              <example xml:space="preserve">concurrent fetches   1   10   50  100  200  500  1000
hits/second        501  520  481  475  420  390   295</example>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>CGI</code></tableterm>
            <item>
              <para>The CGI test load consists of a trivial &ldquo;hello world&rdquo; C program.  I noticed GNU/Linux (2.2.17 in this case, probably others too) to throw &ldquo;Resource temporarily unavailable&rdquo; errors when <code>fork</code>ing very fast.  This limits the test to about 200 concurrent fetches on the test system.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>Large files</code></tableterm>
            <item>
              <para>The large-file test load consists of 100 files, each 1MB long, requested randomly.  Also, each connection is throttled to simulate a 33.6Kbps modem. Note that 1000 33.6Kbps connections is 3/4 of a T3.  There was no problem to get 1000+ concurrent fetches.</para>
            </item>
          </tableitem>
        </table>
      </subsubsection>

      <subsubsection>
        <title>Configuration</title>
        <para>The following options can be set from the configuration file.</para>
        <table>
          <tableitem>
            <tableterm><code>indexfile (string, default: index.html)</code></tableterm>
            <item>
              <para>The <code>indexfile</code> parameter is the default file served by the HTTP server when the user does not specify a file but a document node (e.g., <uref><urefurl>http://www.lkcc.org/</urefurl></uref>).</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>docs (string, default: ../show)</code></tableterm>
            <item>
              <para>The <code>docs</code> parameter is the document root where the server finds its web documents.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>userdir (string, default: public_html)</code></tableterm>
            <item>
              <para>Each <samp>~user</samp> request gets converted into the given users home directory.  The string will be appended to this directory.  Its default value is <samp>public_html</samp>.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>cgi-url (string, default: /cgi-bin)</code></tableterm>
            <item>
              <para>This parameter is the first part of the URL the HTTP server identifies a CGI request.  For instance if you specify here <file>/cgi-bin</file> and the user requests <uref><urefurl>http://www.lkcc.org/cgi-bin/test.pl</urefurl></uref> then the HTTP server tries to execute the program <file>test.pl</file> within the <code>cgi-dir</code> (see below) and pipes its output to the user.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>cgi-dir (string, default: ./cgibin)</code></tableterm>
            <item>
              <para>The <code>cgi-dir</code> is the CGI document root (on the server).</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>cgi-application (hash, default: empty)</code></tableterm>
            <item>
              <para>Within the MinGW32 port you can use this hash to associate certain file suffices with applications on your computer (e.g., <file>pl</file> with <file>perl</file>).  This is necessary because there is no possibility to check whether a file is executable on Win32.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>cache-size (integer, default: 200 kb)</code></tableterm>
            <item>
              <para>This specifies the size of the document cache in bytes for each cache entry.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>cache-entries (integer, default: 64)</code></tableterm>
            <item>
              <para>This parameter specifies the maximum number of HTTP file cache entries (files).  When you instantiate more than one HTTP server the biggest value wins.  The HTTP file cache is shared by all HTTP servers.&linebreak; <strong>Please note</strong>: If your harddrive/filesystem combination proves to be faster than the HTTP file cache you should disable it by setting both <code>cache-size</code> and <code>cache-entries</code> to zero.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>timeout (integer, default: 15)</code></tableterm>
            <item>
              <para>The <code>timeout</code> value is the amount of time in seconds after which a keep-alive connection (this is a HTTP/1.1 feature) will be closed when it has been idle.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>keepalive (integer, default: 10)</code></tableterm>
            <item>
              <para>On one keep-alive connection can be served the number of <code>keepalive</code> documents at all.  Then the connection will be closed. Both this and the <code>timeout</code> value are just to be on the safe side. They protect against idle and high traffic connections.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>default-type (string, default: text/plain)</code></tableterm>
            <item>
              <para>The <code>default-type</code> is the default content type the HTTP server assumes if it can not identify a served file by the <code>types</code> hash and the <code>type-file</code> (see below).</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>type-file (string, default: /etc/mime.types)</code></tableterm>
            <item>
              <para>This should be a file like the <file>/etc/mime.types</file> on Unix systems. It associates file suffices with MIME types.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>types (hash, default: empty)</code></tableterm>
            <item>
              <para>If you want to specify special content types do it here.  This parameter is a hash map associating file suffices with HTTP content types (MIME types).</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>admin (string, default: root@localhost)</code></tableterm>
            <item>
              <para>Your address, where problems with the server should be e-mailed. This address appears on some server-generated pages, such as error documents.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>host (string, default: localhost)</code></tableterm>
            <item>
              <para>This is the host name of your web server.  Sometimes the server has to send back its own name to the client.  It will use this value. Be aware that you cannot invent such a name.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>nslookup (boolean, default: false)</code></tableterm>
            <item>
              <para>If this is true the HTTP server invokes a reverse DNS lookup for each client connection in order to replace the remote ip address with the remote host name in the access logfile.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>ident (boolean, default: false)</code></tableterm>
            <item>
              <para>If this is true the HTTP server processes identd requests for each client connection for logging purposes.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>logfile (string, default: http-access.log)</code></tableterm>
            <item>
              <para>The location of the access logfile.  For each HTTP request a line gets appended to this file.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>logformat (string, default: CLF)</code></tableterm>
            <item>
              <para>The format of the access logfile.  There are special placeholders for different kinds of logging information.  The default log format is the Common Log Format (CLF).  It contains a separate line for each request.  A line is composed of several tokens separated by spaces.</para>
              <example xml:space="preserve">CLF = host ident authuser date request status bytes</example>
              <para>If a token does not have a value then it is represented by a hyphen (-). The meanings and values of these tokens are as follows:</para>
              <table>
                <tableitem>
                  <tableterm><code>%h (host)</code></tableterm>
                  <item>
                    <para>The fully-qualified domain name of the client, or its IP number if the name is not available.</para>
                  </item>
                </tableitem>
                <tableitem>
                  <tableterm><code>%i (ident)</code></tableterm>
                  <item>
                    <para>This is the identity information reported by the client.  Not active, so we will see a hyphen (-).</para>
                  </item>
                </tableitem>
                <tableitem>
                  <tableterm><code>%u (authuser)</code></tableterm>
                  <item>
                    <para>If the request was for an password protected document, then this is the userid used in the request.</para>
                  </item>
                </tableitem>
                <tableitem>
                  <tableterm><code>%t (date)</code></tableterm>
                  <item>
                    <para>The date and time of the request, in the following format:</para>
                    <example xml:space="preserve">date   = [day/month/year:hour:minute:second zone]
day    = 2*digit
month  = 3*letter
year   = 4*digit
hour   = 2*digit
minute = 2*digit
second = 2*digit
zone   = (`+' | `-') 4*digit</example>
                  </item>
                </tableitem>
                <tableitem>
                  <tableterm><code>%R (request)</code></tableterm>
                  <item>
                    <para>The request line from the client, enclosed in double quotes (").</para>
                  </item>
                </tableitem>
                <tableitem>
                  <tableterm><code>%r (referrer)</code></tableterm>
                  <item>
                    <para>Which document referred to this document.</para>
                  </item>
                </tableitem>
                <tableitem>
                  <tableterm><code>%a (agent)</code></tableterm>
                  <item>
                    <para>What kind of web browser did the remote client use.</para>
                  </item>
                </tableitem>
                <tableitem>
                  <tableterm><code>%c (status)</code></tableterm>
                  <item>
                    <para>The three digit status code returned to the client.</para>
                  </item>
                </tableitem>
                <tableitem>
                  <tableterm><code>%l (bytes)</code></tableterm>
                  <item>
                    <para>The number of bytes in the object returned to the client, not including any headers.</para>
                  </item>
                </tableitem>
              </table>
            </item>
          </tableitem>
        </table>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>IRC Server</nodename>
    <nodenext>Control Protocol Server</nodenext>
    <nodeprev>HTTP Server</nodeprev>
    <nodeup>Existing servers</nodeup>
    <subsection>
      <title>IRC Server</title>
      <subsubsection>
        <title>General description</title>
        <para>Internet Relay Chat.  The mother of all chat systems.  The integrated IRC server is intended to be compatible with the EFNet.  There are no good possibilities to test this in real life, so it is still under heavy construction.  But it can be used as a standalone server anyway.</para>
        <para>IRC itself is a teleconferencing system, which (through the use of the client-server model) is well-suited for running on many machines in a distributed fashion.  A typical setup involves a single process (the server) forming a central point for clients (or other servers) to connect to, performing the required message delivery/multiplexing and other functions.</para>
        <para>The server forms the backbone of IRC, providing a point for clients and servers to connect to.  Clients connect to talk to each other.  Servers connect to build up a network of servers.  IRC server connections have to build up a spanning tree.  Loops are not allowed.  Each server acts as a central node for the rest of the network it sees.</para>
      </subsubsection>

      <subsubsection>
        <title>Configuration</title>
        <para>The following table shows the configuration keys provided.  Most of the configuration items are similar to those of an Hybrid IRC server.  They seem archaic at first sight but IRC operators are used to it.  Refer to the Hybrid documentation for further information.  It can be found on the EFNet web page.</para>
        <table>
          <tableitem>
            <tableterm><code>MOTD-file (string, default: ../data/irc-MOTD.txt)</code></tableterm>
            <item>
              <para>When a user initially joins it will get this file's content as the message of the day comment.  When changing on disk the server will notice that and reload the file automatically.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>INFO-file (string, default: no file)</code></tableterm>
            <item>
              <para>The <code>INFO-file</code>s content gets displayed when the user issues the /INFO command.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>tsdelta (integer, default: 0)</code></tableterm>
            <item>
              <para>This value is the timestamp delta value to UTC (Coordinated Universal Time) in seconds.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>channels-per-user (integer, default: 10)</code></tableterm>
            <item>
              <para>Configures the maximum number of channels a single local user can join.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>admininfo (string, no default)</code></tableterm>
            <item>
              <para>Some administrative information delivered on the /ADMIN command.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>M-line (string, no default, mandatory)</code></tableterm>
            <item>
              <para>The TCP level configuration of this IRC server.  The server info field is sometimes given to the client for informational use.  The server will croak about if the settings do not correspond with the actual bindings. The format of this line is:</para>
              <example xml:space="preserve">":" virtual hostname
":" optional bind address (real hostname)
":" server info: "World's best IRC server"
":" port</example>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>A-line (string, no default, mandatory)</code></tableterm>
            <item>
              <para>The administrative info, printed by the /ADMIN command.</para>
              <example xml:space="preserve">":" administrative info (department, university)
":" the server's geographical location
":" email address for a person responsible for the IRC server</example>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>Y-lines (string array, no default, suggested)</code></tableterm>
            <item>
              <para>The connection classes.  They are used in other parameters (e.g., I-lines). A Y-line describes a group of connections.  You usually have at least two Y-lines: One for server connections and one for client connections. Format of each line is:</para>
              <example xml:space="preserve">":" class number (higher numbers refer to a higher priority)
":" ping frequency (in seconds)
":" connect frequency in seconds for servers, 0 for
    client classes
":" maximum number of links in this class
":" send queue size</example>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>I-lines (string array, no default, mandatory)</code></tableterm>
            <item>
              <para>Authorization of clients, wildcards permitted, a valid client is matched <email><emailaddress>user@ip</emailaddress></email> OR <email><emailaddress>user@host</emailaddress></email>.</para>
              <example xml:space="preserve">":" user@ip, you can specify <samp>NOMATCH</samp> here to force
    matching user@host
":" password (optional)
":" user@host
":" password (optional)
":" connection class number (YLine)</example>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>O-lines (string array, no default, optional)</code></tableterm>
            <item>
              <para>Authorize operator, wildcards allowed.</para>
              <example xml:space="preserve">":" user@host, user@ forces checking ident
":" password
":" nick</example>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>o-lines (string array, no default, optional)</code></tableterm>
            <item>
              <para>Authorize local operator.</para>
              <example xml:space="preserve">":" user@host, user@ forces checking ident
":" password
":" nick</example>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>C-lines (string array, no default, networked)</code></tableterm>
            <item>
              <para>List of servers to connect to. Note: C and N lines can also use the user@ combination in order to check specific users (ident) starting servers.  C and N lines are usually given in pairs.</para>
              <example xml:space="preserve">":" host name
":" password
":" server name (virtual)
":" port (if not given we will not connect)
":" connection class number (YLine)</example>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>N-lines (string array, no default, networked)</code></tableterm>
            <item>
              <para>Servers which may connect.</para>
              <example xml:space="preserve">":" host name
":" password
":" server name (virtual host name)
":" password
":" how many components of your own server's name to strip
    off the front and be replaced with a <samp>*</samp>.
":" connection class number (YLine)</example>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>K-lines (string array, no default, optional)</code></tableterm>
            <item>
              <para>Kill user, wildcards allowed.</para>
              <example xml:space="preserve">":" host
":" time of day
":" user</example>
            </item>
          </tableitem>
        </table>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Control Protocol Server</nodename>
    <nodenext>Foo Server</nodenext>
    <nodeprev>IRC Server</nodeprev>
    <nodeup>Existing servers</nodeup>
    <subsection>
      <title>Control Protocol Server</title>
      <para>If the GNU Serveez package is configured with the control protocol enabled, running <samp>serveez --help</samp> will show the option <code>-P</code> and the following documentation applies. Otherwise, feel free to skip to the next section.</para>

      <subsubsection>
        <title>General description</title>
        <para>Serveez implements something like a telnet protocol for administrative purposes.  You just need to start a telnet session like:</para>
        <example xml:space="preserve">$ telnet www.lkcc.org 42420</example>
        <para>After pressing <key>RET</key> you will be asked for a password which you might setup passing Serveez the -P argument. See <xref><xrefnodename>Using Serveez</xrefnodename></xref>.  The next section describes the interactive commands available.</para>
      </subsubsection>

      <subsubsection>
        <title>Using the Control Protocol</title>
        <table>
          <tableitem>
            <tableterm><samp>help</samp></tableterm>
            <item>
              <para>This command will give you a very short help screen of all available commands.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>quit</samp></tableterm>
            <item>
              <para>This command closes the connection to Serveez.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>restart ident</samp></tableterm>
            <item>
              <para>Restarts the internal ident coserver.  This is useful if you just want to start a new one if the old one died or is otherwise unusable.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>restart dns</samp></tableterm>
            <item>
              <para>Restarts the internal dns lookup server.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>restart reverse dns</samp></tableterm>
            <item>
              <para>Restarts the internal reverse dns lookup server.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>killall</samp></tableterm>
            <item>
              <para>This might be useful if Serveez seems to be unstable but you do not want to restart it.  With <samp>killall</samp> you disconnect all client network connections except the control protocol connections.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>kill id NUM</samp></tableterm>
            <item>
              <para>Disconnects a specific connection identified by its ID.  These IDs will be stated when you type <samp>stat con</samp> (see below).</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>stat</samp></tableterm>
            <item>
              <para>General statistics about Serveez.  This will show you some useful information about the computer Serveez is running on and about the state of Serveez in general.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>stat coserver</samp></tableterm>
            <item>
              <para>Statistics about all running coserver instances.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>stat SERVER</samp></tableterm>
            <item>
              <para>This command is for selecting certain server instances to be listed. SERVER is one of server names you specified in the configuration file.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>stat id NUM</samp></tableterm>
            <item>
              <para>Show statistics about a specific connection.  This will give you all available information about every connection you specified. See <xref><xrefnodename>Writing servers</xrefnodename></xref>, for more information about how to provide these information.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>stat con</samp></tableterm>
            <item>
              <para>Connection statistics.  This will give a list of all socket structures within Serveez.  If you want more detailed information about specific connections, coservers or servers you need to request these information with <samp>stat id NUM</samp> or <samp>stat all</samp>.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>stat all</samp></tableterm>
            <item>
              <para>Server and coserver instance statistics.  This command lists all the information about instantiated servers and coservers. See <xref><xrefnodename>Writing servers</xrefnodename></xref>, for more information about how to provide these information.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>stat cache</samp></tableterm>
            <item>
              <para>HTTP cache statistics.  This command produces an output something like the following where <samp>File</samp> is the short name of the cache entry, <samp>Size</samp> the cache size, <samp>Usage</samp> the amount of connections currently using this entry, <samp>Hits</samp> the amount of cache hits, <samp>Recent</samp> the cache strategy flag (newer entries have larger numbers) and <samp>Ready</samp> is the current state of the cache entry.</para>
              <example xml:space="preserve">File                      Size  Usage  Hits Recent Ready
zlib-1.1.3-20000531.zip  45393      0     0      1 Yes
texinfo.tex             200531      0     0      2 Yes
shayne.txt                2534      0     1      1 Yes

Total : 248458 byte in 3 cache entries</example>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><samp>kill cache</samp></tableterm>
            <item>
              <para>Reinitialize the HTTP file cache.  Flushes all files from the cache.</para>
            </item>
          </tableitem>
        </table>
      </subsubsection>

      <subsubsection>
        <title>Configuration</title>
        <para>There is nothing to be configured yet.</para>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Foo Server</nodename>
    <nodenext>SNTP Server</nodenext>
    <nodeprev>Control Protocol Server</nodeprev>
    <nodeup>Existing servers</nodeup>
    <subsection>
      <title>Foo Server</title>
      <subsubsection>
        <title>General description</title>
        <para>The Foo Server is a simple example on how to write Internet protocol servers with Serveez.  See <xref><xrefnodename>Writing servers</xrefnodename></xref>.</para>
      </subsubsection>

      <subsubsection>
        <title>Configuration</title>
        <para>There are all kinds of configuration items.  They are used to explain the implementation of servers.  A complete list will follow.</para>
        <table>
          <tableitem>
            <tableterm><code>port (port configuration, default: tcp, 42421, *)</code></tableterm>
            <item>
              <para>Sets up the TCP port and local address.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>bar (integer, no default)</code></tableterm>
            <item>
              <para>Some integer value.  Printed as server information.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>reply (string, default: Default reply)</code></tableterm>
            <item>
              <para>Some string.  Printed as server information.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>messages (string array, default: ...)</code></tableterm>
            <item>
              <para>Some string array which is actually a list of strings.  Also printed as server information.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>ports (integer array, default: 1, 2, 3, 4)</code></tableterm>
            <item>
              <para>Some array of integer numbers.  Printed as server information.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>assoc (hash, default, default: ...)</code></tableterm>
            <item>
              <para>An hash map associating keys with values.  Printed as server information.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>truth (boolean, default: true)</code></tableterm>
            <item>
              <para>Some boolean value.  Printed as server information.</para>
            </item>
          </tableitem>
        </table>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>SNTP Server</nodename>
    <nodenext>Gnutella Spider</nodenext>
    <nodeprev>Foo Server</nodeprev>
    <nodeup>Existing servers</nodeup>
    <subsection>
      <title>SNTP Server</title>
      <subsubsection>
        <title>General</title>
        <para>The SNTP server can be queried with the <samp>netdate</samp> command.  It is used to synchronize time and dates between Internet hosts.  The protocol is described in the ARPA Internet RFC 868.  Thus it is not really an SNTP server as described by RFC 2030 (Simple Network Time Protocol (SNTP) Version 4 for IPv4, IPv6 and OSI).  It is rather an excellent example on how to implement a UDP server in Serveez.</para>
        <para>This protocol provides a site-independent, machine readable date and time.  The Time service sends back time in seconds since midnight on January first 1900.</para>
        <para>One motivation arises from the fact that not all systems have a date/time clock, and all are subject to occasional human or machine error.  The use of time-servers makes it possible to quickly confirm or correct a system's idea of the time, by making a brief poll of several independent sites on the network.</para>
      </subsubsection>

      <subsubsection>
        <title>Configuration</title>
        <para>The configuration of this server does not require any item.</para>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Gnutella Spider</nodename>
    <nodenext>Tunnel Server</nodenext>
    <nodeprev>SNTP Server</nodeprev>
    <nodeup>Existing servers</nodeup>
    <subsection>
      <title>Gnutella Spider</title>
      <subsubsection>
        <title>What is it ?</title>
        <para>The Gnutella net is a peer-to-peer network which is based on client programs only.  There are no servers.  The network itself is formed by client connections only.  Generally the Gnutella network is for sharing files of any kind.</para>
        <para>This Gnutella spider is for seeking the needle in the haystack.  Once connected to the network it regularly tries to find certain files in there. It keeps track of all connected clients and tries to reconnect them if the current connections are lost.</para>
        <para>Gnutella, however has nothing to do with the GNU project.  The original client is just a free (as in free beer) piece of software.  With Serveez you have a free (as in freedom) way to use it.  Have a look at the Gnutella page for further information.</para>
      </subsubsection>

      <subsubsection>
        <title>Configuration</title>
        <para>The Gnutella spider knows the following configurations items.</para>
        <table>
          <tableitem>
            <tableterm><code>net-url (string, default: gnutella-net)</code></tableterm>
            <item>
              <para>If you want to see the host catcher list of this Gnutella spider you can connect to this port with any WWW browser at <uref><urefurl>http://host:port/net-url</urefurl></uref>.  The <code>host:port</code> combinations depend on the bindings.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>hosts (string array, no default)</code></tableterm>
            <item>
              <para>This is the start of the haystack, the initial host list of the clients the spider tries to connect to.  Each list item should be of the format <code>ip:port</code> (e.g., <samp>146.145.85.34:6346</samp>).  You can also pass Internet host names.  If the port information is left blank it defaults to 6346.  If you need some entry point for the Gnutella network have a look at <uref><urefurl>http://www.gnutellahosts.com/</urefurl></uref> or <uref><urefurl>http://www.gnutellanet.com/</urefurl></uref>.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>search (string array, default: Puppe3000, Meret Becker)</code></tableterm>
            <item>
              <para>This is the needle.  Each search line is either a set of space delimited tokens where every token must match.  Or a kind of wildcard expression including <samp>?</samp> and <samp>*</samp>. Search lines are always matched case insensitive.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>search-limit (integer, default: 30)</code></tableterm>
            <item>
              <para>This limits how many results the Gnutella spider returns to other people searching your files.  This is for protection against <code>*</code> search requests.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>max-ttl (integer, default: 5)</code></tableterm>
            <item>
              <para>Every Gnutella packet has got a TTL.  This is the maximum TTL allowed for outgoing packets.  When a packet comes in it gets its TTL value decremented and is forwarded to it destination.  If however an incoming packet has a TTL larger than <code>max-ttl</code> the ttl value is set to <code>max-ttl</code>.  This is necessary since most people use far too large TTL values.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>ttl (integer, default: 5)</code></tableterm>
            <item>
              <para>When creating a new Gnutella packet we use this as TTL.  Please use a sane value.  This ttl needs not to be as large as it is for IP packets. A value below 10 is more than enough.  Have a look at the Gnutella page for a calculation of a 'sane value'.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>download-path (string, default: /tmp)</code></tableterm>
            <item>
              <para>This is where the spider saves needles in.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>share-path (string, default: /tmp)</code></tableterm>
            <item>
              <para>Here are all the files we share with others.  The Gnutella spider will recurse into directories.  So be careful with this option.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>max-downloads (integer, default: 4)</code></tableterm>
            <item>
              <para>Maximum number of concurrent downloads from the network.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>max-uploads (integer, default: 4)</code></tableterm>
            <item>
              <para>Maximum number of concurrent uploads to the network.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>connection-speed (integer, default: 28)</code></tableterm>
            <item>
              <para>This is what we send as our connection speed in KBit/s.  We also use this value to throttle down the network transfer rate for file uploads.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>min-speed (integer, default: 28)</code></tableterm>
            <item>
              <para>Search for needles on hosts with a minimum speed.  Set it to 0 if you do not care about that.  This value is in KBit/s, too.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>file-extensions (string array, default: empty list)</code></tableterm>
            <item>
              <para>If we get replies on search queries we check if the file extension of this reply matches one of these extensions.  Useful extensions are <samp>mp3</samp> and <samp>mpg</samp>.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>connections (integer, default: 4)</code></tableterm>
            <item>
              <para>This is the number of concurrent connections the Gnutella spider tries to keep up to the network.  The IP addresses and the port information is taken from the host catcher hash.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>force-ip (string, default: not set)</code></tableterm>
            <item>
              <para>You can force the Gnutella spider to send outgoing replies with this IP as host information.  Must be in dotted decimals notation.  This is useful if you are behind a masquerading gateway.  You need to install some kind of port forwarder on the gateway so other people can reach you from the outside.  Serveez is a good port forwarder.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>force-port (integer, default: not set)</code></tableterm>
            <item>
              <para>Force the Gnutella spider to send outgoing replies with the <code>force-port</code> as port information.  See above for more information.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>disable (boolean, default: false)</code></tableterm>
            <item>
              <para>With this configuration option you can disable the bindings for a Gnutella server instance.  This means that no remote client can connect without being told so (e.g., by push requests).</para>
            </item>
          </tableitem>
        </table>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Tunnel Server</nodename>
    <nodenext>Fake Ident Server</nodenext>
    <nodeprev>Gnutella Spider</nodeprev>
    <nodeup>Existing servers</nodeup>
    <subsection>
      <title>Tunnel Server</title>
      <subsubsection>
        <title>General description</title>
        <para>The Tunnel server is for mapping one port configuration to another. So we should rather speak of a port forwarder.  Two port forwarders can form a tunnel.  Generally this means that you can setup Serveez to accept network or pipe connections in order to pass all transfer data on this line to another port configuration.  This can be useful to work around gateways and firewalls.  When instantiating an ICMP source or destination you must ensure root privileges for the application.  On Windows NT and Windows 2000 you need to be either logged in as Administrator or have set the registry key HKLM\System\CurrentControlSet\Services\Afd\Parameters\DisableRawSecurity to 1 (DWORD).  One of the given examples in <file>serveez.cfg</file> shows how you can setup a tunnel server for forwarding a pipe connection.  Please keep in mind when forwarding a TCP or pipe connection over ICMP or UDP you loose reliability since the latter two are packet oriented rather than connection oriented.  We are not willing to implement our own TCP stack to work on ICMP/UDP directly.</para>
        <para>Forwarding between the same types of connection is always possible.  When forwarding to an ICMP tunnel we use a special protocol which we will outline in the following section.</para>
      </subsubsection>

      <subsubsection>
        <title>Extended ICMP protocol specification</title>
        <para>Since ICMP (Internet Control Message Protocol) does have a fixed packet format we had to extend it in order to use it for our own purposes.  The protocol field of the IP header contains a binary <samp>1</samp> which is the identifier for ICMP (e.g., <samp>6</samp> identifies TCP).  When creating an ICMP socket the IP header is always generated by the kernel.  This is the main difference to raw sockets where the IP header must be generated at userspace level.</para>
        <para>When receiving an ICMP packet it also contains the IP header.  When sending an ICMP packet you must not prepend this IP header.  The kernel will do this itself.  The IP header always follows the actual ICMP header followed by the ICMP packet data.  Since this section does not cover raw sockets we leave the IP header structure out here.</para>
        <para>The modified ICMP message format is as: </para>
        <multitable>
          <columnfraction>20</columnfraction>
          <columnfraction>20</columnfraction>
          <columnfraction>60</columnfraction>
          <tbody>
            <row>
              <entry>Offset</entry>
              <entry>Size</entry>
              <entry>Meaning</entry>
            </row>
            <row>
              <entry>0</entry>
              <entry>1</entry>
              <entry>Message type.</entry>
            </row>
            <row>
              <entry>1</entry>
              <entry>1</entry>
              <entry>Message type sub code.</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>2</entry>
              <entry>Checksum.</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>2</entry>
              <entry>Senders unique identifier.</entry>
            </row>
            <row>
              <entry>6</entry>
              <entry>2</entry>
              <entry>Sequence number.</entry>
            </row>
            <row>
              <entry>8</entry>
              <entry>2</entry>
              <entry>Port number.</entry>
            </row>
            <row>
              <entry>10</entry>
              <entry>0 - 65506</entry>
              <entry>Packet load.</entry>
            </row>
          </tbody>
        </multitable>
        <para>Each of these fields can be modified and processed by Serveez and do not get touched by the kernel at all.  The ICMP socket implementation of Serveez differentiates two types of sockets: listening and connected ICMP sockets. This is non-standard because it actually makes no sense since there is no difference for the kernel.  The introduction of these semantics allow Serveez to forward data between connection-oriented (TCP and named pipes) and packet-oriented (UDP and ICMP) protocols.</para>
        <table>
          <tableitem>
            <tableterm>Message type</tableterm>
            <item>
              <para>Valid message types are for instance <samp>8</samp> for an echo message and <samp>0</samp> for its echo reply.  These two messages are used for the systems builtin ping services.  Serveez uses its own message type identifier which is <samp>42</samp> (<code>ICMP_SERVEEZ</code>) by default.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm>Message type sub code</tableterm>
            <item>
              <para>Serveez also defines its own message type sub codes described in the following table. </para>
              <multitable>
                <columnfraction>20</columnfraction>
                <columnfraction>40</columnfraction>
                <columnfraction>40</columnfraction>
                <tbody>
                  <row>
                    <entry>Sub code</entry>
                    <entry>Constant identifier</entry>
                    <entry>Description</entry>
                  </row>
                  <row>
                    <entry>0</entry>
                    <entry><code>ICMP_SERVEEZ_DATA</code></entry>
                    <entry>packet contains data</entry>
                  </row>
                  <row>
                    <entry>1</entry>
                    <entry><code>ICMP_SERVEEZ_REQ</code></entry>
                    <entry>unused</entry>
                  </row>
                  <row>
                    <entry>2</entry>
                    <entry><code>ICMP_SERVEEZ_ACK</code></entry>
                    <entry>unused</entry>
                  </row>
                  <row>
                    <entry>3</entry>
                    <entry><code>ICMP_SERVEEZ_CLOSE</code></entry>
                    <entry>disconnection message</entry>
                  </row>
                  <row>
                    <entry>4</entry>
                    <entry><code>ICMP_SERVEEZ_CONNECT</code></entry>
                    <entry>connect message</entry>
                  </row>
                </tbody>
              </multitable>
            </item>
          </tableitem>
          <tableitem>
            <tableterm>Checksum</tableterm>
            <item>
              <para>The checksum field of the ICMP header is used to check the ICMP headers and the payloads (packet data) validity.  We are using the standard Internet Checksum algorithm described in RFC 1071.  If the check failed we drop the packet.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm>Senders unique identifier</tableterm>
            <item>
              <para>The senders identifier field is used to determine if a received packet has been sent by the sender itself and should therefore be dropped.  This happens because each ICMP socket setup for receiving gets all sent ICMP packets system wide.  Thus Serveez will even be notified if the kernel creates some echo reply or destination unreachable message due to a request completely outside the scope of Serveez.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm>Sequence number</tableterm>
            <item>
              <para>Each connected ICMP socket increments its sequence number when sending a packet.  Thus a connection message type packet of such a socket always has a zero sequence number.  This field could (but is not yet) also be used to reorder ICMP packets or to detect missing packets.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm>Port number</tableterm>
            <item>
              <para>The port field of the modified packet format helps Serveez to establish connected ICMP sockets.  A simple packet filter detects if a received packet is kind of reply to a sockets sent packets by comparing this port number. The packet is dropped if the comparison fails and it is not a listening socket.</para>
            </item>
          </tableitem>
        </table>
        <para>Except the data message type subcode all ICMP packets created and sent by Serveez have a zero payload.  The connect message subcode identifies a new connection and the disconnection message subcode its shutdown without actually transmitting data.  These two subcodes emulate a TCP connections <code>connect</code>, <code>accept</code> and <code>shutdown</code> system call.</para>
      </subsubsection>

      <subsubsection>
        <title>Configuration</title>
        <para>This might be the most easiest configuration to setup.  You essentially need to define the source port configuration and the target port configuration.  The <file>serveez.cfg</file> in the <file>data/</file> directory shows two example configurations how to tunnel TCP connections over UDP and ICMP.  The UDP tunnel accesses the standard HTTP port 80 and the ICMP tunnel accesses the standard Telnet port 23.</para>
        <table>
          <tableitem>
            <tableterm><code>source (port configuration, no default)</code></tableterm>
            <item>
              <para>The source port configuration.  This is usually the same you bind the server to.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>target (port configuration, no default)</code></tableterm>
            <item>
              <para>The target port configuration.</para>
            </item>
          </tableitem>
        </table>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Fake Ident Server</nodename>
    <nodenext>Passthrough Server</nodenext>
    <nodeprev>Tunnel Server</nodeprev>
    <nodeup>Existing servers</nodeup>
    <subsection>
      <title>Fake Ident Server</title>
      <subsubsection>
        <title>General description</title>
        <para>Most systems run the 'ident protocol' on port 113.  Internet hosts can connect to that port and find out what user is having a connection to the host.  For example a webserver can query your username when you fetch a file (e.g., Serveez' internal ident-coserver can do that). Most IRC servers protect themselves by allowing only users that have a valid ident response.  Therefore mIRC (for windoze) has a built in ident server. This fake ident server can be used to 'fake' a response.  This is useful when you connect through a masquerading gateway and the gateway cannot handle ident requests correctly.  (Or, of course, you are using windoze, need an ident response and do not have mIRC at hand.)</para>
        <para>This server has two modes of operation.  In one mode all requests get <samp>ERROR : NO-USER</samp> as response.  This is a valid but not very helpful response. The other mode makes the server send a valid and useful response.  It contains a system type and a username.  The system type is usually 'UNIX'.  Others are valid but never used (at least i have never seen something else).</para>
      </subsubsection>

      <subsubsection>
        <title>Configuration</title>
        <para>This server is easy to configure.</para>
        <table>
          <tableitem>
            <tableterm><code>systemtype (string, default: UNIX)</code></tableterm>
            <item>
              <para>The system type to respond.  The username field of the response has other meanings depending on this field, so do not make things up here.  Read the RFC to learn more.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>username (string, default: &lt;NULL&gt;)</code></tableterm>
            <item>
              <para>If no username is set (which means this field does not appear in the configuration file) the server runs in the flag-all-requests-as-error mode. Use your favourite nickname here.</para>
            </item>
          </tableitem>
        </table>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Passthrough Server</nodename>
    <nodenext>Mandel Server</nodenext>
    <nodeprev>Fake Ident Server</nodeprev>
    <nodeup>Existing servers</nodeup>
    <subsection>
      <title>Passthrough Server</title>
      <subsubsection>
        <title>General description</title>
        <para>The program passthrough server provides basic inetd functionality. Basically it can accept connections and pass this connection to the standard input (stdin) and standard output (stdout) handles of programs.  Depending on the platform (operating system) the user is able to configure different methods how this can be achieved.</para>
      </subsubsection>

      <subsubsection>
        <title>Configuration</title>
        <para>This server has different types of configuration options specifying its behaviour.  Some of them are mandatory and some are optional.  The very least to configure is the program to be started when a new connection is made.</para>
        <table>
          <tableitem>
            <tableterm><code>binary (string, no default)</code></tableterm>
            <item>
              <para>This parameter specifies the program to execute when a new connection has been accepted.  The parameter is mandatory and must be a fully qualified file name (including path).</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>directory (string, no default)</code></tableterm>
            <item>
              <para>This will be the working directory of the executed program.  If you omit this parameter the server uses the current directory (the directory is not changed).</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>user (string, no default)</code></tableterm>
            <item>
              <para>If you omit this parameter no user or group will be set for the started program.  Otherwise you need to specify this information in the format <samp>user[.group]</samp>.  If the group is omitted the user's primary group will be used.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>argv (string array, no default)</code></tableterm>
            <item>
              <para>This list of character strings is going to be the program's argument list (command line).  If the first list item (which is argv[0] and the program's name) is left blank it defaults to the name specified in the <code>binary</code> parameter.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>do-fork (boolean, default: true)</code></tableterm>
            <item>
              <para>This flag specifies the method used to pass the connection to the program. If it is true the server uses the Unix'ish <code>fork</code> and <code>exec</code> method.  Otherwise it will pass the data through a unnamed pair of sockets [ or two pairs of anonymous pipes ].</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>single-threaded (boolean, default: true)</code></tableterm>
            <item>
              <para>This parameter applies to servers bound to UDP and ICMP port configurations only.  For programs which process all incoming packets and eventually time out, the program is said to be <samp>single-threaded</samp> and should use a true value here.  If a program gets a packet and can receive further packets, it is said to be a <samp>multi-threaded</samp> program, and should use a false value.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>thread-frequency (integer, default: 40)</code></tableterm>
            <item>
              <para>The optional <code>thread-frequency</code> parameter specifies the maximum number of program instances that may be spawned from the server within an interval of 60 seconds.</para>
            </item>
          </tableitem>
        </table>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Mandel Server</nodename>
    <nodeprev>Passthrough Server</nodeprev>
    <nodeup>Existing servers</nodeup>
    <subsection>
      <title>Mandel Server</title>
      <subsubsection>
        <title>General description</title>
        <para>The distributed Mandelbrot server is an Internet server completely written in Guile with the help of the API provided by the underlying Serveez application.  The reader will not see any occurrence of the networking API of Guile.</para>
        <para>It implements a protocol called <samp>dnc</samp>.  <samp>dnc</samp> - short for &ldquo;Distributed Number Cruncher&rdquo;.  The Mandelbrot server manages the computation of a graphic visualization of the Mandelbrot set fractal. Each client can connect to the server and ask for something to calculate and is meant to send its result back to the server.  Finally the server produces a bitmap in the XPM format and uses a specified viewer application to bring it onto your screen.</para>
      </subsubsection>

      <subsubsection>
        <title>Configuration</title>
        <para>The server can be setup to manage the calculation of the Mandelbrot set at various locations (rectangular region in the complex plane), in a specific pixel resolution and colour depth.  Moreover you can define the name of the final output file and the viewer application the output file is displayed with.</para>
        <table>
          <tableitem>
            <tableterm><code>start (string, default: -2.0-1.5i)</code></tableterm>
            <item>
              <para>Specifies the upper left corner of the final bitmap in the complex plane.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>end (string, default: +1.1+1.5i)</code></tableterm>
            <item>
              <para>Specifies the lower right corner of the final bitmap in the complex plane.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>x-res (integer, default: 320)</code></tableterm>
            <item>
              <para>The real part pixel resolution.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>y-res (integer, default: 240)</code></tableterm>
            <item>
              <para>The imaginary part pixel resolution.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>colors (integer, default: 256)</code></tableterm>
            <item>
              <para>Number of maximum colours used in the bitmap.  Also determines the maximum iteration depth.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>outfile (string, default: mandel.xpm)</code></tableterm>
            <item>
              <para>When the Mandel server has managed to calculate the whole bitmap it produces an output file in the XPM format.  You can specify the name and location of this output file.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>viewer (string, default: xv)</code></tableterm>
            <item>
              <para>Here you can setup your favourite bitmap viewer application.  It should be able to parse and display the XPM format.</para>
            </item>
          </tableitem>
        </table>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Coserver</nodename>
    <nodenext>Embedding</nodenext>
    <nodeprev>Server</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Coserver</title>
      <menu>
        <menuentry>
          <menunode>What are coservers</menunode>
          <menutitle>What are coservers</menutitle>
          <menucomment>The use of coservers in Serveez</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Writing coservers</menunode>
          <menutitle>Writing coservers</menutitle>
          <menucomment>How to write coservers with Serveez</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Existing coservers</menunode>
          <menutitle>Existing coservers</menutitle>
          <menucomment>What kind of coservers already exist ?</menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>What are coservers</nodename>
    <nodenext>Writing coservers</nodenext>
    <nodeup>Coserver</nodeup>
    <section>
      <title>What are coservers</title>
      <para>If it is necessary to complete blocking tasks in Serveez you have to use coservers.  The actual implementation differs on platforms.  On Unices they are implemented as processes communicating with Serveez over pipes. On Win32 Serveez uses threads and shared memory.</para>
    </section>
  </node>
  <node>
    <nodename>Writing coservers</nodename>
    <nodenext>Existing coservers</nodenext>
    <nodeprev>What are coservers</nodeprev>
    <nodeup>Coserver</nodeup>
    <section>
      <title>Writing coservers</title>
      <subsection>
        <title>Making and configuring preparations</title>
        <para>First you have to change into the <file>src/libserveez/coserver/</file> directory of the Serveez package.  Then edit the <file>Makefile.am</file> and add your header and implementation file to the <code>libcoserver_la_SOURCES</code> variable.</para>
      </subsection>

      <subsection>
        <title>Coserver header file</title>
        <para>You have to declare the coserver handle routine here.  This callback gets the input buffer argument and delivers the output buffer result. Both of these buffers are supposed to be lines separated by a <samp>\n</samp>.</para>
      </subsection>

      <subsection>
        <title>Coserver implementation file</title>
        <para>Here you need to <code>#include "libserveez/coserver/coserver.h"</code> and implement the coserver handle routine declared in the coserver header file. This can be any blocking system call.  On successful completion you can return the result or <code>NULL</code> on errors.  The input and output buffers are plain strings and can have any format with one exception. Because the coservers communicate via a line protocol with Serveez these buffers must not contain <samp>\n</samp> (0x0d).</para>
      </subsection>

      <subsection>
        <title>Make your coserver available in Serveez</title>
        <para>For this you have to edit <file>coserver.h</file> and <file>coserver.c</file> files which are located in the <file>src/libserveez/coserver/</file> directory.  In the header file you have to define a further <code>COSERVER_*</code> id (macro) and set the <code>MAX_COSERVER_TYPES</code> define to the appropriate value.  Then you should define a further <code>svz_coserver_*</code> macro in the same file.</para>
        <para>In <file>coserver.c</file> you have to implement the <code>svz_coserver_*</code> macro. This macro takes three arguments.  The first is always specific to your coserver and is used to create the actual request string.  Then follows the result callback routine, and an optional argument for this callback.  The latter two are simply passed to the <code>svz_coserver_send_request</code> routine.  This routine takes four arguments where the first is the previously defined <code>COSERVER_*</code> id and the second is the input buffer for the coserver handle routine without the trailing <samp>\n</samp>.</para>
        <para>Then you need to add your coserver to the <code>svz_coservertypes</code> array specifying the <code>COSERVER_*</code> id, the coserver description, the coserver handle routine discussed above, the number of coserver instances to be created and an optional initialization routine.</para>
      </subsection>
    </section>
  </node>
  <node>
    <nodename>Existing coservers</nodename>
    <nodeprev>Writing coservers</nodeprev>
    <nodeup>Coserver</nodeup>
    <section>
      <title>Existing coservers</title>
      <subsection>
        <title>Identification (Ident) coserver</title>
        <para>The Identification protocol is briefly documented in RFC1413.  It provides a means to determine the identity of a user of a particular TCP connection.  Given a TCP port number pair, it returns a character string which identifies the owner of that connection on the server's (that is the client's) system.</para>
        <para>This is a connection based application on TCP.  A server listens for TCP connections on TCP port 113 (decimal).  Once a connection is established, the server reads a line of data which specifies the connection of interest.  If it exists, the system dependent user identifier of the connection of interest is sent as the reply.  The server may then either shut down the connection or it may continue to read/respond to more queries.</para>
        <para>The Ident coserver is a client to this kind of service.  For every established network connection you can use this service by calling the appropriate macro from <file>coserver.h</file>.  But you could also use the Ident coserver as is without this macro. The messages from Serveez to this coserver are formatted this way:</para>
        <example xml:space="preserve">Format:
RemoteAddressInDottedDecimals ":" RemotePort ":" LocalPort

Macro:
svz_coserver_ident (sock, MyIdentCallback, sock-&gt;id, sock-&gt;version);</example>
        <para>In this context <code>sock</code> is of type <code>svz_socket_t</code> and <code>MyIdentCallback</code> is something like the following example.  Both of the last two (optional) arguments identify a valid socket structure and <code>user</code> can be <code>NULL</code> if there is no ident daemon running on the foreign machine.  The last two argument within the above macro will be the last two arguments in the callback below.  Thus you will know what kind of data the invocation of the callback is related to.</para>
        <example xml:space="preserve">Callback:
int
MyIdentCallback (char *user, int id, int version)
{
  printf ("Identified user: %s\n", user);
  return 0;
}</example>
      </subsection>

      <subsection>
        <title>Domain Name Server (DNS) coserver</title>
        <para>The DNS coserver is using <code>gethostbyname</code> to translate a given hostname to the associated IP address.  The format of the coserver input line and the macro from <file>coserver.h</file> is shown below.  The IRC server is currently using this coserver for resolving its <samp>?-Lines</samp>. See <xref><xrefnodename>Existing servers</xrefnodename></xref>, for more information.  In the example below <code>realhost</code> is something like <samp>www.lkcc.org</samp>.</para>
        <example xml:space="preserve">Format:
RemoteHostname

Macro:
svz_coserver_dns (realhost, irc_connect_server, ircserver, NULL);

Callback:
int
irc_connect_server (char *ip, irc_server_t *server)
{
  printf ("The ip address is: %s\n", ip);
  return 0;
}</example>
      </subsection>

      <subsection>
        <title>Reverse Domain Name Server (reverse DNS) coserver</title>
        <para>As easily guessed from the name this coserver is just doing the reverse as the DNS coserver.  It translates a given IP address into a hostname using <code>gethostbyaddr</code>.  In the macro the ip address is given as an <code>unsigned long</code> in host byte order.  The Reverse DNS coserver itself takes something like <samp>192.168.2.1</samp>.</para>
        <example xml:space="preserve">Format:
RemoteAddressInDottedDecimals

Macro:
svz_coserver_reverse (addr, MyReverseCallback, sock-&gt;id, sock-&gt;version);

Callback:
int
MyReverseCallback (char *host, int id, int version)
{
  printf ("Hostname is: %s\n", host);
  return 0;
}</example>
      </subsection>
    </section>
  </node>
  <node>
    <nodename>Embedding</nodename>
    <nodenext>Porting issues</nodenext>
    <nodeprev>Coserver</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Embedding</title>
      <para><indexterm index="cp">embedding</indexterm> 
<!-- *-texinfo-*- -->
<!-- This file includes the embedding documentation. -->
<!-- It is included by `serveez.texi'. --> This chapter documents how to embed Serveez into C programs and describes all parts of the API it provides.</para>
      <para>The Serveez core library provides all of the functionality necessary in order to write Internet protocol servers (currently TCP, UDP, ICMP and RAW sockets), pipe servers (connection-oriented via a pair of named pipes) and coservers in a portable way.  All of the included servers are based upon this library, which encapsulates the native network and file system programming interface of different Unices and Windows systems.</para>
      <para>The following sections will give the reader an overview about how to use its core library.</para>
      <menu>
        <menuentry>
          <menunode>Embedding Serveez</menunode>
          <menutitle>Embedding Serveez</menutitle>
          <menucomment>How to embed Serveez into C programs</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Embedding API</menunode>
          <menutitle>Embedding API</menutitle>
          <menucomment>Description of functions and data in the library</menucomment>
        </menuentry>
      </menu>
    </chapter>
  </node>
  <node>
    <nodename>Embedding Serveez</nodename>
    <nodenext>Embedding API</nodenext>
    <nodeup>Embedding</nodeup>
    <section>
      <title>Embedding Serveez</title>
      <para>This chapter deals with embedding the Serveez core library into standalone C/C++ applications and using it in order to write additional servers.</para>
      <menu>
        <menuentry>
          <menunode>Compiling and linking</menunode>
          <menutitle>Compiling and linking</menutitle>
          <menucomment>How to compile and link against the library</menucomment>
        </menuentry>
        <menuentry>
          <menunode>A simple example</menunode>
          <menutitle>A simple example</menutitle>
          <menucomment>A very small example showing the basics</menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>Compiling and linking</nodename>
    <nodenext>A simple example</nodenext>
    <nodeup>Embedding Serveez</nodeup>
    <subsection>
      <title>Compiling and linking</title>
      <para>When you have installed a version of Serveez passing the <file>configure</file> script the <code>$prefix</code> argument, e.g., <samp>./configure --prefix=/usr/local</samp>, you will find the <file>libserveez</file> library in <file>/usr/local/lib</file> and the include headers in <file>/usr/local/include</file>.  If you want to compile a C program using the Serveez API and link against the Serveez core library <code>libserveez</code>, which is <file>libserveez.so</file> for Unices and <file>libserveez.dll</file> for Windows systems, you need to tell the compiler and linker where to find the headers and libraries.</para>
      <para>Most C compilers you can use will understand the following command line options for this purpose.  The <samp>-I</samp> argument specifies the directory of additional include headers, the <samp>-L</samp> argument the direcory to additional libraries and the <samp>-l</samp> argument the library itself to link against.</para>
      <example xml:space="preserve">$ cc test.c -I/usr/local/include -o test -L/usr/local/lib -lserveez</example>
      <para>In order to obtain the correct compiler and linker flag you can also run the <samp>serveez-config</samp> script which gets installed with the Serveez package.  The <samp>serveez-config</samp> script can be invoked with the following set of option.</para>
      <table>
        <tableitem>
          <tableterm><code>-h, --help</code></tableterm>
          <item>
            <para>Displays the usage information.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-v, --version</code></tableterm>
          <item>
            <para>Displays installed Serveez version.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-l, --ldflags</code></tableterm>
          <item>
            <para>Prints the linker flags (libraries to link with including directory information).</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>-c, --cflags</code></tableterm>
          <item>
            <para>Prints the compiler flags to compile with.</para>
          </item>
        </tableitem>
      </table>
    </subsection>
  </node>
  <node>
    <nodename>A simple example</nodename>
    <nodeprev>Compiling and linking</nodeprev>
    <nodeup>Embedding Serveez</nodeup>
    <subsection>
      <title>A simple example</title>
      <para>The following small example shows how to use the Serveez core library to print the list of known network interface.  As you will notice there are three major steps to do: Include the library header with <code>#include &lt;libserveez.h&gt;</code>, initialize the library via <code>svz_boot</code> and finalize it via <code>svz_halt</code>.  In between these calls you can use all of the API functions, variables and macros described in <xref><xrefnodename>Embedding API</xrefnodename></xref>.</para>
      <example xml:space="preserve">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;libserveez.h&gt;

static int
display_ifc (const svz_interface_t *ifc,
             void *closure)
{
  char *addr = svz_inet_ntoa (ifc-&gt;ipaddr);

  if (ifc-&gt;description)
    /* interface with description */
    printf ("%40s: %s\n",
            ifc-&gt;description, addr);
  else
    /* interface with interface # only */
    printf ("%31s%09lu: %s\n",
            "interface # ", ifc-&gt;index, addr);
  return 0;
}

int
main (int argc, char **argv)
{
  /* Library initialization.  */
  svz_boot ("example");

  /* Display a list of interfaces.  */
  printf ("local interfaces:\n");
  svz_foreach_interface (display_ifc, NULL);

  /* Library finalization.  */
  svz_halt ();

  return EXIT_SUCCESS;
}</example>
    </subsection>
  </node>
  <node>
    <nodename>Embedding API</nodename>
    <nodeprev>Embedding Serveez</nodeprev>
    <nodeup>Embedding</nodeup>
    <section>
      <title>Embedding API</title>
      <para>In this chapter the reader will find a short description of each function, global variable and macro provided by the Serveez core library.  The API can either be used to implement a new server or coserver module for use with Serveez or for supporting network and server functionality within your own applications without caring about the details and system programming.</para>
      <para>Most of the Serveez core library interface functionality should be prefixed with <code>svz_</code>.  Small symbols will refer to functions and variables in most cases and big letter symbols refer to macros.</para>
      <para>[FIXME: The subsections are named inconsistently because originally, the API reference was a separate document; on merge, weirdness like &ldquo;Port config funcs&rdquo; was necessary to avoid conflict with the other &ldquo;Port configuration&rdquo; node. &mdash;ttn]</para>
      <menu>
        <menuentry>
          <menunode>Library features</menunode>
          <menutitle>Library features</menutitle>
          <menucomment>A high-level list of what libserveez provides</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Memory management</menunode>
          <menutitle>Memory management</menutitle>
          <menucomment>How memory is managed in Serveez</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Data structures</menunode>
          <menutitle>Data structures</menutitle>
          <menucomment>Data structure helpers</menucomment>
        </menuentry>
        <menuentry>
          <menunode>svz_address_t</menunode>
          <menutitle>svz_address_t</menutitle>
          <menucomment>A data type to hold family plus bits</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Utility functions</menunode>
          <menutitle>Utility functions</menutitle>
          <menucomment>Miscellaneous helper functions</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Core functions</menunode>
          <menutitle>Core functions</menutitle>
          <menucomment>Network core implementations</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Client connections</menunode>
          <menutitle>Client connections</menutitle>
          <menucomment>Client connection functions</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Socket management</menunode>
          <menutitle>Socket management</menutitle>
          <menucomment>Socket management functions</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Coserver functions</menunode>
          <menutitle>Coserver functions</menutitle>
          <menucomment>Coserver interface</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Codec functions</menunode>
          <menutitle>Codec functions</menutitle>
          <menucomment>Codec interface</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Server types</menunode>
          <menutitle>Server types</menutitle>
          <menucomment>Server type implementations</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Server functions</menunode>
          <menutitle>Server functions</menutitle>
          <menucomment>Server object functions</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Port config funcs</menunode>
          <menutitle>Port config funcs</menutitle>
          <menucomment>Port configuration functions</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Booting</menunode>
          <menutitle>Booting</menutitle>
          <menucomment>Configuration and boot functions</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Interface</menunode>
          <menutitle>Interface</menutitle>
          <menucomment>Network interface function implementation</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Windoze</menunode>
          <menutitle>Windoze</menutitle>
          <menucomment>Windows port implementations</menucomment>
        </menuentry>
      </menu>
    </section>
  </node>
  <node>
    <nodename>Library features</nodename>
    <nodenext>Memory management</nodenext>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Library features</title>
      <para>The <file>configure</file> script used to build libserveez takes many options (see <xref><xrefnodename>Build and install</xrefnodename></xref>). Some of these are encapsulated by <code>svz_library_features</code>.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_library_features</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>const char * const *</deftype> 
          <deffunction>svz_library_features</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>count</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return a list (length saved to <var>count</var>) of strings representing the features compiled into libserveez.</para>
        </definitionitem>
      </definition>
      <para role="continues">Here is a table describing the features in detail:</para>
      <table>
        <tableitem>
          <tableterm><code>debug</code></tableterm>
          <item>
            <para>Present when <samp>--enable-debug</samp>.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>heap-counters</code></tableterm>
          <item>
            <para>Present when <samp>--enable-heap-count</samp>.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>interface-list</code></tableterm>
          <item>
            <para>Present when <samp>--enable-iflist</samp>.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>poll</code></tableterm>
          <item>
            <para>Present when <samp>--enable-poll</samp> and you have poll(2).</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>sendfile</code></tableterm>
          <item>
            <para>Present when <samp>--enable-sendfile</samp> and you have sendfile(2) or some workalike (e.g., <code>TransmitFile</code>).</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>log-mutex</code></tableterm>
          <item>
            <para>Present when <code>svz_log</code> uses a mutex around its internal stdio operations, implying that you have some kind of thread capability (perhaps in a separate library).  If your system has <code>fwrite_unlocked</code>, the configure script assumes that <code>fwrite</code> et al already operate in a locked fashion, and disables this.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>flood-protection</code></tableterm>
          <item>
            <para>Present when <samp>--enable-flood</samp>.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm><code>core</code></tableterm>
          <item>
            <para>The networking core.  This is always present.</para>
          </item>
        </tableitem>
      </table>
    </subsection>
  </node>
  <node>
    <nodename>Memory management</nodename>
    <nodenext>Data structures</nodenext>
    <nodeprev>Library features</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Memory management</title>
      <para>The core library of Serveez is able to keep track of the memory an application or part of a program consumes, and also controls itself in the same manner.  When you are using this memory allocator interface you can determine and afterwards remove memory leaks.  This is a very important feature as servers are by nature long-lived programs.</para>
      <para>The three allocator function pointers for <code>malloc</code>, <code>realloc</code> and <code>free</code> make it possible to instruct Serveez to use different kinds of memory, which might be necessary if you want the library to work with shared memory arenas or any other underlying memory API.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_set_mm_funcs</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_set_mm_funcs</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_malloc_func_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>cus_malloc</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_realloc_func_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>cus_realloc</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_free_func_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>cus_free</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Set the internal memory management functions to <var>cus_malloc</var>, <var>cus_realloc</var> and <var>cus_free</var>, respectively. The default internal values are <code>malloc</code>, <code>realloc</code> and <code>free</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_malloc</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void *</deftype> 
          <deffunction>svz_malloc</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>size</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Allocate <var>size</var> bytes of memory and return a pointer to this block.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_calloc</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void *</deftype> 
          <deffunction>svz_calloc</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>size</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Allocate <var>size</var> bytes of memory and return a pointer to this block. The memory is cleared (filled with zeros).</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_realloc</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void *</deftype> 
          <deffunction>svz_realloc</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>ptr</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>size</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Change the size of a block of memory at <var>ptr</var>, previously returned by <code>svz_malloc</code>, to <var>size</var> bytes.  If <var>ptr</var> is <code>NULL</code>, allocate a new block.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_free</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_free</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>ptr</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Free a block of memory at <var>ptr</var>, previously returned by <code>svz_malloc</code> or <code>svz_realloc</code>.  If <var>ptr</var> is <code>NULL</code>, do nothing.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_strdup</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>char *</deftype> 
          <deffunction>svz_strdup</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>src</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Duplicate the given string <var>src</var> if it is not <code>NULL</code> and has non-zero length.  Return the new string.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_get_curalloc</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_get_curalloc</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>to</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Write values to <code>to[0]</code> and <code>to[1]</code> representing the number of currently allocated bytes and blocks, respectively. If Serveez was not configured with <samp>--enable-debug</samp>, the values are always 0.</para>
        </definitionitem>
      </definition>
    </subsection>
  </node>
  <node>
    <nodename>Data structures</nodename>
    <nodenext>svz_address_t</nodenext>
    <nodeprev>Memory management</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Data structures</title>
      <para>Since most servers need to store information about its clients or want to keep track of data during runtime, we include a pair of of useful data structures.  The actual aim was to provide higher level data structures which the C programming language does not support.  Some of the included servers which come with Serveez make extensive use of them.</para>
      <menu>
        <menuentry>
          <menunode>Array</menunode>
          <menutitle>Array</menutitle>
          <menucomment>A growable array implementation</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Hashtable</menunode>
          <menutitle>Hashtable</menutitle>
          <menucomment>Hashtable implementation</menucomment>
        </menuentry>
      </menu>
    </subsection>
  </node>
  <node>
    <nodename>Array</nodename>
    <nodenext>Hashtable</nodenext>
    <nodeup>Data structures</nodeup>
    <subsubsection>
      <title>Array</title>
      <para>The array data structure is a simple array implementation.  Each array has a size and capacity.  The array indices range from zero to the array's size minus one.  You can put any kind of data into this array which fits into the size of a pointer.  The array grows automatically if necessary.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_array_create</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_array_t *</deftype> 
          <deffunction>svz_array_create</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>capacity</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_free_func_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>destroy</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Create a new array with the initial capacity <var>capacity</var> and return a pointer to it.  If <var>capacity</var> is zero it defaults to some value. If <var>destroy</var> is non-<code>NULL</code>, <code>svz_array_destroy</code> calls that function (typically used to free dynamically allocated memory). For example, if the array contains data allocated by <code>svz_malloc</code>, <var>destroy</var> should be specified as <code>svz_free</code>.  If the array contains data which should not be released, <var>destroy</var> should be <code>NULL</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_array_destroy</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_array_destroy</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_array_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>array</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Completely destroy the array <var>array</var>.  The <var>array</var> handle is invalid afterwards.  The routine runs the <var>destroy</var> callback for each element of the array.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_array_get</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void *</deftype> 
          <deffunction>svz_array_get</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_array_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>array</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>index</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the array element at the position <var>index</var> of the array <var>array</var> if the index is within the array range.  Return <code>NULL</code> if not.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_array_set</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void *</deftype> 
          <deffunction>svz_array_set</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_array_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>array</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>index</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>value</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Replace the array element at the position <var>index</var> of the array <var>array</var> with the value <var>value</var> and return the previous value at this index.  Return <code>NULL</code> and do nothing if <var>array</var> is <code>NULL</code> or the <var>index</var> is out of the array range.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_array_add</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_array_add</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_array_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>array</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>value</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Append the value <var>value</var> at the end of the array <var>array</var>. Do nothing if <var>array</var> is <code>NULL</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_array_del</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void *</deftype> 
          <deffunction>svz_array_del</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_array_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>array</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>index</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Remove the array element at the position <var>index</var> of the array <var>array</var>.  Return its previous value or <code>NULL</code> if the index is out of the array's range.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_array_size</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>size_t</deftype> 
          <deffunction>svz_array_size</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_array_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>array</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the current size of <var>array</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_array_foreach</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>svz_array_foreach</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>array</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>value</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>i</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Expand into a <code>for</code>-statement header, for iterating over <var>array</var>.  On each cycle, <var>value</var> is assigned to successive elements of <var>array</var>, and <var>i</var> the element's position.</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>Hashtable</nodename>
    <nodeprev>Array</nodeprev>
    <nodeup>Data structures</nodeup>
    <subsubsection>
      <title>Hashtable</title>
      <para>A hashtable associates keys of arbitrary size and content with values. This data structure is also called associative array sometimes because you use keys in order to access values instead of numbers.  You cannot store two values associated with the same key.  The values can have any simple C types like integers or pointers.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_hash_create</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_hash_t *</deftype> 
          <deffunction>svz_hash_create</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>size</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_free_func_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>destroy</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Create a new hash table with an initial capacity <var>size</var>.  Return a non-zero pointer to the newly created hash.  The size is calculated down to a binary value.  The <var>destroy</var> callback specifies an element destruction callback for use by <code>svz_hash_clear</code> and <code>svz_hash_destroy</code> for each value.  If no such operation should be performed the argument must be <code>NULL</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_hash_configure</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_hash_t *</deftype> 
          <deffunction>svz_hash_configure</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_hash_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>hash</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defdelimiter>(</defdelimiter>
          <defparamtype>*</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>keylen</defparamtype>
          <defdelimiter>)</defdelimiter>
          <defparam>&#xa0;</defparam>
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defdelimiter>)</defdelimiter>
          <defparam>&#xa0;</defparam>
          <defparam><var></var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>unsigned</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>long</defparamtype>
          <defparam>&#xa0;</defparam>
          <defdelimiter>(</defdelimiter>
          <defparamtype>*</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>code</defparamtype>
          <defdelimiter>)</defdelimiter>
          <defparam>&#xa0;</defparam>
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defdelimiter>)</defdelimiter>
          <defparam>&#xa0;</defparam>
          <defparam><var></var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defdelimiter>(</defdelimiter>
          <defparamtype>*</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>equals</defparamtype>
          <defdelimiter>)</defdelimiter>
          <defparam>&#xa0;</defparam>
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var></var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var></var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Set the internal <var>keylen</var>, <var>code</var> and and <var>equals</var> functions for hash table <var>hash</var>.  Return <var>hash</var>.</para>
          <para><var>keylen</var> takes <code>const char *data</code> and returns <code>size_t</code>, the number of bytes in <var>data</var> representing the key.</para>
          <para><var>code</var> takes <code>const char *data</code> and returns <code>unsigned long</code>.</para>
          <para><var>equals</var> takes <code>const char *data1, const char *data2</code> and returns <code>int</code>, which should be non-zero if equal.</para>
          <para>As a special case, a <code>NULL</code> value means don't set that function, leaving it to its default value.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_hash_destroy</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_hash_destroy</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_hash_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>hash</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Destroy the existing hash table <var>hash</var>, <code>svz_free</code>ing all keys within the hash, the hash table and the hash itself. If a non-<code>NULL</code> element destruction callback was specified to <code>svz_hash_create</code>, that function is called on each value.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_hash_delete</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void *</deftype> 
          <deffunction>svz_hash_delete</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_hash_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>hash</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>key</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Delete an existing entry accessed via a <var>key</var> from the hash table <var>hash</var>.  Return <code>NULL</code> if there is no such key, otherwise the previous value.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_hash_put</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void *</deftype> 
          <deffunction>svz_hash_put</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_hash_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>hash</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>key</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>value</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Add a new element consisting of <var>key</var> and <var>value</var> to <var>hash</var>. When <var>key</var> already exists, replace and return the old value. <strong>Note</strong>: This is sometimes the source of memory leaks.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_hash_get</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void *</deftype> 
          <deffunction>svz_hash_get</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>svz_hash_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>hash</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>key</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the value associated with <var>key</var> in the hash table <var>hash</var>, or <code>NULL</code> if there is no such key.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_hash_foreach</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_hash_foreach</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_hash_do_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>func</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_hash_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>hash</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>closure</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Iterate <var>func</var> over each key/value pair in <var>hash</var>. <var>func</var> is called with three <code>void *</code> args: the key, the value and the opaque (to <code>svz_hash_foreach</code>) <var>closure</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_hash_size</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>size_t</deftype> 
          <deffunction>svz_hash_size</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>svz_hash_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>hash</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the number of keys in the hash table <var>hash</var>. If <var>hash</var> is <code>NULL</code>, return zero.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_hash_contains</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>char *</deftype> 
          <deffunction>svz_hash_contains</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>svz_hash_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>hash</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>value</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the key associated with <var>value</var> in the hash table <var>hash</var>, or <code>NULL</code> if there is no such value.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_hash_exists</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_hash_exists</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>svz_hash_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>hash</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>key</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return non-zero if <code>key</code> is stored within the hash table <code>hash</code>, otherwise zero. This function is useful when you cannot tell whether the return value of <code>svz_hash_get</code> (<code>== NULL</code>) indicates a real value in the hash or a non-existing hash key.</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>svz_address_t</nodename>
    <nodenext>Utility functions</nodenext>
    <nodeprev>Data structures</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>svz_address_t</title>
      <para>A network address comprises a <dfn>family</dfn>, such as <code>AF_INET</code> (also known as IPv4), and its <dfn>bits</dfn> in network byte order, such as the bytes 127, 0, 0 and 1 (also known as the <dfn>IPv4 loopback address</dfn>).  Many libserveez functions take <code>svz_address_t *</code>.</para>
      <para><strong>Please note</strong>: Although <code>svz_address_t</code> supports<footnote><para>that is, if your system supports it</para></footnote> IPv6, the rest of libserveez it does not (yet).  This means you can freely create and manipulate address objects with the functions described in this section, but any attempt to pass to the rest of libserveez an address with a <var>family</var> other than <code>AF_INET</code> will immediately abort the process.  When full IPv6 support is in place, this blurb will be deleted and the list returned by <code>svz_library_features</code> will include an appropriate indicator (see <xref><xrefnodename>Library features</xrefnodename></xref>).</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_address_make</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_address_t *</deftype> 
          <deffunction>svz_address_make</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>family</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>bits</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return an address object to hold an address in <var>family</var>, represented by <var>bits</var>.  <var>family</var> must be one of:</para>
          <table>
            <tableitem>
              <tableterm><code>AF_INET</code></tableterm>
              <item>
                <para>An IPv4 address; <var>bits</var> is <code>in_addr_t *</code>.</para>
              </item>
            </tableitem>
            <tableitem>
              <tableterm><code>AF_INET6</code></tableterm>
              <item>
                <para>(if supported by your system) An IPv6 address; <var>bits</var> is <code>struct in6_addr *</code>.</para>
              </item>
            </tableitem>
          </table>
          <para>The <var>bits</var> are expected in network byte order. If there are problems, return <code>NULL</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_address_family</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_address_family</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>svz_address_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>addr</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the address family of <var>addr</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_address_to</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_address_to</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>dest</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>svz_address_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>addr</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Copy the address bits out of <var>addr</var> to <var>dest</var>. Return 0 on success, -1 if either <var>addr</var> or <var>dest</var> is <code>NULL</code>, or the <var>addr</var> family is <code>AF_UNSPEC</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_address_same</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_address_same</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>svz_address_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>a</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>svz_address_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>b</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return 1 if <var>a</var> and <var>b</var> represent the same address (identical family and bits), otherwise 0.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_pp_address</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>const char *</deftype> 
          <deffunction>svz_pp_address</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>buf</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>size</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>svz_address_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>addr</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Format an external representation of <var>addr</var> into <var>buf</var>, of <var>size</var> bytes.  The format depends on the family of <var>addr</var>.  For IPv4, this is numbers-and-dots.  For IPv6, it is &ldquo;the most appropriate IPv6 network address format for <var>addr</var>&rdquo;, according to the manpage of <code>inet_ntop</code>, the function that actually does the work.</para>
          <para>If <var>buf</var> or <var>addr</var> is <code>NULL</code>, or <var>size</var> is not big enough, return <code>NULL</code>.  Otherwise, return <var>buf</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_pp_addr_port</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>const char *</deftype> 
          <deffunction>svz_pp_addr_port</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>buf</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>size</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>svz_address_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>addr</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>in_port_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>port</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Format an external representation of <var>addr</var> and <var>port</var> (in network byte order) into <var>buf</var>, of <var>size</var> bytes. The address <dfn>xrep</dfn> (external representation) is done by <code>svz_pp_address</code>, q.v.  The rest of the formatting depends on the <var>addr</var> family.</para>
          <multitable>
            <columnfraction>40</columnfraction>
            <columnfraction>60</columnfraction>
            <thead>
              <row>
                <entry>Family</entry>
                <entry>Formatting</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><code>AF_INET</code> (IPv4)</entry>
                <entry><code><var>xrep</var>:<var>port</var></code></entry>
              </row>
              <row>
                <entry><code>AF_INET6</code> (IPv6)</entry>
                <entry><code>[<var>xrep</var>]:<var>port</var></code></entry>
              </row>
            </tbody>
          </multitable>
          <para>If <var>buf</var> or <var>addr</var> is <code>NULL</code>, or <var>size</var> is not big enough, return <code>NULL</code>.  Otherwise, return <var>buf</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_address_copy</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_address_t *</deftype> 
          <deffunction>svz_address_copy</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>svz_address_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>addr</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return a copy of <var>addr</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_SET_ADDR</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_SET_ADDR</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>place</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>family</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>bits</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Expand to a series of commands.  First, if <var>place</var> is non-<code>NULL</code>, then <code>svz_free</code> it.  Next, assign to <var>place</var> a new address object made by calling <code>svz_address_make</code> with <var>family</var> and <var>bits</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_PP_ADDR</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_PP_ADDR</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>buf</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>addr</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Expand to a call to <code>svz_pp_address</code>, passing it <var>buf</var> and <code>sizeof <var>buf</var></code>, in addition to <var>addr</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_PP_ADDR_PORT</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_PP_ADDR_PORT</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>buf</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>addr</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>port</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Expand to a call to <code>svz_pp_addr_port</code>, passing it <var>buf</var> and <code>sizeof <var>buf</var></code>, in addition to <var>addr</var> and <var>port</var>.</para>
        </definitionitem>
      </definition>
    </subsection>
  </node>
  <node>
    <nodename>Utility functions</nodename>
    <nodenext>Core functions</nodenext>
    <nodeprev>svz_address_t</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Utility functions</title>
      <para>Within this section you will find some miscellaneous functionality and left overs of the C API.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_log</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_log</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>level</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>format</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>&dots;</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Print a message to the log system.  <var>level</var> specifies the prefix.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_log_setfile</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_log_setfile</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>FILE</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>file</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Set the file stream <var>file</var> to the log file all messages are printed to.  Can also be <code>stdout</code> or <code>stderr</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_hexdump</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_hexdump</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>FILE</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>out</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>action</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>from</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>buffer</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>len</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>max</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Dump <var>buffer</var> with the length <var>len</var> to the file stream <var>out</var>. Display description <var>action</var> along with origin and size info first, followed by the hexadecimal text representation. Stop output at either <var>max</var> or <var>len</var> (if <var>max</var> is zero) bytes. <var>from</var> is a numerical identifier of the buffers creator.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_itoa</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>char *</deftype> 
          <deffunction>svz_itoa</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>unsigned</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>i</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Convert an unsigned integer to its decimal string representation, returning a pointer to an internal buffer.  (You should copy the result.)</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_atoi</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>unsigned int</deftype> 
          <deffunction>svz_atoi</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>str</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Convert string <var>str</var> in decimal format to an unsigned integer. Stop conversion on any invalid characters.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_getcwd</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>char *</deftype> 
          <deffunction>svz_getcwd</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the current working directory in a newly allocated string. (You should <code>svz_free</code> it when done.)</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_openfiles</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_openfiles</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>max_sockets</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Check for the current and maximum limit of open files of the current process and try to set the limit to <var>max_sockets</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_time</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>char *</deftype> 
          <deffunction>svz_time</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>long</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>t</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Transform the given binary data <var>t</var> (UTC time) to an ASCII time text representation without any trailing characters.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_tolower</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>char *</deftype> 
          <deffunction>svz_tolower</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>str</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Convert the given string <var>str</var> to lower case text representation.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sys_version</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>char *</deftype> 
          <deffunction>svz_sys_version</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return a statically-allocated string describing some operating system version details.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_socket_unavailable_error_p</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_socket_unavailable_error_p</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return 1 if there was a "socket unavailable" error recently, 0 otherwise.  This checks <code>svz_errno</code> against <code>WSAEWOULDBLOCK</code> (woe32) or <code>EAGAIN</code> (Unix).</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sys_strerror</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>const char *</deftype> 
          <deffunction>svz_sys_strerror</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return a string describing the most recent system error.</para>
        </definitionitem>
      </definition>
      <para>The next two functions log (with <code>SVZ_LOG_ERROR</code>) the current <dfn>system error</dfn> or <dfn>network error</dfn>, forming the prefix of the message using <var>fmt</var> and <var>args</var>.  This formatted prefix cannot exceed 255 bytes.  The rest of the message comprises: colon, space, error description, newline.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_log_sys_error</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_log_sys_error</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>fmt</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>&dots;</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Log the current <dfn>system error</dfn>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_log_net_error</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_log_net_error</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>fmt</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>&dots;</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Log the current <dfn>network error</dfn>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_mingw_at_least_nt4_p</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_mingw_at_least_nt4_p</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return 1 if running MinGW (Windows) NT4x or later, otherwise 0.</para>
        </definitionitem>
      </definition>
    </subsection>
  </node>
  <node>
    <nodename>Core functions</nodename>
    <nodenext>Client connections</nodenext>
    <nodeprev>Utility functions</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Networking and other low level functions</title>
      <para>This chapter deals with the basic networking and file systems functions. It encapsulates systems calls in a portable manner.  These functions should behave identically on Windows and Unices.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_inet_ntoa</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>char *</deftype> 
          <deffunction>svz_inet_ntoa</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>in_addr_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>ip</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Convert <var>ip</var>, an address in network byte order, to its dotted decimal representation, returning a pointer to a statically allocated buffer.  (You should copy the result.)</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_inet_aton</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_inet_aton</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>str</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>struct</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>sockaddr_in</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>addr</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Convert the Internet host address <var>str</var> from the standard numbers-and-dots notation into binary data and store it in the structure that <var>addr</var> points to. Return zero if the address is valid, nonzero otherwise. As a special case, if <var>str</var> is <samp>*</samp> (asterisk), store <code>INADDR_ANY</code> in <var>addr</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_closesocket</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_closesocket</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_t_socket</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>sockfd</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Close the socket <var>sock</var>. Return 0 if successful, -1 otherwise.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_fd_cloexec</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_fd_cloexec</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>fd</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Set the close-on-exec flag of the given file descriptor <var>fd</var> and return zero on success.  Otherwise return non-zero.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_tcp_cork</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_tcp_cork</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_t_socket</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>fd</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>set</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Enable or disable the <code>TCP_CORK</code> socket option of the socket <var>fd</var>.  This is useful for performance reasons when using <code>sendfile</code> with any prepending or trailing data not inside the file to transmit.  Return zero on success, otherwise non-zero.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_tcp_nodelay</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_tcp_nodelay</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_t_socket</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>fd</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>set</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>old</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Enable or disable the <code>TCP_NODELAY</code> setting for the socket <var>fd</var> depending on the flag <var>set</var>, effectively enabling or disabling the Nagle algorithm. This means that packets are always sent as soon as possible and no unnecessary delays are introduced. If <var>old</var> is not <code>NULL</code>, save the old setting there. Return zero on success, otherwise non-zero.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sendfile</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_sendfile</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>out_fd</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>in_fd</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>off_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>offset</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>count</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Transmit data between one file descriptor and another where <var>in_fd</var> is the source and <var>out_fd</var> the destination. The <var>offset</var> argument is a pointer to a variable holding the input file pointer position from which reading starts. On return, the <var>offset</var> variable will be set to the offset of the byte following the last byte that was read. <var>count</var> is the number of bytes to copy. Return the number of bytes actually read/written or -1 on errors.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_open</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_open</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>file</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>flags</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>mode_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>mode</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Open the filename <var>file</var> and convert it into a file handle.  The given <var>flags</var> specify the access mode and the <var>mode</var> argument the permissions if the <code>O_CREAT</code> flag is set.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_close</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_close</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>fd</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Close the given file handle <var>fd</var>.  Return -1 on errors.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_fstat</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_fstat</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>fd</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>struct</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>stat</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>buf</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return information about the specified file associated with the file descriptor <var>fd</var> returned by <code>svz_open</code>.  Store available information in the stat buffer <var>buf</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_fopen</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>FILE *</deftype> 
          <deffunction>svz_fopen</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>file</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>mode</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Open the file whose name is the string pointed to by <var>file</var> and associate a stream with it.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_fclose</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_fclose</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>FILE</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>f</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Dissociate the named stream <var>f</var> from its underlying file.</para>
        </definitionitem>
      </definition>
    </subsection>
  </node>
  <node>
    <nodename>Client connections</nodename>
    <nodenext>Socket management</nodenext>
    <nodeprev>Core functions</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Client connections</title>
      <para>Serveez tries to handle all kinds of Internet protocols like TCP (connection oriented), UDP, ICMP and RAW (packet oriented) and communication across named pipes (also connection oriented) in the same way.  Therefore it uses a structure called <code>svz_socket_t</code> which is the abstraction of any kind of communication endpoint (can be client or server or both together).</para>
      <menu>
        <menuentry>
          <menunode>TCP sockets</menunode>
          <menutitle>TCP sockets</menutitle>
          <menucomment>TCP socket functions</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Pipe connections</menunode>
          <menutitle>Pipe connections</menutitle>
          <menucomment>Named and anonymous pipe functions</menucomment>
        </menuentry>
        <menuentry>
          <menunode>UDP sockets</menunode>
          <menutitle>UDP sockets</menutitle>
          <menucomment>UDP socket functions</menucomment>
        </menuentry>
        <menuentry>
          <menunode>ICMP sockets</menunode>
          <menutitle>ICMP sockets</menutitle>
          <menucomment>ICMP socket functions</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Raw sockets</menunode>
          <menutitle>Raw sockets</menutitle>
          <menucomment>Raw socket functions</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Passthrough connections</menunode>
          <menutitle>Passthrough connections</menutitle>
          <menucomment>Passthrough connections to child processes</menucomment>
        </menuentry>
      </menu>
    </subsection>
  </node>
  <node>
    <nodename>TCP sockets</nodename>
    <nodenext>Pipe connections</nodenext>
    <nodeup>Client connections</nodeup>
    <subsubsection>
      <title>TCP sockets</title>
      <para>TCP sockets provide a reliable, stream oriented, full duplex connection between two sockets on top of the Internet Protocol (IP).  TCP guarantees that the data arrives in order and retransmits lost packets. It generates and checks a per packet checksum to catch transmission errors.  TCP does not preserve record boundaries.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_tcp_connect</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_socket_t *</deftype> 
          <deffunction>svz_tcp_connect</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_address_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>host</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>in_port_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>port</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Create a TCP connection to host <var>host</var> and set the socket descriptor in structure <var>sock</var> to the resulting socket.  Return <code>NULL</code> on errors.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_tcp_read_socket</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_tcp_read_socket</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Read all data from <var>sock</var> and call the <code>check_request</code> function for the socket, if set.  Return -1 if the socket has died, zero otherwise.</para>
          <para>This is the default function for reading from <var>sock</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_tcp_send_oob</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_tcp_send_oob</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>If the underlying operating system supports urgent data (out-of-band) in TCP streams, try to send the byte in <code>sock-&gt;oob</code> through the socket structure <var>sock</var> as out-of-band data.  Return zero on success and -1 otherwise (also if urgent data is not supported).</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>Pipe connections</nodename>
    <nodenext>UDP sockets</nodenext>
    <nodeprev>TCP sockets</nodeprev>
    <nodeup>Client connections</nodeup>
    <subsubsection>
      <title>Pipe connections</title>
      <para>The pipe implementation supports both named and anonymous pipes.  Pipe servers are implemented as listeners on a file system FIFO on Unices or &ldquo;Named Pipes&rdquo; on Windows (can be shared over a Windows network).</para>
      <para>A FIFO special file is similar to a pipe, except that it is created in a different way.  Instead of being an anonymous communications channel, a FIFO special file is entered into the file system.</para>
      <para>Once you have created a FIFO special file in this way, any process can open it for reading or writing, in the same way as an ordinary file. However, it has to be open at both ends simultaneously before you can proceed to do any input or output operations on it.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_pipe_create</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_socket_t *</deftype> 
          <deffunction>svz_pipe_create</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_t_handle</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>recv_fd</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_t_handle</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>send_fd</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Create a socket structure containing both the pipe descriptors <var>recv_fd</var> and <var>send_fd</var>.  Return <code>NULL</code> on errors.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_pipe_create_pair</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_pipe_create_pair</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_t_handle</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>pipe_desc</var></defparam>
          <defdelimiter>[</defdelimiter>
          <defparamtype>2</defparamtype>
          <defdelimiter>]</defdelimiter>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Create a (non blocking) pair of pipes.  This differs in Win32 and Unices.  Return a non-zero value on errors.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_pipe_connect</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_socket_t *</deftype> 
          <deffunction>svz_pipe_connect</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_pipe_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>recv</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_pipe_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>send</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Create a pipe connection socket structure to the pair of named pipes <var>recv</var> and <var>send</var>.  Return <code>NULL</code> on errors.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_invalid_handle_p</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_invalid_handle_p</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_t_handle</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>handle</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return 1 if <var>handle</var> is invalid, otherwise 0.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_invalidate_handle</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_invalidate_handle</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_t_handle</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>href</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Invalidate the handle pointed at by <var>href</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_closehandle</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_closehandle</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_t_handle</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>handle</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Close <var>handle</var>. Return 0 if successful, -1 otherwise.</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>UDP sockets</nodename>
    <nodenext>ICMP sockets</nodenext>
    <nodeprev>Pipe connections</nodeprev>
    <nodeup>Client connections</nodeup>
    <subsubsection>
      <title>UDP sockets</title>
      <para>The UDP sockets implement a connectionless, unreliable datagram packet service.  Packets may be reordered or duplicated before they arrive. UDP generates and checks checksums to catch transmission errors.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_udp_connect</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_socket_t *</deftype> 
          <deffunction>svz_udp_connect</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_address_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>host</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>in_port_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>port</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Create a UDP connection to <var>host</var> at <var>port</var> and set the socket descriptor in structure <var>sock</var> to the resulting socket.  Return a <code>NULL</code> value on errors.</para>
          <para>This function can be used for port bouncing.  If you assign the <code>handle_request</code> callback to something server specific and the <var>cfg</var> field of the server's configuration to the returned socket structure, this socket is able to handle a dedicated UDP connection to some other UDP server.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_udp_write</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_udp_write</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>buf</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>length</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Write <var>buf</var> into the send queue of the UDP socket <var>sock</var>.  If <var>length</var> argument supersedes the maximum length for UDP messages it is split into smaller packets.</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>ICMP sockets</nodename>
    <nodenext>Raw sockets</nodenext>
    <nodeprev>UDP sockets</nodeprev>
    <nodeup>Client connections</nodeup>
    <subsubsection>
      <title>ICMP sockets</title>
      <para>The ICMP socket implementation is currently used in the tunnel server which comes with the Serveez package.  It implements a user protocol receiving and sending ICMP packets by opening a raw socket with the protocol <code>IPPROTO_ICMP</code>.</para>
      <para>The types of ICMP packets passed to the socket can be filtered using the <code>ICMP_FILTER</code> socket option (or by software as done here).  ICMP packets are always processed by the kernel too, even when passed to a user socket.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_icmp_connect</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_socket_t *</deftype> 
          <deffunction>svz_icmp_connect</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_address_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>host</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>in_port_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>port</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>uint8_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>type</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Create an ICMP socket for receiving and sending. Return <code>NULL</code> on errors, otherwise an enqueued socket structure.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_icmp_send_control</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_icmp_send_control</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>uint8_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>type</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>&ldquo;If you are calling this function we will send an empty ICMP packet signaling that this connection is going down soon.&rdquo; [ttn sez: huh?]</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_icmp_write</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_icmp_write</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>buf</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>length</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Send <var>buf</var> with length <var>length</var> via this ICMP socket <var>sock</var>. If <var>length</var> supersedes the maximum ICMP message size the buffer is split into smaller packets.</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>Raw sockets</nodename>
    <nodenext>Passthrough connections</nodenext>
    <nodeprev>ICMP sockets</nodeprev>
    <nodeup>Client connections</nodeup>
    <subsubsection>
      <title>Raw sockets</title>
      <para>A raw socket receives or sends the raw datagram not including link-level headers.  It is currently used by the ICMP socket implementation of the core library.  The IPv4 layer generates an IP header when sending a packet unless the <code>IP_HDRINCL</code> socket option is enabled on the socket.  When it is enabled, the packet must contain an IP header.  For receiving the IP header is always included in the packet.</para>
      <para>Only processes with an effective userid of zero (Administrator or root) or the <code>CAP_NET_RAW</code> capability are allowed to open raw sockets. All packets or errors matching the protocol number specified for the raw socket are passed to this socket.  A protocol of <code>IPPROTO_RAW</code> implies enabled <code>IP_HDRINCL</code> and receives all IP protocols. Sending is not allowed.</para>
      <para>[FIXME: All funcs internalized!  Write something else here!]</para>
    </subsubsection>
  </node>
  <node>
    <nodename>Passthrough connections</nodename>
    <nodeprev>Raw sockets</nodeprev>
    <nodeup>Client connections</nodeup>
    <subsubsection>
      <title>Passthrough connections</title>
      <para>The functions described in this section allow you to pass through client connections to the standard input (stdin) and standard output (stdout) of external programs.  Some of the routines deal with the management of program environments.  Basically, there are two methods for passing through a duplex connection: the Unix'ish <code>fork</code> and <code>exec</code> method and the shuffle method where the main process keeps control over the communication on the original duplex connection and passes this data through two pairs of pipes, or yet another socket connection, to the child process.  All of the three method are implemented calling them <code>SVZ_PROCESS_FORK</code>, <code>SVZ_PROCESS_SHUFFLE_PIPE</code> and <code>SVZ_PROCESS_SHUFFLE_SOCK</code>.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_process</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_sock_process</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>bin</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>dir</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>**</defparamtype>
          <defparam><var>argv</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_envblock_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>envp</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>forkp</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>user</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Start a new program <var>bin</var>, a fully qualified executable filename, passing the socket or pipe descriptor(s) in the socket structure <var>sock</var> to its stdin and stdout.</para>
          <para>If <var>dir</var> is non-<code>NULL</code>, it specifies the working directory of the new process.</para>
          <para>The program arguments and the environment of the new process are taken from <var>argv</var> and <var>envp</var>.  Normally <code>argv[0]</code> should be set to the program's name.  If <code>NULL</code>, it defaults to <var>bin</var>.</para>
          <para>The <var>forkp</var> argument is a flag that controls the passthrough method. If non-zero, pipe descriptors or the socket descriptor are passed to the child process directly through <code>fork</code> and <code>exec</code>.  Otherwise, socket transactions are passed via a pair or pipes or sockets (depending on whether or not the system provides <code>socketpair</code>).</para>
          <para>You can pass the user and group identifications in the format <samp>user[.group]</samp> (group is optional), as <code>SVZ_PROCESS_NONE</code> or <code>SVZ_PROCESS_OWNER</code> in the <var>user</var> argument.  This specifies the permissions of the new child process.  If <code>SVZ_PROCESS_OWNER</code> is passed the permissions are set to the executable file <var>bin</var> owner; <code>SVZ_PROCESS_NONE</code> does not change user or group.</para>
          <para>Return the new process id on success, -1 on failure.</para>
        </definitionitem>
      </definition>
      <para><strong>Please note</strong>: On M$-Windows platforms it is not possible to pass a socket connection to stdin/stdout of a child process.  That is why this function creates an inheritable version of the socket and puts the socket handle number into the environment variables <code>SEND_HANDLE</code> and <code>RECV_HANDLE</code>.  A spawned child process can use these handles as if they were self-created.  After calling <code>WSAStartup</code> the child process can <code>send</code> and <code>recv</code> as usual.</para>
      <para>Relatedly, Windoze does not use <code>SIGCHLD</code> to inform the parent when a child dies, so for that platform, you should use the next function (which is not otherwise available):</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_mingw_child_dead_p</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_mingw_child_dead_p</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>prefix</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_t_handle</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>pid</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Check child pointed at by <var>pid</var> by waiting a bit. If it is dead, close and invalidate its handle, and return 1. Otherwise, return 0. <var>prefix</var> is for error messages; it should be either the empty string, or a string ending in colon and space.</para>
        </definitionitem>
      </definition>
      <para>On non-Windoze, this is the function you want to use:</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_most_recent_dead_child_p</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_most_recent_dead_child_p</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_t_handle</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>pid</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return 1 if a child process <var>pid</var> died recently, updating other internal state by side effect.  Otherwise, return 0.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_envblock_setup</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_envblock_setup</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Set up internal tables for environment block wrangling.</para>
          <para>This function must be called once after <code>svz_boot</code> so that subsequent functions (like <code>svz_envblock_default</code>) can work correctly.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_envblock_create</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_envblock_t *</deftype> 
          <deffunction>svz_envblock_create</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Create and return a fresh environment block, useful for passing to <code>svz_envblock_default</code> and <code>svz_envblock_add</code>.  Its size is initially set to zero.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_envblock_default</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_envblock_default</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_envblock_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>env</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Fill environment block <var>env</var> with the environment variables from the current process, replacing its current contents (if any).</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_envblock_add</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_envblock_add</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_envblock_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>env</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>format</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>&dots;</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Insert a new environment variable into environment block <var>env</var>.  The <var>format</var> argument is a <code>printf</code>-style format string describing how to format the optional arguments.  You specify environment variables in the <samp>VAR=VALUE</samp> format.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_envblock_destroy</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_envblock_destroy</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_envblock_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>env</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Destroy environment block <var>env</var> completely.  Afterwards, <var>env</var> is invalid and should therefore not be further referenced.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_envblock_get</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void *</deftype> 
          <deffunction>svz_envblock_get</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_envblock_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>env</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Convert environment block <var>env</var> into something which can be passed to <code>execve</code> (Unix) or <code>CreateProcess</code> (Windows).  Additionally, under Windows, sort the environment block.</para>
          <para>(Unfortunately the layout of environment blocks in Unices and Windows differ.  On Unices you have a NULL terminated array of character strings (i.e., <code>char **</code>) and on Windows systems you have a simple character string containing the environment variables in the format <samp>VAR=VALUE</samp> each separated by a zero byte (i.e., <code>char *</code>).  The end of the list is indicated by a further zero byte.)</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>Socket management</nodename>
    <nodenext>Coserver functions</nodenext>
    <nodeprev>Client connections</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Socket management</title>
      <para>The functions described in this section deal with the creation, destruction and other simple operations on socket structures called <code>svz_socket_t</code>.  See the description of each function for details on which kind of socket it can handle and what they are for.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_nconnections</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_sock_nconnections</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the number of currently connected sockets.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_write</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_sock_write</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>buf</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>len</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Write <var>len</var> bytes from the memory location pointed to by <var>buf</var> to the output buffer of the socket <var>sock</var>.  Also try to flush the buffer to the socket of <var>sock</var> if possible.  Return a non-zero value on error, which normally means a buffer overflow.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_printf</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_sock_printf</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>fmt</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>&dots;</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Print a formatted string on the socket <var>sock</var>.  <var>fmt</var> is the <code>printf</code>-style format string, which describes how to format the optional arguments.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_resize_buffers</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_sock_resize_buffers</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>send_buf_size</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>recv_buf_size</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Resize the send and receive buffers for the socket <var>sock</var>. <var>send_buf_size</var> is the new size for the send buffer, <var>recv_buf_size</var> for the receive buffer.  Note that data may be lost when the buffers shrink.  For a new buffer size of 0 the buffer is freed and the pointer set to NULL.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_check_request</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_sock_check_request</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Check for the kind of packet delimiter within <var>sock</var> and and assign one of the default <code>check_request</code> routines (one or more byte delimiters or a fixed size).</para>
          <para>Afterwards this function will never ever be called again because the callback gets overwritten here.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_reduce_recv</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_sock_reduce_recv</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>len</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Shorten the receive buffer of <var>sock</var> by <var>len</var> bytes.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_reduce_send</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_sock_reduce_send</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>len</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Reduce the send buffer of <var>sock</var> by <var>len</var> bytes.</para>
        </definitionitem>
      </definition>
    </subsection>
  </node>
  <node>
    <nodename>Coserver functions</nodename>
    <nodenext>Codec functions</nodenext>
    <nodeprev>Socket management</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Coserver functions</title>
      <para>This section describes the internal coserver interface of Serveez. Coservers are helper processes meant to perform blocking tasks.  This is necessary because Serveez itself is single threaded.  Each coserver is connected via a pair of pipes to the main thread of Serveez communicating over a simple text line protocol.  Each request/response is separated by a newline character.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_foreach_coserver</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_foreach_coserver</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_coserver_do_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>func</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>closure</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Call <var>func</var> for each coserver, passing additionally the second arg <var>closure</var>.  If <var>func</var> returns a negative value, return immediately with that value (breaking out of the loop), otherwise, return 0.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_coserver_check</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_coserver_check</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Under woe32 check if there was any response from an active coserver. Moreover keep the coserver threads/processes alive.  If one of the coservers dies due to buffer overrun or might be overloaded, start a new one.</para>
          <para>Call this function whenever there is time, e.g., within the timeout of the <code>select</code> system call.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_coserver_destroy</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_coserver_destroy</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>type</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Destroy specific coservers with the type <var>type</var>. All instances of this coserver type will be stopped.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_coserver_create</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_coserver_t *</deftype> 
          <deffunction>svz_coserver_create</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>type</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Create and return a single coserver with the given type <var>type</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_coserver_type_name</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>const char *</deftype> 
          <deffunction>svz_coserver_type_name</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>svz_coserver_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>coserver</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the type name of <var>coserver</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_coserver_rdns_invoke</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_coserver_rdns_invoke</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_address_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>addr</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_coserver_handle_result_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>cb</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>closure</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Enqueue a request for the reverse DNS coserver to resolve address <var>addr</var>, arranging for callback <var>cb</var> to be called with two args: the hostname (a string) and the opaque data <var>closure</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_coserver_dns_invoke</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_coserver_dns_invoke</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>host</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_coserver_handle_result_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>cb</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>closure</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Enqueue a request for the DNS coserver to resolve <var>host</var>, arranging for callback <var>cb</var> to be called with two args: the ip address in dots-and-numbers notation and the opaque data <var>closure</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_coserver_ident_invoke</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_coserver_ident_invoke</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_coserver_handle_result_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>cb</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>closure</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Enqueue a request for the ident coserver to resolve the client identity at <var>sock</var>, arranging for callback <var>cb</var> to be called with two args: the identity (string) and the opaque data <var>closure</var>.</para>
        </definitionitem>
      </definition>
      <para>To make use of coservers, you need to start the coserver interface by calling <code>svz_updn_all_coservers</code> once before, and once after, entering the main server loop.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_updn_all_coservers</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_updn_all_coservers</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>direction</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>If <var>direction</var> is non-zero, init coserver internals. Otherwise, finalize them.  Return 0 if successful.</para>
          <para>If <var>direction</var> is positive, init also starts one instance each of the builtin servers.  If negative, it doesn't.</para>
        </definitionitem>
      </definition>
    </subsection>
  </node>
  <node>
    <nodename>Codec functions</nodename>
    <nodenext>Server types</nodenext>
    <nodeprev>Coserver functions</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Codec functions</title>
      <para>The codec interface of the Serveez core API supplies routines for setting up socket structures to perform encoding or decoding of its receive or send buffers.  It is a transparent layer of buffer transition.  The interface itself tries to unify different types of codecs.  In order to add a new codec the programmer needs to write some wrapper functions around the actual implementation to fulfill certain entry and exit semantics of this interface.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_foreach_codec</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_foreach_codec</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_codec_do_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>func</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>closure</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Call <var>func</var> for each codec, passing additionally the second arg <var>closure</var>.  If <var>func</var> returns a negative value, return immediately with that value (breaking out of the loop), otherwise, return 0.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_codec_get</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_codec_t *</deftype> 
          <deffunction>svz_codec_get</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>description</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>type</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Find an appropriate codec for the given <var>description</var> and <var>type</var> (one of either <code>SVZ_CODEC_ENCODER</code> or <code>SVZ_CODEC_DECODER</code>). Return <code>NULL</code> if there is no such codec registered.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_codec_ratio</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_codec_ratio</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_codec_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>codec</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_codec_data_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>data</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Print a text representation of a codec's current ratio in percent if possible.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_codec_register</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_codec_register</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_codec_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>codec</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Register <var>codec</var>.  Does not register invalid or duplicate codecs.  Return zero on success, non-zero otherwise.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_codec_unregister</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_codec_unregister</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_codec_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>codec</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Remove <var>codec</var> from the list of known codecs.  Return zero if the codec could be successfully removed, non-zero otherwise.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_codec_sock_receive_setup</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_codec_sock_receive_setup</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_codec_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>codec</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Arrange for <var>sock</var> to decode or encode its receive data via <var>codec</var>.  Return zero on success, non-zero otherwise.</para>
          <para>(You need to have set the <code>check_request</code> method previously for this to work.)</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_codec_sock_receive</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_codec_sock_receive</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>&ldquo;This routine is the new <code>check_request</code> callback for reading codecs.  It is applied in <code>svz_codec_sock_receive_setup</code>. Usually it gets called whenever there is data in the receive buffer. It lets the current receive buffer be the input of the codec.  The output buffer of the codec gets the new receive buffer of <var>sock</var>. The old <code>check_request</code> callback of <var>sock</var> gets called afterwards.  When leaving this function, the receive buffer gets restored again with the bytes snipped consumed by the codec itself.&rdquo; [ttn sez: huh?]</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_codec_sock_send_setup</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_codec_sock_send_setup</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_codec_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>codec</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Arrange for <var>sock</var> to encode or decode its send buffer via <var>codec</var>.  Return zero on success, non-zero otherwise.</para>
          <para>(You need to have properly set the <code>write_socket</code> member of <var>sock</var> previously for this to work.)</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_codec_sock_send</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_codec_sock_send</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>&ldquo;This is the new <code>write_socket</code> callback for <var>sock</var> which is called whenever there is data within the send buffer available and <var>sock</var> is scheduled for writing.  It uses the current send buffer as input buffer for the codec.  The output buffer of the codec is used to invoke the <code>write_socket</code> callback saved within <code>svz_codec_sock_send_setup</code>.  After this the send buffer is restored again without the bytes consumed by the codec.&rdquo; [ttn sez: huh?]</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_codec_sock_disconnect</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_codec_sock_disconnect</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Try to release the resources of both the receiving and sending codec of <var>sock</var>.</para>
          <para>This callback is used as the <code>disconnected_socket</code> callback of the socket structure <var>sock</var>.  It is called by default if the codec socket structure <var>sock</var> gets disconnected for some external reason.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_codec_sock_detect</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_codec_t *</deftype> 
          <deffunction>svz_codec_sock_detect</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return a valid codec detected by scanning the receive buffer of <var>sock</var>, or <code>NULL</code> if no codec could be detected.</para>
        </definitionitem>
      </definition>
    </subsection>
  </node>
  <node>
    <nodename>Server types</nodename>
    <nodenext>Server functions</nodenext>
    <nodeprev>Codec functions</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Server types</title>
      <para>As already noted in the main Serveez manual a server type is the main specification of the abilities and configuration items of a server which can be instantiated.  It is represented by <code>svz_servertype_t</code> in Serveez.  It contains server specific members like its name, different callbacks, a single default configuration and a list of configuration items which determine what can be configured.</para>
      <menu>
        <menuentry>
          <menunode>Macros for setting up a new server type</menunode>
          <menutitle>Macros for setting up a new server type</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>General server type functionality</menunode>
          <menutitle>General server type functionality</menutitle>
          <menucomment></menucomment>
        </menuentry>
        <menuentry>
          <menunode>Dynamic server loading</menunode>
          <menutitle>Dynamic server loading</menutitle>
          <menucomment></menucomment>
        </menuentry>
      </menu>
    </subsection>
  </node>
  <node>
    <nodename>Macros for setting up a new server type</nodename>
    <nodenext>General server type functionality</nodenext>
    <nodeup>Server types</nodeup>
    <subsubsection>
      <title>Macros for setting up a new server type</title>
      <para>When specifying a server type you also need to define configuration items for it.  These items refer to addresses in the example configuration of the server type.  These macros can be used to define such items.</para>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_REGISTER_INT</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_REGISTER_INT</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>name</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>item</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>defaultable</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Register a simple integer.  C-type: <code>int</code>.  The given <var>name</var> specifies the symbolic name of the integer and <var>item</var> the integer itself (not its address).  The <var>defaultable</var> argument can be either <code>SVZ_ITEM_DEFAULTABLE</code> or <code>SVZ_ITEM_NOTDEFAULTABLE</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_REGISTER_BOOL</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_REGISTER_BOOL</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>name</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>item</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>defaultable</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Register a boolean value.  C-type: <code>int</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_REGISTER_INTARRAY</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_REGISTER_INTARRAY</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>name</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>item</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>defaultable</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Register an array of integers.  C-type: <code>svz_array_t *</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_REGISTER_STR</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_REGISTER_STR</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>name</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>item</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>defaultable</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Register a simple character string.  C-type: <code>char *</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_REGISTER_STRARRAY</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_REGISTER_STRARRAY</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>name</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>item</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>defaultable</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Register a string array.  C-type: <code>svz_array_t *</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_REGISTER_HASH</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_REGISTER_HASH</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>name</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>item</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>defaultable</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Register a hash table associating strings with strings only.  C-type: <code>svz_hash_t *</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_REGISTER_PORTCFG</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_REGISTER_PORTCFG</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>name</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>item</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>defaultable</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Register a port configuration.  C-type: <code>svz_portcfg_t *</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_REGISTER_END</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_REGISTER_END</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Indicate the end of the list of configuration items.  It is the only mandatory item you need to specify in an example server type configuration.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_CONFIG_DEFINE</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_CONFIG_DEFINE</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>description</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>config</defparam>
          <defdelimiter>,</defdelimiter> 
          <defparam>prototypes</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Expand to a data structure that properly associates the example configuration <var>config</var> with the name <var>description</var> and its configuration items <var>prototypes</var>, for use within a server type definition.</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>General server type functionality</nodename>
    <nodenext>Dynamic server loading</nodenext>
    <nodeprev>Macros for setting up a new server type</nodeprev>
    <nodeup>Server types</nodeup>
    <subsubsection>
      <title>General server type functionality</title>
      <para>The following set of functions are used to manage the list of known server types in the Serveez core library.  Serveez itself uses some of these functions to register its builtin server types.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_foreach_servertype</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_foreach_servertype</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_servertype_do_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>func</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>closure</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Call <var>func</var> for each servertype, passing additionally the second arg <var>closure</var>.  If <var>func</var> returns a negative value, return immediately with that value (breaking out of the loop), otherwise, return 0.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_servertype_add</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_servertype_add</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_servertype_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>server</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Add the server type <var>server</var> to the currently registered servers.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_servertype_get</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_servertype_t *</deftype> 
          <deffunction>svz_servertype_get</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>name</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>dynamic</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Find a servertype definition by its short name.  If <var>dynamic</var> is set to non-zero, try to load a shared library that provides that servertype.  Return <code>NULL</code> if no server with the given variable prefix <var>name</var> has been found.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_servertype_find</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_servertype_t *</deftype> 
          <deffunction>svz_servertype_find</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_server_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>server</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Find a given server instances <var>server</var> server type.  Return <code>NULL</code> if there is no such server type (which should never occur since a server is a child of a server type).</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>Dynamic server loading</nodename>
    <nodeprev>General server type functionality</nodeprev>
    <nodeup>Server types</nodeup>
    <subsubsection>
      <title>Dynamic server loading</title>
      <para>The core API of Serveez is able to register server types dynamically at runtime.  It uses the dynamic linker capabilities of the underlying operating system to load shared libraries (or DLLs on Win32).  This has been successfully tested on Windows and GNU/Linux.  Other systems are supported but yet untested.  Please tell us if you notice misbehaviour of any sort.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_dynload_path_set</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_dynload_path_set</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_array_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>paths</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Set the additional search paths for the serveez library.  The given array of strings gets <code>svz_free</code>d.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_dynload_path_get</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_array_t *</deftype> 
          <deffunction>svz_dynload_path_get</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Create an array of strings containing each an additional search path. The loadpath is hold in the environment variable <samp>SERVEEZ_LOAD_PATH</samp> which can be set from outside the library or modified using <code>svz_dynload_path_set</code>.  The returned array needs to be destroyed after usage.</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>Server functions</nodename>
    <nodenext>Port config funcs</nodenext>
    <nodeprev>Server types</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Server functions</title>
      <para>A server in Serveez is an instantiated (configured) server type.  It is merely a copy of a specific server type with a unique server name, and is represented by <code>svz_server_t</code> in the core library.</para>
      <menu>
        <menuentry>
          <menunode>Server functionality</menunode>
          <menutitle>Server functionality</menutitle>
          <menucomment>General server instance implementations</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Server configuration</menunode>
          <menutitle>Server configuration</menutitle>
          <menucomment>Server instance configuration</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Server binding</menunode>
          <menutitle>Server binding</menutitle>
          <menucomment>Server instance bindings</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Server core</menunode>
          <menutitle>Server core</menutitle>
          <menucomment>Core functionality for servers</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Server loop</menunode>
          <menutitle>Server loop</menutitle>
          <menucomment>Server loop implementation</menucomment>
        </menuentry>
        <menuentry>
          <menunode>Server socket</menunode>
          <menutitle>Server socket</menutitle>
          <menucomment>Using and creating server sockets</menucomment>
        </menuentry>
      </menu>
    </subsection>
  </node>
  <node>
    <nodename>Server functionality</nodename>
    <nodenext>Server configuration</nodenext>
    <nodeup>Server functions</nodeup>
    <subsubsection>
      <title>Server functionality</title>
      <para>This section contains functions dealing with the list of known servers in the core library of Serveez, also with the basics like creation and destruction of such servers.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_foreach_server</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_foreach_server</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_server_do_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>func</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>closure</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Call <var>func</var> for each server, passing additionally the second arg <var>closure</var>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_server_find</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_server_t *</deftype> 
          <deffunction>svz_server_find</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>cfg</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Find a server instance by the given configuration structure <var>cfg</var>. Return <code>NULL</code> if there is no such configuration in any server instance.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_server_clients</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_array_t *</deftype> 
          <deffunction>svz_server_clients</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_server_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>server</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return a list of clients (socket structures) which are associated with the given server instance <var>server</var>.  If there is no such socket, return <code>NULL</code>.  Caller should <code>svz_array_destroy</code> the returned array.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_server_get</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_server_t *</deftype> 
          <deffunction>svz_server_get</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>name</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Get the server instance with the given instance name <var>name</var>. Return <code>NULL</code> if there is no such server yet.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_updn_all_servers</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_updn_all_servers</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>direction</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>If <var>direction</var> is non-zero, run the initializers of all servers, returning -1 if some server did not think it is a good idea to run.  Otherwise, run the local finalizers for all server instances.</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>Server configuration</nodename>
    <nodenext>Server binding</nodenext>
    <nodeprev>Server functionality</nodeprev>
    <nodeup>Server functions</nodeup>
    <subsubsection>
      <title>Configuration</title>
      <para>These functions provide an interface for configuring a server.  They are used to create and modify the default configuration of a server type in order to create a server configuration.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_config_type_instantiate</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_config_type_instantiate</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>type</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>name</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>instance</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>options</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_config_accessor_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>accessor</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>ebufsz</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>ebuf</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Instantiate a configurable type.  The <var>type</var> argument specifies the configurable type name, <var>name</var> the name of the type (in the domain of the configurable type) and <var>instance</var> the instance name of the type.  Return zero on success, otherwise -1.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_config_free</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_config_free</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_config_prototype_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>prototype</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>cfg</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Release the configuration <var>cfg</var> of the given configuration prototype <var>prototype</var>.  If <var>cfg</var> is <code>NULL</code>, do nothing.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_collect</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void *</deftype> 
          <deffunction>svz_collect</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>type</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>count</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>data</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Create a collection of <var>type</var>, given the <var>count</var> items of <var>data</var>.  Valid values of <var>type</var> are one of: <code>SVZ_INTARRAY</code>, <code>SVZ_STRARRAY</code>, <code>SVZ_STRHASH</code>. For a string hash, <var>data</var> should be alternating keys and values; the returned hash table will have <code><var>count</var> / 2</code> elements. The C type of <var>data</var> for an int array should be <code>int[]</code>, and for string array or hash it should be <code>char*[]</code>. On error (either bad <var>type</var> or odd <var>count</var> for string hash), return <code>NULL</code>.</para>
        </definitionitem>
      </definition>
      <para role="continues">Here are some convenience macros for <code>svz_collect</code>:</para>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_COLLECT_INTARRAY</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_COLLECT_INTARRAY</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>cvar</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return an integer array <code>svz_array_t *</code> created from <code>int <var>cvar</var>[]</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_COLLECT_STRARRAY</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_COLLECT_STRARRAY</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>cvar</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return a string array <code>svz_array_t *</code> created from <code>char *<var>cvar</var>[]</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">SVZ_COLLECT_STRHASH</indexterm>
          <defcategory>Macro</defcategory> 
          <deffunction>SVZ_COLLECT_STRHASH</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparam>cvar</defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return a string hash <code>svz_hash_t *</code> created from <code>char *<var>cvar</var>[]</code>.</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>Server binding</nodename>
    <nodenext>Server core</nodenext>
    <nodeprev>Server configuration</nodeprev>
    <nodeup>Server functions</nodeup>
    <subsubsection>
      <title>Bindings</title>
      <para>The following functionality represents the relationship between port configurations as described in <xref><xrefnodename>Port config funcs</xrefnodename></xref> and server instances.  When binding a server to a specific port configuration the core library creates listeners as needed by itself.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_server_bind</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_server_bind</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_server_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>server</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_portcfg_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>port</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Bind the server instance <var>server</var> to the port configuration <var>port</var> if possible.  Return non-zero on errors, otherwise zero. It might occur that a single server is bound to more than one network port if, e.g., the TCP/IP address is specified by <samp>*</samp> (asterisk) since this gets expanded to the known list of interfaces.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_server_portcfgs</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_array_t *</deftype> 
          <deffunction>svz_server_portcfgs</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_server_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>server</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return an array of port configurations to which the server instance <var>server</var> is currently bound to, or <code>NULL</code> if there is no such binding.  Caller should <code>svz_array_destroy</code> the returned array when done.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_server_listeners</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_array_t *</deftype> 
          <deffunction>svz_server_listeners</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_server_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>server</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return an array of listening socket structures to which the server instance <var>server</var> is currently bound to, or <code>NULL</code> if there is no such binding.  Caller should <code>svz_array_destroy</code> the returned array when done.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_servers</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_array_t *</deftype> 
          <deffunction>svz_sock_servers</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the array of server instances bound to the listening <var>sock</var>, or <code>NULL</code> if there are no bindings.  Caller should <code>svz_array_destroy</code> the returned array when done.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_binding_contains_server</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_binding_contains_server</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_server_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>server</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Checks whether the server instance <var>server</var> is bound to the server socket structure <var>sock</var>. Return one if so, otherwise zero.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_pp_server_bindings</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>size_t</deftype> 
          <deffunction>svz_pp_server_bindings</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>buf</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>size</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_server_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>server</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Format a space-separated list of current port configuration bindings for <var>server</var> into <var>buf</var>, which has <var>size</var> bytes.  The string is guaranteed to be nul-terminated.  Return the length (at most <code><var>size</var> - 1</code>) of the formatted string.</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>Server core</nodename>
    <nodenext>Server loop</nodenext>
    <nodeprev>Server binding</nodeprev>
    <nodeup>Server functions</nodeup>
    <subsubsection>
      <title>Server core</title>
      <definition>
        <definitionterm><indexterm index="cp">svz_child_died</indexterm>
          <defcategory>Variable</defcategory> 
          <deftype>svz_t_handle</deftype> 
          <defvariable>svz_child_died</defvariable>
        </definitionterm>
        <definitionitem>
          <para>Set to a non-zero value whenever the server receives a SIGCHLD signal.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_shutting_down_p</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_shutting_down_p</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return non-zero if the core is in the process of shutting down (typically as a result of a signal).</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_foreach_socket</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_foreach_socket</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_do_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>func</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>closure</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Call <var>func</var> for each socket, passing additionally the second arg <var>closure</var>.  If <var>func</var> returns a negative value, return immediately with that value (breaking out of the loop), otherwise, return 0.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_find</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_socket_t *</deftype> 
          <deffunction>svz_sock_find</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>id</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>version</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the socket structure for the socket id <var>id</var> and the version <var>version</var>, or <code>NULL</code> if no such socket exists.  If <var>version</var> is -1 it is not checked.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_schedule_for_shutdown</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_sock_schedule_for_shutdown</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Mark socket <var>sock</var> as killed.  That means that no further operations except disconnecting and freeing are allowed.  All marked sockets will be deleted once the server loop is through.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_enqueue</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_sock_enqueue</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Enqueue the socket <var>sock</var> into the list of sockets handled by the server loop.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_setparent</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_sock_setparent</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>child</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>parent</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Set the <var>child</var> socket's parent to <var>parent</var>.</para>
          <para>This should be called whenever a listener accepts a connection and creates a new child socket.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_getparent</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_socket_t *</deftype> 
          <deffunction>svz_sock_getparent</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>child</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the <var>child</var> socket's parent socket structure, or <code>NULL</code> if this socket does not exist anymore.  This might happen if a listener dies for some reason.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_setreferrer</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_sock_setreferrer</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>referrer</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Set the referring socket structure of <var>sock</var> to <var>referrer</var>. If <var>referrer</var> is <code>NULL</code> the reference will be invalidated.</para>
          <para>This can be used to create some relationship between two socket structures.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_getreferrer</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_socket_t *</deftype> 
          <deffunction>svz_sock_getreferrer</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Get the referrer of the socket structure <var>sock</var>. Return <code>NULL</code> if there is no such socket.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_sock_portcfg</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_portcfg_t *</deftype> 
          <deffunction>svz_sock_portcfg</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_socket_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>sock</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the parent's port configuration of <var>sock</var>, or <code>NULL</code> if the given socket has no parent, i.e. is a listener.</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>Server loop</nodename>
    <nodenext>Server socket</nodenext>
    <nodeprev>Server core</nodeprev>
    <nodeup>Server functions</nodeup>
    <subsubsection>
      <title>Server loop</title>
      <para>This section describes the main server loop functionality.  There two modes of operation.  The default mode as used in Serveez is to jump into the loop and wait until the core library drops out of it.  In the other mode, the caller tells the Serveez core library to scan (and process) its socket chain once and return immediately.  Thus, caller is able to issue additional functionality in between each pass, useful if such functionality cannot be handled within the timers (notifiers) of servers and sockets.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_loop_pre</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_loop_pre</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Initialize top-of-cycle state.</para>
          <para>Call this function once before using <code>svz_loop_one</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_loop_post</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_loop_post</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Clean up bottom-of-cycle state.</para>
          <para>Call this function once after using <code>svz_loop_one</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_loop</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_loop</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Loop, serving.  In other words, handle all signals, incoming and outgoing connections and listening server sockets.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_loop_one</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_loop_one</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Handle all things once.</para>
          <para>This function is called regularly by <code>svz_loop</code>.</para>
        </definitionitem>
      </definition>
    </subsubsection>
  </node>
  <node>
    <nodename>Server socket</nodename>
    <nodeprev>Server loop</nodeprev>
    <nodeup>Server functions</nodeup>
    <subsubsection>
      <title>Server sockets</title>
      <para>This section deals with creating and handling listeners.  These functions provide the default routines invoked when accepting a new connection on a listener.  This is necessary for connection oriented protocols (TCP and named pipes) only.</para>
      <para>[FIXME: All funcs internalized!  Write something else here!]</para>
    </subsubsection>
  </node>
  <node>
    <nodename>Port config funcs</nodename>
    <nodenext>Booting</nodenext>
    <nodeprev>Server functions</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Port configurations</title>
      <para>A port configuration is a structure defining a network or file system configuration.  Depending on the type of a server, it can be bound to one or more port configurations.  There are two major types of port configurations: connection oriented (TCP and PIPE), and packet oriented (ICMP, UDP and RAW).</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_portcfg_addr</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>struct sockaddr_in *</deftype> 
          <deffunction>svz_portcfg_addr</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_portcfg_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>port</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the pointer of the <code>sockaddr_in</code> structure of the given port configuration <var>port</var> if it is a network port configuration. Otherwise return <code>NULL</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_portcfg_port</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>in_port_t</deftype> 
          <deffunction>svz_portcfg_port</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_portcfg_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>port</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the UDP or TCP port of the given port configuration or zero if it neither TCP nor UDP.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_portcfg_ipaddr</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>char *</deftype> 
          <deffunction>svz_portcfg_ipaddr</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_portcfg_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>port</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the pointer to the ip address <code>ipaddr</code> of the given port configuration <var>port</var> if it is a network port configuration. Otherwise return <code>NULL</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_portcfg_device</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>char *</deftype> 
          <deffunction>svz_portcfg_device</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_portcfg_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>port</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the network device name stored in the given port configuration <var>port</var> if it is a network port configuration. Return <code>NULL</code> if there is no such device set or if the port configuration is not a network port configuration.</para>
        </definitionitem>
      </definition>
      <para>Serveez maintains an internal list of port configurations, with each identified by its name.  When you bind a server to a port configuration, it does not get bound to a certain name but to its content.  If there are two or more port configuration specifying the same network or file system configuration just a single one gets actually used.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_portcfg_create</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_portcfg_t *</deftype> 
          <deffunction>svz_portcfg_create</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Create a new blank port configuration.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_portcfg_equal</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_portcfg_equal</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_portcfg_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>a</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_portcfg_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>b</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Check if two given port configurations structures are equal, i.e. specifying the same network port or pipe files.  Return <code>SVZ_PORTCFG_EQUAL</code> if <var>a</var> and <var>b</var> are identical, <code>SVZ_PORTCFG_MATCH</code> if the network address of either port configuration contains the other (INADDR_ANY match), and otherwise <code>SVZ_PORTCFG_NOMATCH</code> or possibly <code>SVZ_PORTCFG_CONFLICT</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_portcfg_add</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_portcfg_t *</deftype> 
          <deffunction>svz_portcfg_add</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>name</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>svz_portcfg_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>port</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Add the given port configuration <var>port</var> associated with the name <var>name</var> to the list of known port configurations.  Return <code>NULL</code> on errors.  If the return port configuration equals the given port configuration the given one has been successfully added.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_portcfg_get</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_portcfg_t *</deftype> 
          <deffunction>svz_portcfg_get</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>name</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the port configuration associated with the given name <var>name</var>. Return <code>NULL</code> on errors.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_portcfg_destroy</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_portcfg_destroy</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_portcfg_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>port</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Make the given port configuration <var>port</var> completely unusable, removing it from the list of known port configurations. Do nothing if <var>port</var> is <code>NULL</code>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_portcfg_mkaddr</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_portcfg_mkaddr</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_portcfg_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>this</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Construct the <code>sockaddr_in</code> fields from the <code>ipaddr</code> field. Return zero if it worked.  If it does not work, the <code>ipaddr</code> field did not consist of an ip address in dotted decimal form.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_portcfg_dup</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>svz_portcfg_t *</deftype> 
          <deffunction>svz_portcfg_dup</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_portcfg_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>port</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Make a copy of the given port configuration <var>port</var>.</para>
        </definitionitem>
      </definition>
    </subsection>
  </node>
  <node>
    <nodename>Booting</nodename>
    <nodenext>Interface</nodenext>
    <nodeprev>Port config funcs</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Boot functions</title>
      <para>The most important functions are <code>svz_boot</code> and <code>svz_halt</code> which must be the first and the last call to the core API.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_boot</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_boot</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>client</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Initialize the core library. <var>client</var> is typically a program's <code>argv[0]</code>. If <code>NULL</code>, take it to be <samp>anonymous</samp>.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_uptime</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>long</deftype> 
          <deffunction>svz_uptime</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Return the number of seconds since <code>svz_boot</code> was called, or -1 if <code>svz_boot</code> has not yet been called.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_halt</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>void</deftype> 
          <deffunction>svz_halt</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>void</defparamtype>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Finalization of the core library.</para>
        </definitionitem>
      </definition>
      <subsubsection>
        <title>Runtime parameters</title>
        <para>There are several runtime parameters indicating the abilities of the libserveez core API:</para>
        <table>
          <tableitem>
            <tableterm><code>SVZ_RUNPARM_VERBOSITY</code></tableterm>
            <item>
              <para>The log-level verbosity.</para>
            </item>
          </tableitem>
          <tableitem>
            <tableterm><code>SVZ_RUNPARM_MAX_SOCKETS</code></tableterm>
            <item>
              <para>Maxium number of clients allowed to connect.</para>
            </item>
          </tableitem>
        </table>
        <para>These are manipulated by <code>svz_runparm</code> and two convenience macros, both of which accept <dfn>nick</dfn>, a C token without the prefix <samp>SVZ_RUNPARM_</samp> (e.g., <code>VERBOSITY</code>).</para>
        <definition>
          <definitionterm><indexterm index="cp">svz_runparm</indexterm>
            <defcategory>Function</defcategory> 
            <deftype>int</deftype> 
            <deffunction>svz_runparm</deffunction> 
            <defdelimiter>(</defdelimiter>
            <defparamtype>int</defparamtype>
            <defparam>&#xa0;</defparam>
            <defparam><var>a</var></defparam>
            <defdelimiter>,</defdelimiter> 
            <defparamtype>int</defparamtype>
            <defparam>&#xa0;</defparam>
            <defparam><var>b</var></defparam>
            <defdelimiter>)</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Set or get a runtime parameter. If <var>a</var> is -1, return the value of runtime parameter <var>b</var>.  If <var>a</var> specifies a runtime parameter, set it to <var>b</var> and return 0.  Otherwise, return -1.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">SVZ_RUNPARM</indexterm>
            <defcategory>Macro</defcategory> 
            <deffunction>SVZ_RUNPARM</deffunction> 
            <defdelimiter>(</defdelimiter>
            <defparam>nick</defparam>
            <defdelimiter>)</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Return the value of runtime parameter <var>nick</var>.</para>
          </definitionitem>
        </definition>
        <definition>
          <definitionterm><indexterm index="cp">SVZ_RUNPARM_X</indexterm>
            <defcategory>Macro</defcategory> 
            <deffunction>SVZ_RUNPARM_X</deffunction> 
            <defdelimiter>(</defdelimiter>
            <defparam>nick</defparam>
            <defdelimiter>,</defdelimiter> 
            <defparam>val</defparam>
            <defdelimiter>)</defdelimiter>
          </definitionterm>
          <definitionitem>
            <para>Set the runtime paramater <var>nick</var> to have value <var>val</var>, an integer.</para>
          </definitionitem>
        </definition>
      </subsubsection>
    </subsection>
  </node>
  <node>
    <nodename>Interface</nodename>
    <nodenext>Windoze</nodenext>
    <nodeprev>Booting</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Network interface functions</title>
      <para>The network interface functions of the Serveez core API allow access to the network devices on your system.  The system administrator can set up these devices to be bound to different Internet addresses and thereby split the network configuration into different <dfn>domains</dfn>.  Thus, the system is able to separate the traffic of different networks.  If set up correctly, Serveez can follow these rules.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_foreach_interface</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_foreach_interface</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>svz_interface_do_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>func</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>closure</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Call <var>func</var> for each interface, passing additionally the second arg <var>closure</var>.  If <var>func</var> returns a negative value, return immediately with that value (breaking out of the loop), otherwise, return 0.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_interface_add</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_interface_add</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>size_t</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>index</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>desc</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>family</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>const</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>void</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>bits</var></defparam>
          <defdelimiter>,</defdelimiter> 
          <defparamtype>int</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparam><var>detected</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Add a network interface to the current list of known interfaces.  Drop duplicate entries.  The given arguments <var>index</var> specifies the network interface index number, <var>desc</var> an interface desription, <var>family</var> an address-family (e.g., <code>AF_INET</code>), <var>bits</var> the address data in network-byte order, and the <var>detected</var> flag if the given network interface has been detected by Serveez itself or not.</para>
        </definitionitem>
      </definition>
    </subsection>
  </node>
  <node>
    <nodename>Windoze</nodename>
    <nodeprev>Interface</nodeprev>
    <nodeup>Embedding API</nodeup>
    <subsection>
      <title>Useful Windows functions</title>
      <para>Serveez is meant to run on Windows systems as well (with some restrictions of course).  These functions are available with the Windows implementation of the Serveez core API only.  They allow access to the Windows registry database and some other useful things.</para>
      <definition>
        <definitionterm><indexterm index="cp">svz_windoze_daemon_control</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>int</deftype> 
          <deffunction>svz_windoze_daemon_control</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>char</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>prog</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>If <var>prog</var> is non-NULL, start the daemon thread with it. Otherwise (if <var>prog</var> is NULL), stop the daemon thread. Return 0 on success, -1 on failure.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_windoze_asc2uni</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>WCHAR *</deftype> 
          <deffunction>svz_windoze_asc2uni</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>CHAR</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>asc</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Convert an ASCII string into a UNICODE string.</para>
        </definitionitem>
      </definition>
      <definition>
        <definitionterm><indexterm index="cp">svz_windoze_uni2asc</indexterm>
          <defcategory>Function</defcategory> 
          <deftype>CHAR *</deftype> 
          <deffunction>svz_windoze_uni2asc</deffunction> 
          <defdelimiter>(</defdelimiter>
          <defparamtype>WCHAR</defparamtype>
          <defparam>&#xa0;</defparam>
          <defparamtype>*</defparamtype>
          <defparam><var>unicode</var></defparam>
          <defdelimiter>)</defdelimiter>
        </definitionterm>
        <definitionitem>
          <para>Convert a UNICODE string into an ASCII string.</para>
        </definitionitem>
      </definition>
    </subsection>
  </node>
  <node>
    <nodename>Porting issues</nodename>
    <nodenext>Bibliography</nodenext>
    <nodeprev>Embedding</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Porting issues</title>
      <para>Serveez was always designed with an eye on maximum portability.  Autoconf and Automake have done a great job at this. A lot of <code>#define</code>'s help to work around some of the different Unix' oddities.  Have a look at <file>config.h</file> for a complete list of all these conditionals.</para>
      <para>Most doubtful might be the Win32 port.  There are two different ways of compiling Serveez on Win32: Cygwin and MinGW.  The Cygwin version of Serveez depends on the Unix emulation layer DLL <file>cygwin1.dll</file>. Both versions work but it is preferable to use MinGW for performance reasons.  The Cygwin version is slow and limited to a very low number (some 64) of open files/network connections.<footnote><para>This was written circa 2003&mdash;maybe the situation is now improved.</para></footnote></para>
      <para>There are major differences between the Win32 and Unix implementations due to the completely different API those systems provide.</para>
      <table>
        <tableitem>
          <tableterm>Processes and Threads</tableterm>
          <item>
            <para>Because process communication is usually done by a pair of unidirectional pipes we chose that method in order to implement the coservers in Unix. The Win32 implementation are threads which are still part of the main process.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>Sockets and Handles</tableterm>
          <item>
            <para>On Win32 systems there is a difference in network sockets and file descriptors.  Thus we had to implement quite a complex main socket loop.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>Named Pipes</tableterm>
          <item>
            <para>Both systems Unix and Win32 do provide this functionality (Windows NT 4.0 and above).  The main differences here are the completely different APIs. On a common Unix you create a named pipe within the filesystem via <code>mkfifo</code>.  On Win32 you have to <code>CreateNamedPipe</code> which will create some special network device.  A further difference is what you can do with these pipes.  On Win32 systems this <samp>network device</samp> is valid on remote machines. Named pipes on Unix are unidirectional, on Win32 they are bidirectional and instantiatable.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>Winsock Versions</tableterm>
          <item>
            <para>There are some difference between the original Winsock 1.1 API and the new version 2.2.x.  In a nutshell, WinSock 2 is WinSock 1.1 on steroids, it's a superset of 1.1's APIs and architecture.  In addition to its new features, it also clarifies existing ambiguities in the 1.1 WinSock specification and adds new extensions that take advantage of operating system features and enhance application performance and efficiency.  Finally, WinSock 2 includes a number of new protocol-specific extensions.  These extensions &ndash;such as multicast socket options&ndash; are relegated to a separate annex, since the main WinSock 2 protocol specification is protocol-independent.</para>
            <para>The Winsock DLL and import library for version 1.1 are <file>wsock32.dll</file> and <file>wsock32.lib</file> and for version 2.2 it is <file>ws2_32.dll</file> and <file>ws2_32.lib</file>.  Serveez is currently using version 2.2.</para>
            <para>The Winsock API is still a bit buggy.  Connected datagram behaviors are not pertinent to any WinSock 2 features, but to generic WinSock.  On Win95 it is possible to use <code>recvfrom</code>/<code>WSARecvFrom</code> on a &ldquo;connected&rdquo; UDP socket, but on NT4 <code>recvfrom</code>/<code>WSARecvFrom</code> fail with 10056 (<code>WSAEISCONN</code>).  NOTE: <code>sendto</code>/<code>WSASendTo</code> fail with <code>WSAEISCONN</code> on both (which I do not see any reason for, but anyway ...).</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>Raw sockets on Windows systems</tableterm>
          <item>
            <para>Raw sockets require Winsock 2.  To use them under Windows NT/2000, you must be logged in as an Administrator.  On any other Microsoft's we were trying to use the <file>ICMP.DLL</file> (an idiotic and almost useless API) without success.  Microsoft says they will replace it as soon as something better comes along.  (Microsoft's been saying this since the Windows 95 days, however, yet this functionality still exists in Windows 2000.) It seems like you cannot send ICMP or even raw packets from the userspace of Windows (except via the <file>ICMP.DLL</file> which is limited to echo requests).  We also noticed that you cannot receive any packets previously sent.  The only thing which works on all Windows systems (9x/ME/NT/2000/XP) is receiving packets the &ldquo;kernel&rdquo; itself generated (like echo replies). One good thing we noticed about Windows 2000 is that the checksums of fragmented ICMP packets get correctly recalculated.  That is not the case in the current Linux kernels.</para>
          </item>
        </tableitem>
        <tableitem>
          <tableterm>Miscellaneous</tableterm>
          <item>
            <para>To use the Win32 Winsock in the Cygwin port, you just need to <code>#define Win32_Winsock</code> and <code>#include "windows.h"</code> at the top of your source file(s).  You will also want to add <code>-lwsock32</code> to the compiler's command line so you link against <file>libwsock32.a</file>.</para>
            <para>What preprocessor macros do I need to know about ? We use <code>_WIN32</code> to signify access to the Win32 API and <code>__CYGWIN__</code> for access to the Cygwin environment provided by the dll. We chose <code>_WIN32</code> because this is what Microsoft defines in VC++ and we thought it would be a good idea for compatibility with VC++ code to follow their example.  We use <code>_MFC_VER</code> to indicate code that should be compiled with VC++.</para>
            <para>Why we do not use pipes for coservers ? Windows differentiates between sockets and file descriptors, that is why you can not <code>select</code> file descriptors.  Please <code>close</code> the pipe's descriptors via <code>CloseHandle</code> and not <code>closesocket</code>, because this will fail.</para>
            <para>The C run-time libraries have a preset limit for the number of files that can be open at any one time.  The limit for applications that link with the single-thread static library (<file>LIBC.LIB</file>) is 64 file handles or 20 file streams.  Applications that link with either the static or dynamic multithread library (<file>LIBCMT.LIB</file> or <file>MSVCRT.LIB</file> and <file>MSVCRT.DLL</file>), have a limit of 256 file handles or 40 file streams. Attempting to open more than the maximum number of file handles or file streams causes program failure.</para>
            <para>As far as I know, one of the big limitations of Winsock is that the SOCKET type is *not* equivalent to file descriptor.  It is however with BSD and POSIX sockets.  That is one of the major reasons for using a separate data type, SOCKET, not an int, a typical type for a file descriptor.  This implies that you cannot mix SOCKETs and stdio, sorry.  This is the case when you use <code>-mno-cygwin</code>.</para>
            <para>Actually they are regular file handles, just like any other.  There is a bug in all 9x/kernel32 libc/msv/crtdll interface implementations <code>GetFileType</code> returns <code>TYPE_UNKNOWN</code> for socket handles.  Since this is AFAIK the only unknown type there is, you know you have a socket handle.  There is a fix in the more recent perl distributions that you can use as a general solution.  <code>-loldnames -lperlcrt -lmsvcrt</code> will get you <code>TYPE_CHAR</code> for socket handles.</para>
          </item>
        </tableitem>
      </table>
      <para>Now follows the list on which operating systems and architectures Serveez has been build and tested successfully.</para>
      <itemize>
        <itemfunction>&bullet;</itemfunction>
        <item>
          <para>FreeBSD 3.3, 4.0, 4.3, 4.4, 4.5, 4.6, 4.7 on Intel</para>
        </item>
        <item>
          <para>FreeBSD 4.0, 4.4, 4.6 on Alpha</para>
        </item>
        <item>
          <para>NetBSD 1.5, 1.6 on Alpha</para>
        </item>
        <item>
          <para>OpenBSD 3.0, 3.1 on Alpha</para>
        </item>
        <item>
          <para>OpenBSD 3.1 on Intel</para>
        </item>
        <item>
          <para>GNU/Linux 2.x.x on Intel</para>
        </item>
        <item>
          <para>GNU/Linux 2.x.x on Alpha</para>
        </item>
        <item>
          <para>GNU/Linux 2.2.x on Sparc64 (UltraSparcII + MachV)</para>
        </item>
        <item>
          <para>GNU/Linux 2.x.x on PowerPC (RS/6000)</para>
        </item>
        <item>
          <para>GNU/Linux 2.4.x on ia64 (Itanium)</para>
        </item>
        <item>
          <para>GNU/Linux 2.4.x on StrongARM (iPAQ)</para>
        </item>
        <item>
          <para>GNU/Linux 2.4.x on Motorola 680x0</para>
        </item>
        <item>
          <para>GNU/Linux 2.4.x on IBM S/390</para>
        </item>
        <item>
          <para>GNU/Linux 2.4.x on HP PA-RISC</para>
        </item>
        <item>
          <para>GNU/Linux 2.4.x on MIPS</para>
        </item>
        <item>
          <para>Solaris 2.6, 2.7 on Sparc32, Sparc64</para>
        </item>
        <item>
          <para>SunOS 5.8 on Sparc32</para>
        </item>
        <item>
          <para>SunOS 5.6 on Intel</para>
        </item>
        <item>
          <para>AIX 4.3 on RS/6000</para>
        </item>
        <item>
          <para>MacOS X10.1/Darwin 1.4, 5.4, 5.5 on PowerPC (Macintosh)</para>
        </item>
        <item>
          <para>Windows 95 on Intel</para>
        </item>
        <item>
          <para>Windows 98 on Intel</para>
        </item>
        <item>
          <para>Windows Millennium Edition on Intel</para>
        </item>
        <item>
          <para>Windows NT 4.0 on Intel</para>
        </item>
        <item>
          <para>Windows 2000 on Intel</para>
        </item>
        <item>
          <para>Windows XP on Intel</para>
        </item>
        <item>
          <para>IRIX 6.x on MIPS</para>
        </item>
        <item>
          <para>Tru64/OSF1 UNIX V4.0 (former Digital UNIX) on Alpha</para>
        </item>
        <item>
          <para>Tru64/OSF1 UNIX V5.x (former Digital UNIX) on Alpha</para>
        </item>
        <item>
          <para>HP-UX B.11.11 on HP PA-RISC (PA-8700/PA-8600)</para>
        </item>
        <item>
          <para>HP-UX B.11.22 on ia64 (Itanium)</para>
        </item>
      </itemize>
    </chapter>
  </node>
  <node>
    <nodename>Bibliography</nodename>
    <nodenext>GNU Free Documentation License</nodenext>
    <nodeprev>Porting issues</nodeprev>
    <nodeup>Top</nodeup>
    <chapter>
      <title>Bibliography</title>
      <para>This section contain some of the documents and resources we read and used to implement various parts of this package.  They appear in no specific order.</para>
      <enumerate first="1">
        <item>
          <para>RFC 760&linebreak; The Internet Protocol</para>
        </item>
        <item>
          <para>RFC 1071&linebreak; Computing the Internet Checksum</para>
        </item>
        <item>
          <para>RFC 1413&linebreak; Identification Protocol</para>
        </item>
        <item>
          <para>RFC 1459&linebreak; Internet Relay Chat Protocol</para>
        </item>
        <item>
          <para>RFC 1945&linebreak; Hypertext Transfer Protocol &ndash; HTTP/1.0</para>
        </item>
        <item>
          <para>RFC 2068&linebreak; Hypertext Transfer Protocol &ndash; HTTP/1.1</para>
        </item>
        <item>
          <para>RFC 2616&linebreak; Hypertext Transfer Protocol &ndash; HTTP/1.1</para>
        </item>
        <item>
          <para>RFC 768&linebreak; User Datagram Protocol</para>
        </item>
        <item>
          <para>RFC 791&linebreak; Internet Protocol</para>
        </item>
        <item>
          <para>RFC 777&linebreak; Internet Control Message Protocol</para>
        </item>
        <item>
          <para><uref><urefurl>http://www.mingw.org/</urefurl></uref>&linebreak; Home of the MinGW (Minimal GNU for Windows) project</para>
        </item>
        <item>
          <para><uref><urefurl>http://gnutelladev.wego.com/</urefurl></uref>&linebreak; The Gnutella Protocol</para>
        </item>
        <item>
          <para><uref><urefurl>http://www.efnet.org/</urefurl></uref>&linebreak; The official EFNet site (includes Hybrid IRC server)</para>
        </item>
        <item>
          <para><uref><urefurl>http://www.sockets.com/</urefurl></uref>&linebreak; Winsock Development Information</para>
        </item>
        <item>
          <para><uref><urefurl>http://tangentsoft.net/wskfaq/</urefurl></uref>&linebreak; Winsock Programmer's FAQ</para>
        </item>
      </enumerate>
    </chapter>
  </node>
  <node>
    <nodename>GNU Free Documentation License</nodename>
    <nodenext>Index</nodenext>
    <nodeprev>Bibliography</nodeprev>
    <nodeup>Top</nodeup>
    <appendix>
      <title>GNU Free Documentation License</title>
<!-- The GNU Free Documentation License. -->
      <center>
        <para>Version 1.3, 3 November 2008</para>
      </center>
<!-- This file is intended to be included within another document, -->
<!-- hence no sectioning command or @node. -->
      <display xml:space="preserve">Copyright &copyright; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
<uref><urefurl>http://fsf.org/</urefurl></uref>

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.</display>
      <enumerate first="0">
        <item>
          <para>PREAMBLE</para>
          <para>The purpose of this License is to make a manual, textbook, or other functional and useful document <dfn>free</dfn> in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others.</para>
          <para>This License is a kind of &ldquo;copyleft&rdquo;, which means that derivative works of the document must themselves be free in the same sense.  It complements the GNU General Public License, which is a copyleft license designed for free software.</para>
          <para>We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does.  But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book.  We recommend this License principally for works whose purpose is instruction or reference.</para>
        </item>
        <item>
          <para>APPLICABILITY AND DEFINITIONS</para>
          <para>This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License.  Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein.  The &ldquo;Document&rdquo;, below, refers to any such manual or work.  Any member of the public is a licensee, and is addressed as &ldquo;you&rdquo;.  You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law.</para>
          <para>A &ldquo;Modified Version&rdquo; of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language.</para>
          <para>A &ldquo;Secondary Section&rdquo; is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document's overall subject (or to related matters) and contains nothing that could fall directly within that overall subject.  (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.)  The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them.</para>
          <para>The &ldquo;Invariant Sections&rdquo; are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License.  If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant.  The Document may contain zero Invariant Sections.  If the Document does not identify any Invariant Sections then there are none.</para>
          <para>The &ldquo;Cover Texts&rdquo; are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License.  A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words.</para>
          <para>A &ldquo;Transparent&rdquo; copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters.  A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text.  A copy that is not &ldquo;Transparent&rdquo; is called &ldquo;Opaque&rdquo;.</para>
          <para>Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, La&tex; input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification.  Examples of transparent image formats include PNG, XCF and JPG.  Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only.</para>
          <para>The &ldquo;Title Page&rdquo; means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page.  For works in formats which do not have any title page as such, &ldquo;Title Page&rdquo; means the text near the most prominent appearance of the work's title, preceding the beginning of the body of the text.</para>
          <para>The &ldquo;publisher&rdquo; means any person or entity that distributes copies of the Document to the public.</para>
          <para>A section &ldquo;Entitled XYZ&rdquo; means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language.  (Here XYZ stands for a specific section name mentioned below, such as &ldquo;Acknowledgements&rdquo;, &ldquo;Dedications&rdquo;, &ldquo;Endorsements&rdquo;, or &ldquo;History&rdquo;.)  To &ldquo;Preserve the Title&rdquo; of such a section when you modify the Document means that it remains a section &ldquo;Entitled XYZ&rdquo; according to this definition.</para>
          <para>The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document.  These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.</para>
        </item>
        <item>
          <para>VERBATIM COPYING</para>
          <para>You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License.  You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute.  However, you may accept compensation in exchange for copies.  If you distribute a large enough number of copies you must also follow the conditions in section 3.</para>
          <para>You may also lend copies, under the same conditions stated above, and you may publicly display copies.</para>
        </item>
        <item>
          <para>COPYING IN QUANTITY</para>
          <para>If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document's license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover.  Both covers must also clearly and legibly identify you as the publisher of these copies.  The front cover must present the full title with all words of the title equally prominent and visible.  You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects.</para>
          <para>If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages.</para>
          <para>If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public.</para>
          <para>It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.</para>
        </item>
        <item>
          <para>MODIFICATIONS</para>
          <para>You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it.  In addition, you must do these things in the Modified Version:</para>
          <enumerate first="A">
            <item>
              <para>Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document).  You may use the same title as a previous version if the original publisher of that version gives permission.</para>
            </item>
            <item>
              <para>List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.</para>
            </item>
            <item>
              <para>State on the Title page the name of the publisher of the Modified Version, as the publisher.</para>
            </item>
            <item>
              <para>Preserve all the copyright notices of the Document.</para>
            </item>
            <item>
              <para>Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.</para>
            </item>
            <item>
              <para>Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.</para>
            </item>
            <item>
              <para>Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document's license notice.</para>
            </item>
            <item>
              <para>Include an unaltered copy of this License.</para>
            </item>
            <item>
              <para>Preserve the section Entitled &ldquo;History&rdquo;, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page.  If there is no section Entitled &ldquo;History&rdquo; in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.</para>
            </item>
            <item>
              <para>Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on.  These may be placed in the &ldquo;History&rdquo; section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.</para>
            </item>
            <item>
              <para>For any section Entitled &ldquo;Acknowledgements&rdquo; or &ldquo;Dedications&rdquo;, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.</para>
            </item>
            <item>
              <para>Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles.  Section numbers or the equivalent are not considered part of the section titles.</para>
            </item>
            <item>
              <para>Delete any section Entitled &ldquo;Endorsements&rdquo;.  Such a section may not be included in the Modified Version.</para>
            </item>
            <item>
              <para>Do not retitle any existing section to be Entitled &ldquo;Endorsements&rdquo; or to conflict in title with any Invariant Section.</para>
            </item>
            <item>
              <para>Preserve any Warranty Disclaimers.</para>
            </item>
          </enumerate>
          <para>If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant.  To do this, add their titles to the list of Invariant Sections in the Modified Version's license notice. These titles must be distinct from any other section titles.</para>
          <para>You may add a section Entitled &ldquo;Endorsements&rdquo;, provided it contains nothing but endorsements of your Modified Version by various parties&mdash;for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard.</para>
          <para>You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version.  Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity.  If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one.</para>
          <para>The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.</para>
        </item>
        <item>
          <para>COMBINING DOCUMENTS</para>
          <para>You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers.</para>
          <para>The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy.  If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work.</para>
          <para>In the combination, you must combine any sections Entitled &ldquo;History&rdquo; in the various original documents, forming one section Entitled &ldquo;History&rdquo;; likewise combine any sections Entitled &ldquo;Acknowledgements&rdquo;, and any sections Entitled &ldquo;Dedications&rdquo;.  You must delete all sections Entitled &ldquo;Endorsements.&rdquo;</para>
        </item>
        <item>
          <para>COLLECTIONS OF DOCUMENTS</para>
          <para>You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects.</para>
          <para>You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.</para>
        </item>
        <item>
          <para>AGGREGATION WITH INDEPENDENT WORKS</para>
          <para>A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an &ldquo;aggregate&rdquo; if the copyright resulting from the compilation is not used to limit the legal rights of the compilation's users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document.</para>
          <para>If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document's Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.</para>
        </item>
        <item>
          <para>TRANSLATION</para>
          <para>Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections.  You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers.  In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail.</para>
          <para>If a section in the Document is Entitled &ldquo;Acknowledgements&rdquo;, &ldquo;Dedications&rdquo;, or &ldquo;History&rdquo;, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.</para>
        </item>
        <item>
          <para>TERMINATION</para>
          <para>You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License.  Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License.</para>
          <para>However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation.</para>
          <para>Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice.</para>
          <para>Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License.  If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.</para>
        </item>
        <item>
          <para>FUTURE REVISIONS OF THIS LICENSE</para>
          <para>The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.  See <uref><urefurl>http://www.gnu.org/copyleft/</urefurl></uref>.</para>
          <para>Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License &ldquo;or any later version&rdquo; applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation.  If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation.  If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Document.</para>
        </item>
        <item>
          <para>RELICENSING</para>
          <para>&ldquo;Massive Multiauthor Collaboration Site&rdquo; (or &ldquo;MMC Site&rdquo;) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works.  A public wiki that anybody can edit is an example of such a server.  A &ldquo;Massive Multiauthor Collaboration&rdquo; (or &ldquo;MMC&rdquo;) contained in the site means any set of copyrightable works thus published on the MMC site.</para>
          <para>&ldquo;CC-BY-SA&rdquo; means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization.</para>
          <para>&ldquo;Incorporate&rdquo; means to publish or republish a Document, in whole or in part, as part of another Document.</para>
          <para>An MMC is &ldquo;eligible for relicensing&rdquo; if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008.</para>
          <para>The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.</para>
        </item>
      </enumerate>
      <heading>ADDENDUM: How to use this License for your documents</heading>
      <para>To use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:</para>
      <smallexample xml:space="preserve"><group>  Copyright (C)  <var>year</var>  <var>your name</var>.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.3
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.</group></smallexample>
      <para>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the &ldquo;with&dots;Texts.&rdquo; line with this:</para>
      <smallexample xml:space="preserve"><group>    with the Invariant Sections being <var>list their titles</var>, with
    the Front-Cover Texts being <var>list</var>, and with the Back-Cover Texts
    being <var>list</var>.</group></smallexample>
      <para>If you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.</para>
      <para>If your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software.</para>
<!-- Local Variables: -->
<!-- ispell-local-pdict: "ispell-dict" -->
<!-- End: -->
    </appendix>
  </node>
  <node>
    <nodename>Index</nodename>
    <nodeprev>GNU Free Documentation License</nodeprev>
    <nodeup>Top</nodeup>
    <unnumbered>
      <title>Index</title>
      <printindex>cp</printindex>
    </unnumbered>
  </node>
</texinfo>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-indent-step:1
sgml-indent-data:nil
End:
-->
