#!/bin/sh
exec ${GUILE-guile} -e '(a1-nf3-mixp)' -s $0 "$@" # -*-scheme-*-
!#
;;; a1-nf3-mixp

;; Copyright (C) 2012 Thien-Thi Nguyen
;;
;; This file is part of IXIN.
;;
;; IXIN is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; IXIN is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with IXIN.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; This is "ttn-do xml2sexp", stripped down and de-generalized
;; to hard code ‘--sxml 3’ and to look for the DTD filename map
;; in the same dir as the program invocation filename's.

;;; Code:

(setlocale LC_ALL "")

(load "./z-dtd.scm")
(load "./z-fixed-pp.scm")

(define-module (a1-nf3-mixp)
  #:export (main)
  #:use-module ((z-dtd) #:select (find-dtd-filename))
  #:use-module ((srfi srfi-13) #:select (string-prefix?
                                         substring/shared
                                         string-concatenate-reverse
                                         string-every))
  #:use-module ((srfi srfi-14) #:select (char-set:whitespace))
  #:use-module ((ice-9 popen) #:select (open-input-pipe))
  #:use-module ((ice-9 pretty-print) #:select (pretty-print))
  #:use-module ((mixp expat) #:select (parser-create
                                       set-param-entity-parsing
                                       hset!))
  #:use-module ((mixp utils) #:select (xml->tree)))

(define-macro (FE . args)
  (let ((proc (car (last-pair args))))
    `(for-each ,proc ,@(delq proc args))))

(define (fse s . args)
  (apply simple-format (current-error-port) s args))

(define (parser)
  (let ((p (parser-create)))

    (define (external-entity-ref context base system-id public-id)
      (cond ((or (find-dtd-filename system-id)
                 (find-dtd-filename public-id))
             => open-input-file)
            (else
             (fse "~A: cannot open external entity ref~%"
                  (basename (car (command-line))))
             (FE `((context ,context)
                   (base ,base)
                   (system-id ,system-id)
                   (public-id ,public-id))
                 (lambda (x)
                   (apply fse " (~A) ~S~%" x)))
             (exit #f))))

    (set-param-entity-parsing p 'XML_PARAM_ENTITY_PARSING_ALWAYS)
    (hset! p `((external-entity-ref . ,external-entity-ref)))
    p))

(define (combine-character-data-children node)
  (let ((acc '()))

    (define (acc! x)
      (set! acc (cons x acc)))

    (let loop ((parts #f) (ls (cddr node)))

      (define (squeeze!)
        (and parts
             (acc! (list 'character-data (string-concatenate-reverse
                                          parts)))))

      (if (null? ls)
          (begin (squeeze!)
                 (reverse! acc))
          (let ((one (car ls)))
            (case (car one)
              ((character-data)
               (loop (cons (cadr one) (or parts '()))
                     (cdr ls)))
              (else
               (squeeze!)
               (acc! one)
               (loop #f (cdr ls)))))))))

(define (crunch port)

  (define current-xml:space-preserve
    (let ((stack '()))
      (lambda args
        (if (null? args)
            (car stack)
            (set! stack (let ((arg (car args)))
                          (if (boolean? arg)
                              (cons arg stack)
                              (cdr stack))))))))

  (define (no-s s)
    (string-every char-set:whitespace s))

  (define (crunch-1 form)
    (let ((acc '()))

      (define (acc! x)
        (set! acc (cons x acc)))

      (let loop ((ls form))
        (if (null? ls)
            (reverse! acc)
            (let ((head (car ls))
                  (tail (cdr ls)))
              (or (pair? head)
                  (error "(not (pair? head)) !!!" head))
              (and (pair? (car head))
                   (error "(pair? (car head)) !!!" head))
              (case (car head)
                ((element)
                 (let* ((x (cadr head))
                        (name (string->symbol (car x)))
                        (attrs (map (lambda (pair)
                                      (list (string->symbol (car pair))
                                            (cdr pair)))
                                    (cadr x))))
                   (acc! name)
                   (acc! (cons '@ attrs))
                   (current-xml:space-preserve
                    (and=> (assq-ref attrs 'xml:space)
                           (lambda (ls)
                             (string=? "preserve" (car ls)))))
                   (FE (map crunch-1 (map list (combine-character-data-children
                                                head)))
                       (lambda (res)
                         (cond ((null? res))
                               ((and-map string? res)
                                (FE res acc!))
                               (else
                                (acc! res)))))
                   (current-xml:space-preserve 0)))
                ((character-data)
                 (let ((s (cadr head)))
                   (or (and (not (current-xml:space-preserve))
                            (no-s s))
                       (acc! s))))
                ((comment)
                 ;; ignore
                 #t)
                (else
                 (acc! head)))
              (loop tail))))))

  (crunch-1 (xml->tree port (parser))))

(define (one port)
  (pretty-print (crunch port))
  (force-output))

(define (main args)
  (call-with-input-file (cadr args)
    one)
  (exit #t))

;;; a1-nf3-mixp ends here
