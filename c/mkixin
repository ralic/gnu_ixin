#!/bin/sh
exec ${GUILE-guile} -e '(mkixin)' -s $0 "$@" # -*- scheme -*-
!#
;;; mkixin

;; Copyright (C) 2012 Thien-Thi Nguyen
;;
;; This file is part of IXIN.
;;
;; IXIN is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; IXIN is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with IXIN.  If not, see <http://www.gnu.org/licenses/>.

;;; Code:

(setlocale LC_ALL "")

(load "./z-fixed-pp.scm")

(define-module (mkixin)
  #:export (main))

(use-modules
 ((srfi srfi-1) #:select (break!
                          car+cdr
                          take drop))
 ((srfi srfi-11) #:select (let-values
                           let*-values))
 ((srfi srfi-13) #:select (string-drop-right))
 ((ice-9 pretty-print) #:select (pretty-print))
 ((ice-9 rdelim) #:select (read-line write-line)))

(define (ppp port)
  (lambda (x)
    (pretty-print x port)))

;; NF stands for "normal form 3": (ELEMENT (@ (ATTR VALUE)...) CHILD...).
;; The degenerate case:           (ELEMENT (@))

(define (symbol<-attribute-ref nf name)
  (string->symbol
   (car (assq-ref (cdadr nf)
                  name))))

(define (kids nf)
  (cddr nf))

(define (element? element)
  (lambda (nf)
    (eq? element (car nf))))

(define-macro (FE . args)
  (let ((proc (car (last-pair args))))
    `(for-each ,proc ,@(delq proc args))))

(define (walker proc)
  (define (walk nf)
    (cond ((pair? nf)
           (proc nf)
           (FE (kids nf) walk))))
  walk)

(define (walker/cozy proc kons)
  (define (walk up nf)
    (cond ((pair? nf)
           (proc up nf)
           (FE (kids nf)
               (let ((new-up (kons (car nf) up)))
                 (lambda (kid)
                   (walk new-up kid)))))))
  walk)

(define (find-printindex node)
  (define printindex? (element? 'printindex))
  (call-with-current-continuation
   (lambda (return)
     ((walker (lambda (nf)
                (and (printindex? nf)
                     (return (string->symbol (caddr nf))))))
      node)
     #f)))

(define (fs s . args)
  (apply simple-format #f s args))

(define (how-to-handle filename)
  (values (string-drop-right filename (string-length ".sxml"))
          (lambda ()
            (call-with-input-file filename
              read))))

(define (txi-vars-as-settings variables settings)
  (let ((fix '((txicodequoteundirected . codequoteundirected)
               (txicodequotebacktick   . codequotebacktick)
               (txideftypefnnl         . deftypefnnewline))))
    (let loop ((acc '()) (ls variables))
      (if (pair? ls)
          (loop (let ((pair (car ls)))
                  (cond ((assq-ref fix (car pair))
                         => (lambda (setting)
                              (set! settings
                                    (cons (list setting 'on)
                                          settings))
                              acc))
                        (else
                         (cons pair acc))))
                (cdr ls))
          (values                       ; 2 rv
           (reverse! acc)
           settings)))))

(define (rescue meta)                   ; from (S)XML, well, partially
                                        ;   obviously, Someone needs
                                        ;     to learn (S)XLST  :-/

  (let-values (((attributes rest) (car+cdr meta)))

    (define (grab-xid! element)         ; external identifiers
      (or (and=> (assq-ref rest element)
                 (lambda (x)
                   (set! rest (assq-remove! rest element)) ; DWR!
                   (cadr x)))
          'none))

    (define (grab-variables!)
      (let loop ((acc '()))
        (cond ((assq 'setvalue rest)
               => (lambda (sub)
                    (set! rest (delq! sub rest)) ; DWR!
                    (loop (acons (symbol<-attribute-ref sub 'name)
                                 (kids sub)
                                 acc))))
              (else
               (reverse! acc)))))

    (define (grab/dedup-copying!)
      (let-values (((copying new-rest) (break! (element? 'titlepage)
                                               rest)))
        (set! rest new-rest)            ; DWR!
        (or (null? rest)
            (let* ((len (length copying))
                   (tp (car rest))      ; titlepage
                   (body (kids tp))
                   (blen (length body)))
              (let loop ((left blen)
                         (ls body))
                (cond ((> len left))
                      ((and (equal? (car copying) (car ls))
                            (equal? copying (take ls len)))
                       (let* ((tp-rest (drop ls len))
                              (new-tp (append (take body (- blen left))
                                              (list '(insertcopying (@)))
                                              tp-rest))
                              (attr (cadr tp))
                              (new-attr `(@ (copying "copying")
                                            ,@(cdr attr))))
                         (set-cdr! tp (cons new-attr new-tp))))
                      (else
                       (loop (1- left)
                             (cdr ls)))))))
        `(copying (@) ,@copying)))

    (define (extract-toc x)
      (let ((toc '())
            (yes (map element? '(contents
                                 shortcontents
                                 summarycontents))))
        (FE x (walker (lambda (nf)
                        (FE yes (lambda (interesting?)
                                  (and (interesting? nf)
                                       (set! toc (cons (car nf)
                                                       toc))))))))
        (reverse! toc)))

    (let* ((xid (map grab-xid! '(setfilename
                                 settitle
                                 dircategory)))
           (variables (grab-variables!))
           (settings '())               ; TODO
           (copying (grab/dedup-copying!)))

      ;; Magic!
      (let-values (((new-v new-s) (txi-vars-as-settings variables settings)))
        (set! variables new-v)
        (set! settings new-s))

      ;; rv
      `(,(cdr attributes)               ; omit ‘(@)’
        ,xid
        ,variables
        ,settings
        ,copying
        ,(car rest)                     ; titlepage
        ,(extract-toc (cdr rest))))))

(define node-id (make-object-property))

(define (document-term-sets nodes)

  (define font (make-object-property))

  (define (manager name)
    (let ((key (make-object-property))
          (default-font (case name
                          ;; builtin (info "(texinfo) Predefined Indices")
                          ((cp) 'r)
                          ((fn ky pg tp vr) 'code)
                          ;; NB: Input SXML from makeinfo 4.13 does not
                          ;; include ‘def{code}index’ info; we must guess.
                          (else 'r)))
          (ls '()))

      (define (keyed/simplify! elem id)

        (define (actual x)
          (if (pair? x)
              (string-concatenate (map actual (kids x)))
              x))

        (let* ((term (kids elem))
               (ent (list
                     ;; Simplify (STRING) => STRING, maybe.
                     (if (and (string? (car term))
                              (null? (cdr term)))
                         (car term)
                         term)
                     id)))
          (set! (font ent) (or (font elem) default-font))
          (set! (key ent) (actual elem))
          ent))

      (define (merge-duplicate-terms! ls)
        (let ((orig ls))
          (let loop ((n 1) (ls orig))
            (if (pair? (cdr ls))
                (apply loop
                       (let ((was (car ls))
                             (cur (cadr ls)))
                         (define term: car)
                         (define ids:  cdr)
                         (cond ((and (equal? (term: cur)
                                             (term: was))
                                     (eq? (font cur)
                                          (font was)))
                                (set-cdr! was (sort (append! (ids: cur)
                                                             (ids: was))
                                                    <))
                                (set-cdr! ls (cddr ls))
                                (list n ls))
                               (else
                                (list (1+ n) (cdr ls))))))
                (values n orig)))))

      (define (write! port)

        (define (cur)
          (ftell port))

        (define pp (ppp port))

        (let-values (((count ls) (merge-duplicate-terms!
                                  (sort ls (lambda (a b)
                                             (string-ci< (key a)
                                                         (key b)))))))
          (let ((before (cur)))
            (pp (list count default-font))
            (FE (map (lambda (ent)
                       (if (eq? default-font (font ent))
                           ent
                           (cons '- ent)))
                     ls)
                pp)
            (list name
                  (- (cur) before)))))

      ;; rv
      (lambda (one two)
        (if one
            (set! ls (cons (keyed/simplify! one two)
                           ls))
            (write! two)))))

  (define (collect-indexterm! get-mgr)

    (define (pluck node)
      (let ((it? (element? 'indexterm)))
        (lambda (parent nf)
          (cond ((it? nf)
                 (and (eq? 'definitionterm parent)
                      (set! (font nf) 'code))
                 ((get-mgr (symbol<-attribute-ref nf 'index))
                  nf
                  (node-id node)))))))

    (lambda (node)
      ((walker/cozy (pluck node) (lambda (parent ignored)
                                   parent))
       #f
       node)))

  (let ((all '()))

    (define (get-mgr type)
      (or (assq-ref all type)
          (let ((m (manager type)))
            (set! all (acons type m all))
            m)))

    (FE nodes (collect-indexterm! get-mgr))
    (if (null? all)
        all
        (let* ((port (open-output-file "TMP-W-DTS"))
               (counts (map (lambda (mgr)
                              (mgr #f port))
                            (map cdr all))))
          (close-port port)
          counts))))

(define (section-tree nodes)
  (let* ((title? (element? 'title))
         (lev-1 '(top chapter unnumbered appendix))
         (lev-2 '(section unnumberedsec appendixsec))
         (lev-3 '(subsection unnumberedsubsec appendixsubsec))
         (lev-4 '(subsubsection unnumberedsubsubsec appendixsubsubsec))
         (ok `(the-good-earth ,@lev-1
                              ,@lev-2
                              ,@lev-3
                              ,@lev-4))
         (ni #f)
         (last 0)
         (rv (make-vector 5 '())))

    (define (vr i)       (vector-ref rv i))
    (define (v! i value) (vector-set! rv i value))

    (define (level name)
      (cond ((memq name lev-1) 1)
            ((memq name lev-2) 2)
            ((memq name lev-3) 3)
            ((memq name lev-4) 4)
            (else 0)))

    (define (try x)
      (and (memq (car x) ok)
           (let* ((name (car x))
                  (lev (level name))
                  (rel (- lev last))
                  (ent (list (cons* ni name
                                    (let ((first (and (pair? (kids x))
                                                      (caddr x))))
                                      (and first
                                           (title? first)
                                           (kids first)))))))
             (and (negative? rel)
                  (let loop ((old last))
                    (or (= lev old)
                        ;; Flip and tuck the out-hanging leaves.
                        (let* ((branch (reverse! (vr old)))
                               (par (1- old))
                               (lucky (car (vr par))))
                          (v! old (list))
                          (set-cdr! (last-pair lucky)
                                    branch)
                          (loop par)))))
             (v! lev (if (positive? rel)
                         ;; new bud
                         (list ent)
                         ;; grow current branch
                         (cons ent (vr lev))))
             (set! last lev))))

    (let ((walk (walker try)))
      (v! 0 (list (list 'the-good-earth)))
      (FE nodes (lambda (node)
                  (set! ni (node-id node))
                  (FE (kids node) walk)))
      (walk '(the-good-earth over-my-head))
      (cdadr (vr 0)))))

(define (identify nodes)

  (define four (map element? '(nodename
                               nodenext
                               nodeprev
                               nodeup)))

  (define (maybe-four! node)
    (let ((tail (cdr node)))

      (define (xnode! interesting?)
        (let ((nf (cadr tail)))
          (and (interesting? nf)
               (let ((string (car (kids nf))))
                 (delq! nf tail)        ; DWR!
                 string))))

      (map xnode! four)))

  (let* ((count (length nodes))
         (ids (iota count))
         (full (map maybe-four! nodes))
         (names (map car full)))

    (define id<-name
      (let ((alist (map cons names ids)))
        ;; id<-name
        (lambda (name)
          (or (assoc-ref alist name)
              -1))))

    (FE ids nodes
        (lambda (id node)
          (set! (node-id node) id)))

    (values count
            names
            (map (lambda (loc)
                   (map id<-name loc))
                 (map cdr full)))))

(define (do-it! filename)
  (let*-values (((stem snarf) (how-to-handle filename))
                ((meta nodes) (break! (element? 'node)
                                      (cdr (snarf))))
                ((count names locs) (identify nodes)))
    (let* ((coding 'utf-8)              ; TODO
           (pnodes (open-output-file "TMP-W-NODES"))
           (pp-nodes (ppp pnodes))
           (index (make-vector count #f))
           (top -1)
           (dts (document-term-sets nodes)))

      (define lonely-dts
        (let ((acc '()))
          ;; lonely-dts
          (lambda x
            (cond ((pair? x)
                   (set! acc (cons x acc))
                   x)
                  (else acc)))))

      (define (grok! name loc node)

        (define (stash!)

          (define (sz)
            (ftell pnodes))

          (let ((bef (sz)))
            (pp-nodes (cdr node))
            (force-output)
            ;; Subtract 1 to ignore the trailing newline.
            (- (sz) bef 1)))

        (let ((len (stash!))
              (id (node-id node)))
          (and (negative? (caddr loc))
               (set! top id))
          (vector-set! index id (cons* name len loc))
          (and=> (find-printindex node)
                 (lambda (type)
                   (let ((lp (last-pair (or (assq type dts)
                                            (lonely-dts type 0)))))
                     (set-cdr! lp (cons id (cdr lp))))))))

      (define (write-index!)
        (call-with-output-file "TMP-W-INDEX"
          (lambda (port)
            (let ((pp-i (ppp port)))
              (do ((i 0 (1+ i)))
                  ((= count i))
                (pp-i (vector-ref index i))))
            (force-output)
            (ftell port))))

      (define (write-section-tree!)
        (call-with-output-file "TMP-W-S-TREE"
          (lambda (port)
            (pretty-print (section-tree nodes) port)
            (force-output)
            (ftell port))))

      (FE names locs nodes grok!)
      (let* ((index-length (write-index!))
             (s-tree-length (write-section-tree!))
             (ixin (string-append stem ".ixin"))
             (port (open-output-file ixin)))

        (define (fso s . args)
          (apply simple-format port s args))

        (close-port pnodes)
        (fso "ixin 1; -*- coding: ~A -*-~%" coding)
        (pretty-print (rescue meta) port)
        (fso "~S~%" (list index-length count top
                          s-tree-length
                          (append dts (lonely-dts))))
        (close-port port)
        (let ((tail (fs "TMP-W-INDEX TMP-W-S-TREE ~A TMP-W-NODES"
                        (if (pair? dts)
                            "TMP-W-DTS"
                            ""))))

          (define (fsys s . args)
            (zero? (system (apply fs s args))))

          (and (fsys "cat ~A >> ~A" tail ixin)
               (fsys "rm  ~A" tail)))))))

(define (main args)
  (exit (FE (cdr (command-line))
            do-it!)))

;;; mkixin ends here
