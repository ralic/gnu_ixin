#!/bin/sh
exec ${GUILE-guile} -e '(mkixin)' -s $0 "$@" # -*- scheme -*-
!#
;;; mkixin

;; Copyright (C) 2012 Thien-Thi Nguyen
;;
;; This file is part of IXIN.
;;
;; IXIN is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; IXIN is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with IXIN.  If not, see <http://www.gnu.org/licenses/>.

;;; Code:

(setlocale LC_ALL "")

(load "./z-fixed-pp.scm")

(define-module (mkixin)
  #:export (main))

(use-modules
 ((srfi srfi-1) #:select (break!
                          car+cdr
                          take drop))
 ((srfi srfi-11) #:select (let-values
                           let*-values))
 ((srfi srfi-13) #:select (string-drop-right
                           string-trim-both
                           string-suffix-ci?))
 ((ice-9 pretty-print) #:select (pretty-print))
 ((ice-9 popen) #:select (open-input-pipe close-pipe))
 ((ice-9 rdelim) #:select (read-line write-line read-delimited)))

(define (ppp port)
  (lambda (x)
    (pretty-print x port)))

;; NF stands for "normal form 3": (ELEMENT (@ (ATTR VALUE)...) CHILD...).
;; The degenerate case:           (ELEMENT (@))

(define (attribute-ref nf name)
  (car (assq-ref (cdadr nf)
                 name)))

(define (symbol<-attribute-ref nf name)
  (string->symbol
   (attribute-ref nf name)))

(define (kids nf)
  (cddr nf))

(define (element? element)
  (lambda (nf)
    (eq? element (car nf))))

(define-macro (FE . args)
  (let ((proc (car (last-pair args))))
    `(for-each ,proc ,@(delq proc args))))

(define (walker proc)
  (define (walk nf)
    (cond ((pair? nf)
           (proc nf)
           (FE (kids nf) walk))))
  walk)

(define (walker/cozy proc kons)
  (define (walk up nf)
    (cond ((pair? nf)
           (proc up nf)
           (FE (kids nf)
               (let ((new-up (kons (car nf) up)))
                 (lambda (kid)
                   (walk new-up kid)))))))
  walk)

(define (at-first interesting nf proc)
  (let ((interesting? (element? interesting)))
    (call-with-current-continuation
     (lambda (return)
       ((walker (lambda (nf)
                  (and (interesting? nf)
                       (return (proc nf)))))
        nf)
       #f))))

(define (symbol/hyphen<-string s)
  (if (string-null? s)
      '-
      (string->symbol s)))

(define (find-listoffloats node)
  (at-first 'listoffloats node
            (lambda (nf)
              (symbol/hyphen<-string
               (attribute-ref nf 'type)))))

(define (find-printindex node)
  (at-first 'printindex node
            (lambda (nf)
              (string->symbol (car (kids nf))))))

(define (fs s . args)
  (apply simple-format #f s args))

(define (how-to-handle filename)
  (values (string-drop-right filename (string-length ".sxml"))
          (lambda ()
            (call-with-input-file filename
              read))))

(define (txi-vars-as-settings variables settings)
  (let ((fix '((txicodequoteundirected . codequoteundirected)
               (txicodequotebacktick   . codequotebacktick)
               (txideftypefnnl         . deftypefnnewline))))
    (let loop ((acc '()) (ls variables))
      (if (pair? ls)
          (loop (let ((pair (car ls)))
                  (cond ((assq-ref fix (car pair))
                         => (lambda (setting)
                              (set! settings
                                    (cons (list setting 'on)
                                          settings))
                              acc))
                        (else
                         (cons pair acc))))
                (cdr ls))
          (values                       ; 2 rv
           (reverse! acc)
           settings)))))

(define (rescue meta)                   ; from (S)XML, well, partially
                                        ;   obviously, Someone needs
                                        ;     to learn (S)XLST  :-/

  (let-values (((attributes rest) (car+cdr meta)))

    (define (grab-lang! nf)
      (set! rest (delq! nf rest))       ; DWR!
      (let ((s (if (pair? (kids nf))
                   (car (kids nf))
                   (attribute-ref nf 'xml:lang))))

        (define (subsym beg end)
          (string->symbol (substring s beg end)))

        ;; Obligingly unfubar makeinfo 4.13 output.
        (case (string-length s)
          ((8) (list (subsym 3 5)
                     (subsym 6 8)))
          ((5) (list (subsym 0 2)
                     (subsym 3 5)))
          ((2) (subsym 0 2))
          (else (error "unhandled lang:" s)))))

    (define (grab-xid! lang)            ; external identifiers

      (define (x! element proc)
        (or (and=> (assq-ref rest element)
                   (lambda (x)
                     (set! rest (assq-remove! rest element)) ; DWR!
                     (proc x)))
            '-))

      (define (x!string element)
        (x! element cadr))

      (define (nice x)

        (define (x!ent nf)

          (define (first-kid element)
            (at-first element nf (lambda (nf)
                                   (car (kids nf)))))

          (cons* (first-kid 'menutitle)
                 (first-kid 'menunode)
                 (at-first 'menudescription nf
                           (lambda (nf)
                             (at-first 'pre nf
                                       (lambda (nf)
                                         (map string-trim-both
                                              (kids nf))))))))

        (map x!ent (cdr x)))

      (list (x!string 'setfilename)
            lang
            (x!string 'settitle)
            (x!string 'dircategory)
            (x! 'direntry nice)))

    (define (grab-variables!)
      (let loop ((acc '()))
        (cond ((assq 'setvalue rest)
               => (lambda (sub)
                    (set! rest (delq! sub rest)) ; DWR!
                    (loop (acons (symbol<-attribute-ref sub 'name)
                                 (kids sub)
                                 acc))))
              (else
               (reverse! acc)))))

    (define (grab/dedup-copying!)
      (let-values (((copying new-rest) (break! (element? 'titlepage)
                                               rest)))
        (set! rest new-rest)            ; DWR!
        (or (null? rest)
            (let* ((len (length copying))
                   (tp (car rest))      ; titlepage
                   (body (kids tp))
                   (blen (length body)))
              (let loop ((left blen)
                         (ls body))
                (cond ((> len left))
                      ((and (equal? (car copying) (car ls))
                            (equal? copying (take ls len)))
                       (let* ((tp-rest (drop ls len))
                              (new-tp (append (take body (- blen left))
                                              (list '(insertcopying (@)))
                                              tp-rest))
                              (attr (cadr tp))
                              (new-attr `(@ (copying "copying")
                                            ,@(cdr attr))))
                         (set-cdr! tp (cons new-attr new-tp))))
                      (else
                       (loop (1- left)
                             (cdr ls)))))))
        (and (pair? copying)
             `(copying (@) ,@copying))))

    (define (extract-toc x)
      (let ((toc '())
            (yes (map element? '(contents
                                 shortcontents
                                 summarycontents))))
        (FE x (walker (lambda (nf)
                        (FE yes (lambda (interesting?)
                                  (and (interesting? nf)
                                       (set! toc (cons (car nf)
                                                       toc))))))))
        (reverse! toc)))

    (let* ((lang (and=> (assq 'documentlanguage rest)
                        grab-lang!))
           (xid (grab-xid! (or lang '(en US))))
           (variables (grab-variables!))
           (settings (cond (lang `((documentlanguage ,lang)))
                           (else '()))) ; TODO
           (copying (grab/dedup-copying!)))

      ;; Magic!
      (let-values (((new-v new-s) (txi-vars-as-settings variables settings)))
        (set! variables new-v)
        (set! settings new-s))

      ;; rv
      `(,(cdr attributes)               ; omit ‘(@)’
        ,xid
        ,variables
        ,settings
        ,(or copying '-)
        ,(car rest)                     ; titlepage
        ,(extract-toc (cdr rest))))))

(define node-id (make-object-property))

(define (simplified ls)
  ;; Simplify (STRING) => STRING, maybe.
  (if (and (string? (car ls))
           (null? (cdr ls)))
      (car ls)
      ls))

(define (floating-environments nodes)
  (let ((all '()))

    (define (plucker id)

      (lambda (nf)

        (define (w/ element proc)
          (at-first element nf proc))

        (let* ((type (at-first 'floattype nf
                               (lambda (nf)
                                 (let ((ls (kids nf)))
                                   (if (pair? ls)
                                       (symbol/hyphen<-string (car ls))
                                       '-)))))
               (slot (or (assq type all)
                         (let ((s (list type)))
                           (set! all (cons s all))
                           s))))
          (set-cdr! slot
                    (cons (list
                           ;; name
                           (attribute-ref nf 'name)
                           ;; short-caption
                           (or (w/ 'shortcaption
                                   (lambda (nf)
                                     (simplified (kids nf))))
                               '-)
                           id)
                          (cdr slot))))))

    (define (write! pp cur)
      (lambda (type ents)
        (let ((count (length ents))
              (bef (cur)))
          (pp (list count))
          (FE (reverse! ents) pp)
          (force-output)
          (list type
                (- (cur) bef)))))

    (let ((float? (element? 'float)))
      (FE nodes (lambda (node)
                  (let ((pluck! (plucker (node-id node))))
                    ((walker (lambda (nf)
                               (and (float? nf)
                                    (pluck! nf))))
                     node)))))

    (if (null? all)
        all
        (let* ((port (open-output-file "TMP-W-FLOSETS"))
               (pp (ppp port))
               (counts (map (write! pp (lambda ()
                                         (ftell port)))
                            (map car all)
                            (map cdr all))))
          (close-port port)
          counts))))

(define (document-term-sets nodes)

  (define font (make-object-property))

  (define (manager name)
    (let ((key (make-object-property))
          (default-font (case name
                          ;; builtin (info "(texinfo) Predefined Indices")
                          ((cp) 'r)
                          ((fn ky pg tp vr) 'code)
                          ;; NB: Input SXML from makeinfo 4.13 does not
                          ;; include ‘def{code}index’ info; we must guess.
                          (else 'r)))
          (ls '()))

      (define (keyed/simplify! elem id)

        (define (actual x)
          (if (pair? x)
              (string-concatenate (map actual (kids x)))
              x))

        (let ((ent (list (simplified (kids elem))
                         id)))
          (set! (font ent) (or (font elem) default-font))
          (set! (key ent) (actual elem))
          ent))

      (define (merge-duplicate-terms! ls)
        (let ((orig ls))
          (let loop ((n 1) (ls orig))
            (if (pair? (cdr ls))
                (apply loop
                       (let ((was (car ls))
                             (cur (cadr ls)))
                         (define term: car)
                         (define ids:  cdr)
                         (cond ((and (equal? (term: cur)
                                             (term: was))
                                     (eq? (font cur)
                                          (font was)))
                                (set-cdr! was (sort (append! (ids: cur)
                                                             (ids: was))
                                                    <))
                                (set-cdr! ls (cddr ls))
                                (list n ls))
                               (else
                                (list (1+ n) (cdr ls))))))
                (values n orig)))))

      (define (write! port)

        (define (cur)
          (ftell port))

        (define pp (ppp port))

        (let-values (((count ls) (merge-duplicate-terms!
                                  (sort ls (lambda (a b)
                                             (string-ci< (key a)
                                                         (key b)))))))
          (let ((before (cur)))
            (pp (list count default-font))
            (FE (map (lambda (ent)
                       (if (eq? default-font (font ent))
                           ent
                           (cons '- ent)))
                     ls)
                pp)
            (list name
                  (- (cur) before)))))

      ;; rv
      (lambda (one two)
        (if one
            (set! ls (cons (keyed/simplify! one two)
                           ls))
            (write! two)))))

  (define (collect-indexterm! get-mgr)

    (define (pluck node)
      (let ((it? (element? 'indexterm)))
        (lambda (parent nf)
          (cond ((it? nf)
                 (and (eq? 'definitionterm parent)
                      (set! (font nf) 'code))
                 ((get-mgr (symbol<-attribute-ref nf 'index))
                  nf
                  (node-id node)))))))

    (lambda (node)
      ((walker/cozy (pluck node) (lambda (parent ignored)
                                   parent))
       #f
       node)))

  (let ((all '()))

    (define (get-mgr type)
      (or (assq-ref all type)
          (let ((m (manager type)))
            (set! all (acons type m all))
            m)))

    (FE nodes (collect-indexterm! get-mgr))
    (if (null? all)
        all
        (let* ((port (open-output-file "TMP-W-DTS"))
               (counts (map (lambda (mgr)
                              (mgr #f port))
                            (map cdr all))))
          (close-port port)
          counts))))

(define (section-tree nodes)
  (let* ((title? (element? 'title))
         (lev-1 '(top chapter unnumbered appendix))
         (lev-2 '(section unnumberedsec appendixsec))
         (lev-3 '(subsection unnumberedsubsec appendixsubsec))
         (lev-4 '(subsubsection unnumberedsubsubsec appendixsubsubsec))
         (ok `(the-good-earth ,@lev-1
                              ,@lev-2
                              ,@lev-3
                              ,@lev-4))
         (ni #f)
         (last 0)
         (rv (make-vector 5 '())))

    (define (vr i)       (vector-ref rv i))
    (define (v! i value) (vector-set! rv i value))

    (define (level name)
      (cond ((memq name lev-1) 1)
            ((memq name lev-2) 2)
            ((memq name lev-3) 3)
            ((memq name lev-4) 4)
            (else 0)))

    (define (try x)
      (and (memq (car x) ok)
           (let* ((name (car x))
                  (lev (level name))
                  (rel (- lev last))
                  (ent (list (cons* ni name
                                    (let ((first (and (pair? (kids x))
                                                      (caddr x))))
                                      (and first
                                           (title? first)
                                           (kids first)))))))
             (and (negative? rel)
                  (let loop ((old last))
                    (or (= lev old)
                        ;; Flip and tuck the out-hanging leaves.
                        (let* ((branch (reverse! (vr old)))
                               (par (1- old))
                               (lucky (car (vr par))))
                          (v! old (list))
                          (set-cdr! (last-pair lucky)
                                    branch)
                          (loop par)))))
             (v! lev (if (positive? rel)
                         ;; new bud
                         (list ent)
                         ;; grow current branch
                         (cons ent (vr lev))))
             (set! last lev))))

    (let ((walk (walker try)))
      (v! 0 (list (list 'the-good-earth)))
      (FE nodes (lambda (node)
                  (set! ni (node-id node))
                  (FE (kids node) walk)))
      (walk '(the-good-earth over-my-head))
      (cdadr (vr 0)))))

(define (identify nodes)

  (define four (map element? '(nodename
                               nodenext
                               nodeprev
                               nodeup)))

  (define (maybe-four! node)
    (let ((tail (cdr node)))

      (define (xnode! interesting?)
        (let ((nf (cadr tail)))
          (and (interesting? nf)
               (let ((string (car (kids nf))))
                 (delq! nf tail)        ; DWR!
                 string))))

      (map xnode! four)))

  (let* ((count (length nodes))
         (ids (iota count))
         (full (map maybe-four! nodes))
         (names (map car full)))

    (define id<-name
      (let ((alist (map cons names ids)))
        ;; id<-name
        (lambda (name)
          (or (assoc-ref alist name)
              -1))))

    (FE ids nodes
        (lambda (id node)
          (set! (node-id node) id)))

    (values count
            names
            (map (lambda (loc)
                   (map id<-name loc))
                 (map cdr full)))))

(define (string<-shell-command s . args)
  (read-delimited "" (open-input-pipe (apply fs s args))))

(define (hang! ls . args)
  (append! ls args))

(define (inline-images! dir)

  (define (expand filename ext)

    (define (try ext)
      (let ((full (fs "~A~A" (in-vicinity dir filename) ext)))
        (and (file-exists? full)
             full)))

    ;; Mimic Info processor: (info "(texinfo) Image Syntax")
    (or (try ext)
        (try (fs ".~A" ext))
        (try ".png")
        (try ".jpg")))

  (define (guess-mime-type filename)
    (fs "image/~A"
        (cond ((string-suffix-ci? ".png" filename) 'png)
              ((string-suffix-ci? ".jpg" filename) jpeg)
              ((string-suffix-ci? ".jpeg" filename) 'jpeg)
              (else 'unknown))))

  (define (inline! nf)
    (and=> (expand (attribute-ref nf 'name)
                   (attribute-ref nf 'extension))
           (lambda (filename)
             (hang! (cadr nf)           ; DWR! attributes
                    `(type ,(guess-mime-type filename))
                    '(encoding "base64"))
             (hang! (kids nf)           ; DWR! children
                    (string-drop-right
                     (string<-shell-command "base64 ~A" filename)
                     ;; omit final newline
                     1)))))

  ;; rv
  (walker (let ((image? (element? 'image)))
            (lambda (nf)
              (and (image? nf)
                   (inline! nf))))))

(define (two-phase-accumulator)
  (let ((acc '()))
    ;; rv
    (lambda x
      (cond ((pair? x)
             (set! acc (cons x acc))
             x)
            (else acc)))))

(define (do-it! filename)
  (let*-values (((stem snarf) (how-to-handle filename))
                ((meta nodes) (break! (element? 'node)
                                      (cdr (snarf))))
                ((count names locs) (identify nodes)))
    (FE nodes (inline-images! (dirname filename)))
    (let* ((coding 'utf-8)              ; TODO
           (pnodes (open-output-file "TMP-W-NODES"))
           (pp-nodes (ppp pnodes))
           (index (make-vector count #f))
           (top -1)
           (flosets (floating-environments nodes))
           (lonely-flosets (two-phase-accumulator))
           (dts (document-term-sets nodes))
           (lonely-dts (two-phase-accumulator)))

      (define (grok! name loc node)

        (define (stash!)

          (define (sz)
            (ftell pnodes))

          (let ((bef (sz)))
            (pp-nodes (cdr node))
            (force-output)
            ;; Subtract 1 to ignore the trailing newline.
            (- (sz) bef 1)))

        (let ((len (stash!))
              (id (node-id node)))

          (define (note-summary! look known lonely)
            (and=> (look node)
                   (lambda (key)
                     (let ((lp (last-pair (or (assq key known)
                                              (lonely key 0)))))
                       (set-cdr! lp (cons id (cdr lp)))))))

          (and (negative? (caddr loc))
               (set! top id))
          (vector-set! index id (cons* name len loc))
          (note-summary! find-listoffloats flosets lonely-flosets)
          (note-summary! find-printindex dts lonely-dts)))

      (define (write-index!)
        (call-with-output-file "TMP-W-INDEX"
          (lambda (port)
            (let ((pp-i (ppp port)))
              (do ((i 0 (1+ i)))
                  ((= count i))
                (pp-i (vector-ref index i))))
            (force-output)
            (ftell port))))

      (define (write-section-tree!)
        (call-with-output-file "TMP-W-S-TREE"
          (lambda (port)
            (pretty-print (section-tree nodes) port)
            (force-output)
            (ftell port))))

      (FE names locs nodes grok!)
      (let* ((index-length (write-index!))
             (s-tree-length (write-section-tree!))
             (ixin (string-append stem ".ixin"))
             (port (open-output-file ixin)))

        (define (fso s . args)
          (apply simple-format port s args))

        (close-port pnodes)
        (fso "ixin 1; -*- coding: ~A -*-~%" coding)
        (pretty-print (rescue meta) port)
        (fso "~S~%" (list index-length count top
                          s-tree-length
                          (append dts (lonely-dts))
                          (append flosets (lonely-flosets))))
        (close-port port)
        (let ((tail (fs "TMP-W-INDEX TMP-W-S-TREE ~A ~A TMP-W-NODES"
                        (if (pair? dts)
                            "TMP-W-DTS"
                            "")
                        (if (pair? flosets)
                            "TMP-W-FLOSETS"
                            ""))))

          (define (fsys s . args)
            (zero? (system (apply fs s args))))

          (and (fsys "cat ~A >> ~A" tail ixin)
               (fsys "rm  ~A" tail)))))))

(define (main args)
  (exit (FE (cdr (command-line))
            do-it!)))

;;; mkixin ends here
