#!/bin/sh
exec ${GUILE-guile} -e '(mkixin)' -s $0 "$@" # -*- scheme -*-
!#
;;; mkixin

;; Copyright (C) 2012, 2013 Thien-Thi Nguyen
;;
;; This file is part of IXIN.
;;
;; IXIN is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; IXIN is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with IXIN.  If not, see <http://www.gnu.org/licenses/>.

;;; Code:

(setlocale LC_ALL "")

(load "./z-fixed-pp.scm")

(define-module (mkixin)
  #:export (main))

(use-modules
 ((srfi srfi-1) #:select (break!
                          car+cdr
                          partition!
                          remove!
                          every
                          take drop))
 ((srfi srfi-2) #:select (and-let*))
 ((srfi srfi-11) #:select (let-values
                           let*-values))
 ((srfi srfi-13) #:select (substring/shared
                           string-join
                           string-every
                           string-take
                           string-drop
                           string-drop-right
                           string-trim-both
                           string-index
                           string-skip
                           string-skip-right
                           string-suffix-ci?))
 ((srfi srfi-14) #:select (char-set:whitespace
                           char-set:letter+digit
                           char-set:ascii
                           char-set-intersection
                           char-set-adjoin!))
 ((ice-9 pretty-print) #:select (pretty-print))
 ((ice-9 popen) #:select (open-input-pipe close-pipe))
 ((ice-9 rdelim) #:select (read-line write-line read-delimited)))

(define (ppp port)
  (lambda (x)
    (pretty-print x port)))

;; NF stands for "normal form 3": (ELEMENT (@ (ATTR VALUE)...) CHILD...).
;; The degenerate case:           (ELEMENT (@))

(define (attribute-try nf name proc)
  (and=> (assq-ref (cdadr nf)
                   name)
         (lambda (ls)
           (proc (car ls)))))

(define (attribute-ref nf name)
  (attribute-try nf name identity))

(define (symbol<-attribute-ref nf name)
  (string->symbol
   (attribute-ref nf name)))

(define (kids nf)
  (cddr nf))

(define (element? element)
  (lambda (nf)
    (eq? element (car nf))))

(define-macro (FE . args)
  (let ((proc (car (last-pair args))))
    `(for-each ,proc ,@(delq proc args))))

(define (walker proc)
  (define (walk nf)
    (cond ((pair? nf)
           (proc nf)
           (FE (kids nf) walk))))
  walk)

(define (walker/cozy proc kons)
  (define (walk up nf)
    (cond ((pair? nf)
           (proc up nf)
           (FE (kids nf)
               (let ((new-up (kons (car nf) up)))
                 (lambda (kid)
                   (walk new-up kid)))))))
  walk)

(define (at-first interesting nf proc)
  (let ((interesting? (element? interesting)))
    (call-with-current-continuation
     (lambda (return)
       ((walker (lambda (nf)
                  (and (interesting? nf)
                       (return (proc nf)))))
        nf)
       #f))))

(define (symbol/hyphen<-string s)
  (if (string-null? s)
      '-
      (string->symbol s)))

(define (find-listoffloats node)
  (at-first 'listoffloats node
            (lambda (nf)
              (symbol/hyphen<-string
               (attribute-ref nf 'type)))))

(define (find-printindex cur?)

  (define get (if cur?
                  (lambda (nf)
                    (attribute-ref nf 'value))
                  (lambda (nf)
                    (car (kids nf)))))

  (lambda (node)
    (at-first 'printindex node
              (lambda (nf)
                (string->symbol (get nf))))))

;; Express "0-based index", yet avoid the word "index"!
(define position (make-object-property))

(define (positioned alist . x)
  (let ((ht (make-hash-table)))
    (let loop ((ls alist) (id 0))
      (cond ((pair? ls)
             (hash-set! ht (caar ls) id)
             (loop (cdr ls) (1+ id)))
            (else
             (set! (position x) (lambda (k)
                                  (hash-ref ht k)))
             x)))))

(define (fs s . args)
  (apply simple-format #f s args))

(define (initial nf)
  (let ((loc (kids nf)))
    (and (pair? loc)
         (let ((kid (car loc)))
           (if (string? kid)
               loc
               (initial kid))))))

(define nice-strings!
  (walker
   (lambda (nf)

     (define (final nf)
       (let ((ls (kids nf)))
         (and (pair? ls)
              (let* ((loc (last-pair ls))
                     (kid (car loc)))
                (if (string? kid)
                    ls
                    (final kid))))))

     (define (trim-ws nf)
       ;; beg
       (and-let* ((loc (initial nf))
                  (s (car loc))
                  (bad (string-skip s #\newline))
                  ((positive? bad)))
         (set-car! loc (string-drop s bad)))
       ;; end
       (and-let* ((ls (final nf))
                  (loc (last-pair ls))
                  (s (car loc)))
         (cond ((string-skip-right s char-set:whitespace)
                => (lambda (n)
                     (let ((bad (- (string-length s)
                                   n
                                   1)))
                       (and (positive? bad)
                            (set-car! loc (string-drop-right s bad))))))
               (else
                ;; No non-whitespace chars (i.e., all whitespace) => zonk!
                (set-cdr! ls (delq s ls))))))

     (define s/newline/space/g
       (walker (lambda (nf)
                 (or (equal? "preserve" (attribute-ref nf 'xml:space))
                     (FE (kids nf)
                         (lambda (kid)
                           (and (string? kid)
                                (let loop ((start 0))
                                  (cond ((string-index kid #\newline start)
                                         => (lambda (pos)
                                              (string-set! kid pos #\space)
                                              (loop (1+ pos)))))))))))))

     (case (car nf)
       ((para)
        (trim-ws nf)
        (s/newline/space/g nf))
       ((pre example smallexample
             lisp    smalllisp
             display smalldisplay
             format  smallformat
             verbatim quotation flushleft flushright cartouche)
        (trim-ws nf))))))

(define (block-mangler dir)

  (define (fsys s . args)
    (zero? (system (apply fs s args))))

  (define (bye)
    (fsys "rm -rf ~A" dir))

  (and (file-exists? dir)
       (or (bye)
           (error "cannot remove old temporary dir:" dir)))
  (mkdir dir)
  (let ((filenames '())
        (all '()))

    (define (one kind)
      (let* ((filename (in-vicinity dir (fs "W-~A" kind)))
             (port (open-output-file filename))
             (pp (ppp port)))

        (define (act proc)
          (proc pp))

        (define (cur)
          (force-output)
          (ftell port))

        (define (bye)
          (let ((size (cur)))
            (close-port port)
            size))

        (define (dispatch command . args)
          (case command
            ((act) (act (car args)))
            ((cur) (cur))
            ((bye) (bye))))

        (set! filenames (acons kind filename filenames))
        (set! all (acons kind dispatch all))
        dispatch))

    (define (finish ixin kinds)
      (and (fsys "cat ~A >> ~A"
                 (string-join (map (lambda (kind)
                                     (assq-ref filenames kind))
                                   kinds))
                 ixin)
           (or (bye)
               (error "cannot remove dir:" dir))))

    ;; rv
    (lambda (command . args)
      (case command
        ((new) (apply one args))
        ((finish) (apply finish args))))))

(define (how-to-handle filename)
  (let ((stem (string-drop-right filename (string-length ".sxml"))))
    (values stem
            (lambda ()
              (let ((tree (call-with-input-file filename
                            read)))
                (nice-strings! tree)
                tree))
            (block-mangler (fs "~A.ixin-blocks" stem)))))

(define (txi-vars-as-settings variables settings)
  (let ((fix '((txicodequoteundirected . codequoteundirected)
               (txicodequotebacktick   . codequotebacktick)
               (txideftypefnnl         . deftypefnnewline))))
    (let loop ((acc '()) (ls variables))
      (if (pair? ls)
          (loop (let ((pair (car ls)))
                  (cond ((assq-ref fix (car pair))
                         => (lambda (setting)
                              (set! settings
                                    (cons (list setting 'on)
                                          settings))
                              acc))
                        (else
                         (cons pair acc))))
                (cdr ls))
          (values                       ; 2 rv
           (reverse! acc)
           settings)))))

(define (rescue cur? meta)              ; from (S)XML, well, partially
                                        ;   obviously, Someone needs
                                        ;     to learn (S)XLST  :-/

  (let ((rest (cdr meta)))

    (define (grab-lang! nf)
      (set! rest (delq! nf rest))       ; DWR!
      (let ((s (if (pair? (kids nf))
                   (car (kids nf))
                   (attribute-ref nf 'xml:lang))))

        (define (subsym beg end)
          (string->symbol (substring s beg end)))

        ;; Obligingly unfubar makeinfo 4.13 output.
        (case (string-length s)
          ((8) (list (subsym 3 5)
                     (subsym 6 8)))
          ((5) (list (subsym 0 2)
                     (subsym 3 5)))
          ((2) (subsym 0 2))
          (else (error "unhandled lang:" s)))))

    (define (grab-xid! lang)            ; external identifiers

      (define (x! element proc)
        (or (and=> (assq-ref rest element)
                   (lambda (x)
                     (set! rest (assq-remove! rest element)) ; DWR!
                     (proc x)))
            '-))

      (define (nice-title ls)
        (set! ls (cdr ls))
        (cond ((null? ls)
               '-)
              ((and (string? (car ls))
                    (null? (cdr ls)))
               (car ls))
              (else
               ls)))

      (define (nice x)

        (define (x!ent nf)

          (define (first-kid element)
            (at-first element nf (lambda (nf)
                                   (car (kids nf)))))

          (define (separate-on-newline kids)
            (let loop ((ls kids) (acc (list '())))

              (define (more! x)
                (set-car! acc (cons x (car acc))))

              (define (split! kid pos)
                (let ((bef (string-take kid pos)))
                  (or (string-null? bef)
                      (more! bef))
                  (loop (cond ((string-skip kid char-set:whitespace pos)
                               => (lambda (new)
                                    (cons (string-drop kid new)
                                          (cdr ls))))
                              (else
                               (cdr ls)))
                        (cons '() acc))))

              (if (pair? ls)
                  (let ((kid (car ls)))
                    (or (and-let* (((string? kid))
                                   (pos (string-index kid #\newline)))
                          (split! kid pos))
                        (begin
                          (more! kid)
                          (loop (cdr ls) acc))))
                  ;; rv
                  (map simplified
                       (reverse! (map reverse!
                                      (delq! '() acc)))))))

          (cons* (first-kid 'menutitle)
                 (first-kid 'menunode)
                 (at-first 'menudescription nf
                           (lambda (nf)
                             (at-first 'pre nf
                                       (lambda (nf)
                                         (separate-on-newline
                                          (kids nf))))))))

        (map x!ent (cdr x)))

      (define (x!invitations)
        (let-values (((ls new-rest) (partition! (lambda (x)
                                                  (memq (car x)
                                                        '(dircategory
                                                          direntry)))
                                                rest)))
          (set! rest new-rest)
          (and (pair? ls)
               (let loop ((acc '()) (ls ls))
                 (if (pair? ls)
                     (loop (let ((nf (car ls)))
                             (case (car nf)
                               ((dircategory)
                                (cons (list (car (kids nf)))
                                      acc))
                               ((direntry)
                                (let ((ents (nice (cdr nf))))
                                  (if (null? acc)
                                      (list (cons '- ents))
                                      (cons (append! (car acc) ents)
                                            (cdr acc)))))))
                           (cdr ls))
                     (reverse! acc))))))

      (list (x! 'setfilename cadr)
            lang
            (x! 'settitle nice-title)
            (or (x!invitations) '-)))

    (define (grab-variables!)
      (let loop ((acc '()))
        (cond ((assq (if cur? 'set 'setvalue) rest)
               => (lambda (sub)
                    (set! rest (delq! sub rest)) ; DWR!
                    (loop (acons (symbol<-attribute-ref sub 'name)
                                 (kids sub)
                                 acc))))
              (else
               (reverse! acc)))))

    (define (grab-copying!)
      (let ((copying (assq 'copying rest)))
        (set! rest (delq! copying rest)) ; DWR!
        copying))

    (define (grab/dedup-copying!)
      (let-values (((copying new-rest) (break! (element? 'titlepage)
                                               rest)))
        (set! rest new-rest)            ; DWR!
        (or (null? rest)
            (let* ((len (length copying))
                   (tp (car rest))      ; titlepage
                   (body (kids tp))
                   (blen (length body)))
              (let loop ((left blen)
                         (ls body))
                (cond ((> len left))
                      ((and (equal? (car copying) (car ls))
                            (equal? copying (take ls len)))
                       (let ((tp-rest (drop ls len)))
                         (set-cdr! (cdr tp)
                                   (append (take body (- blen left))
                                           (list '(insertcopying (@)))
                                           tp-rest))))
                      (else
                       (loop (1- left)
                             (cdr ls)))))))
        (and (pair? copying)
             `(copying (@) ,@copying))))

    (define (grab-titlepage!)
      (let ((nf (assq 'titlepage rest)))
        (set! rest (delq! nf rest))
        nf))

    (define (grab-toc!)
      (let ((toc '())
            (yes (map element? '(contents
                                 shortcontents
                                 summarycontents))))
        (FE rest (walker (lambda (nf)
                           (FE yes (lambda (interesting?)
                                     (and (interesting? nf)
                                          (set! toc (cons (car nf)
                                                          toc))))))))
        (FE toc (lambda (element)
                  (set! rest (assq-remove! rest element))))
        (reverse! toc)))

    (let* ((lang (and=> (assq 'documentlanguage rest)
                        grab-lang!))
           (xid (grab-xid! (or lang '(en US))))
           (variables (grab-variables!))
           (settings (cond (lang `((documentlanguage ,lang)))
                           (else '()))) ; TODO
           (copying ((if cur?
                         grab-copying!
                         grab/dedup-copying!)))
           (titlepage (grab-titlepage!))
           (toc (grab-toc!)))

      (and (pair? rest)
           (let ((cep (current-error-port)))

             (define (fse s . args)
               (apply simple-format cep s args))

             (fse "PEBCAK-WARNING: unhandled pre-‘node’ SXML!~%")
             (FE (iota (length rest)) rest
                 (lambda (i x)
                   (fse "~A:\t~S~%" i x)))))

      ;; Magic!
      (let-values (((new-v new-s) (txi-vars-as-settings variables settings)))
        (set! variables new-v)
        (set! settings new-s))

      ;; rv
      `(,xid
        ,variables
        ,settings
        ,(or copying '-)
        ,titlepage
        ,toc))))

(define node-id (make-object-property))

(define (simplified ls)
  ;; Simplify (ATOM) => ATOM, maybe.
  (if (and (not (pair? (car ls)))
           (null? (cdr ls)))
      (car ls)
      ls))

(define (float-type nf)
  (at-first 'floattype nf
            (lambda (nf)
              (let ((ls (kids nf)))
                (if (pair? ls)
                    (symbol/hyphen<-string (car ls))
                    '-)))))

(define (float-name cur? nf)
  (if cur?
      (at-first 'floatname nf (lambda (nf)
                                (car (kids nf))))
      (attribute-ref nf 'name)))

(define (floating-environments mkblk cur? nodes)
  (let ((all '()))

    (define (plucker id)

      (lambda (nf)

        (define (w/ element proc)
          (at-first element nf proc))

        (let* ((type (float-type nf))
               (slot (or (assq type all)
                         (let ((s (list type)))
                           (set! all (cons s all))
                           s))))
          (set-cdr! slot
                    (cons (list
                           ;; name
                           (float-name cur? nf)
                           ;; short-caption
                           (or (w/ 'shortcaption
                                   (lambda (nf)
                                     (simplified (kids nf))))
                               '-)
                           id)
                          (cdr slot))))))

    (define (write! blk)
      (lambda (pair)
        (let-values (((type ents) (car+cdr pair)))
          (let ((count (length ents))
                (ents (reverse! ents))
                (bef (blk 'cur)))
            (blk 'act (lambda (pp)
                        (pp (list count))
                        (FE ents pp)))
            (positioned ents type (- (blk 'cur) bef))))))

    (let ((float? (element? 'float)))
      (FE nodes (lambda (node)
                  (let ((pluck! (plucker (node-id node))))
                    ((walker (lambda (nf)
                               (and (float? nf)
                                    (pluck! nf))))
                     node)))))

    (if (null? all)
        all
        (let* ((blk (mkblk))
               (counts (map (write! blk)
                            all)))
          (blk 'bye)
          counts))))

(define (document-term-sets mkblk cur? setup nodes)

  (define default-font
    (let ((syn (map (lambda (nf)
                      (cons (symbol<-attribute-ref nf 'from)
                            (case (car nf)
                              ((synindex) 'r)
                              ((syncodeindex) 'code))))
                    (car setup)))
          (def (map (lambda (nf)
                      (cons (symbol<-attribute-ref nf 'value)
                            (case (car nf)
                              ((defindex) 'r)
                              ((defcodeindex) 'code))))
                    (cdr setup))))
      ;; default font
      (lambda (name)
        (or (assq-ref syn name)
            (assq-ref def name)
            (case name
              ;; builtin (info "(texinfo) Predefined Indices")
              ((cp) 'r)
              ((fn ky pg tp vr) 'code)
              (else
               ;; NB: Input SXML from makeinfo 4.13 does not
               ;; include ‘{def,syn}{code}index’ info; we must guess.
               'r))))))

  (define font (make-object-property))

  (define (manager name)
    (let ((key (make-object-property))
          (default-font (default-font name))
          (ls '()))

      (define (keyed/simplify! elem id)

        (define (actual x)
          (if (pair? x)
              (string-concatenate (map actual (kids x)))
              x))

        (let ((ent (list (simplified (kids elem))
                         id)))
          (set! (font ent) (or (font elem) default-font))
          (set! (key ent) (actual elem))
          ent))

      (define (merge-duplicate-terms! ls)
        (let ((orig ls))
          (let loop ((n 1) (ls orig))
            (if (pair? (cdr ls))
                (apply loop
                       (let ((was (car ls))
                             (cur (cadr ls)))
                         (define term: car)
                         (define ids:  cdr)
                         (cond ((and (equal? (term: cur)
                                             (term: was))
                                     (eq? (font cur)
                                          (font was)))
                                (set-cdr! was (sort (append! (ids: cur)
                                                             (ids: was))
                                                    <))
                                (set-cdr! ls (cddr ls))
                                (list n ls))
                               (else
                                (list (1+ n) (cdr ls))))))
                (values n orig)))))

      (define (write! blk)

        (define (cur)
          (blk 'cur))

        (let-values (((count ls) (merge-duplicate-terms!
                                  (sort ls (lambda (a b)
                                             (string-ci< (key a)
                                                         (key b)))))))
          (let ((before (cur)))
            (blk 'act (lambda (pp)
                        (pp (list count default-font))
                        (FE (map (lambda (ent)
                                   (if (eq? default-font (font ent))
                                       ent
                                       (cons '- ent)))
                                 ls)
                            pp)))
            (positioned ls name (- (cur) before)))))

      ;; rv
      (lambda (one two)
        (if one
            (set! ls (cons (keyed/simplify! one two)
                           ls))
            (write! two)))))

  (define (collect-indexterm! get-mgr)

    (define (pluck node)
      (let ((it? (element? 'indexterm)))
        (lambda (parent nf)

          (define (type!/cur)

            (define (attry name proc)
              (attribute-try nf name proc))

            (let ((orig (symbol<-attribute-ref nf 'index)))
              (set! (font nf) (default-font orig))
              (or (attry 'mergedindex string->symbol)
                  orig)))

          (define (type!/old)
            (and (eq? 'definitionterm parent)
                 (set! (font nf) 'code))
            (symbol<-attribute-ref nf 'index))

          (cond ((it? nf)
                 ((get-mgr ((if cur?
                                type!/cur
                                type!/old)))
                  nf
                  (node-id node)))))))

    (lambda (node)
      ((walker/cozy (pluck node) (lambda (parent ignored)
                                   parent))
       #f
       node)))

  (let ((all '()))

    (define (get-mgr type)
      (or (assq-ref all type)
          (let ((m (manager type)))
            (set! all (acons type m all))
            m)))

    (FE nodes (collect-indexterm! get-mgr))
    (if (null? all)
        all
        (let* ((blk (mkblk))
               (counts (map (lambda (mgr)
                              (mgr #f blk))
                            (map cdr all))))
          (blk 'bye)
          counts))))

(define (section-tree cur? nodes)
  (let* ((title? (element? (if cur? 'sectiontitle 'title)))
         (lev-1 '(top chapter unnumbered appendix))
         (lev-2 '(section unnumberedsec appendixsec))
         (lev-3 '(subsection unnumberedsubsec appendixsubsec))
         (lev-4 '(subsubsection unnumberedsubsubsec appendixsubsubsec))
         (ok `(the-good-earth ,@lev-1
                              ,@lev-2
                              ,@lev-3
                              ,@lev-4))
         (ni #f)
         (last 0)
         (rv (make-vector 5 '())))

    (define (vr i)       (vector-ref rv i))
    (define (v! i value) (vector-set! rv i value))

    (define (level name)
      (cond ((memq name lev-1) 1)
            ((memq name lev-2) 2)
            ((memq name lev-3) 3)
            ((memq name lev-4) 4)
            (else 0)))

    (define (try x)
      (and (memq (car x) ok)
           (let* ((name (car x))
                  (lev (level name))
                  (rel (- lev last))
                  (ent (list (cons* ni name
                                    (let ((first (and (pair? (kids x))
                                                      (caddr x))))
                                      (and first
                                           (title? first)
                                           (kids first)))))))
             (and (negative? rel)
                  (let loop ((old last))
                    (or (= lev old)
                        ;; Flip and tuck the out-hanging leaves.
                        (let* ((branch (reverse! (vr old)))
                               (par (1- old))
                               (lucky (car (vr par))))
                          (v! old (list))
                          (set-cdr! (last-pair lucky)
                                    branch)
                          (loop par)))))
             (v! lev (if (positive? rel)
                         ;; new bud
                         (list ent)
                         ;; grow current branch
                         (cons ent (vr lev))))
             (set! last lev))))

    (let ((walk (walker try)))
      (v! 0 (list (list 'the-good-earth)))
      (FE nodes (lambda (node)
                  (set! ni (node-id node))
                  (FE (kids node) walk)))
      (walk '(the-good-earth over-my-head))
      (cdadr (vr 0)))))

(define IGNORABLE
  ;; Elements of the input SXML that we can safely ignore a priori.
  '(filename
    preamble
    macro
    alias
    include
    bye))

(define (tuck nf)

  (define (neglecting-some-kids nf)
    (remove! (lambda (kid)
               (and (pair? kid)
                    (memq (car kid) IGNORABLE)))
             (cdr nf)))

  (define node? (element? 'node))

  (define (bef+aft ls)
    (break! node? ls))

  (define (normalize meta rest)
    (let loop ((acc '()) (ls rest))

      (define (continue subsumed todo)
        (loop (cons (append!
                     ;; a ‘node’ element:
                     ;;  (node (@) (nodename) (nodenext) (nodeprev) (nodeup))
                     (car ls)
                     ;; list of non-‘node’ elements:
                     ;;  ((top) (chapter) ...)
                     subsumed)
                    acc)
              todo))

      (define (boundary-info)
        (let*-values (((nne more) (car+cdr (cdr ls))) ; non-‘node’ element
                      ((safe hi) (bef+aft (cdr nne))))
          (values (cons (car nne) safe) ; head
                  hi
                  more)))

      (if (pair? ls)
          (let-values (((head hi more) (boundary-info)))
            ;; Does the first non-‘node’ element contain ‘node’?
            (if (pair? hi)
                ;; Yes; loop at the boundary.
                (continue (list head)
                          (append hi more))
                ;; No; find the boundary in successors, and loop there.
                (let-values (((safe-too later) (bef+aft more)))
                  (continue (cons head safe-too)
                            later))))
          (values meta (reverse! acc)))))

  (define (extract-dts-setup meta)

    (define (segregate! ls interesting)
      (partition! (lambda (x)
                    (memq (car x) interesting))
                  ls))

    (let*-values (((syn rest) (segregate! meta '(synindex syncodeindex)))
                  ((def meta) (segregate! rest '(defindex defcodeindex))))
      (values (cons syn def)
              meta)))

  (define w/o-useless-attributes
    (let ((useless '(leadingtext
                     separator
                     endspaces
                     spaces
                     line))
          (particularly `(,@(map (lambda (element)
                                   (list element 'index))
                                 '(cindex findex kindex pindex tindex
                                          vindex indexcommand))
                          (indexterm incode)
                          ;; Add other particulars here.
                          )))
      ;; w/o-useless-attributes
      (lambda (nf)

        (define (useless? pair)
          (let ((name (car pair)))
            (or (memq name useless)
                (and=> (assq-ref particularly (car nf))
                       (lambda (particularly-useless)
                         (memq name particularly-useless))))))

        (let ((attr (cadr nf)))
          (set-cdr! attr (remove! useless? (cdr attr)))))))

  ;; do it!
  ((walker neglecting-some-kids) nf)
  (let-values (((meta rest) (bef+aft (cdr nf))))
    (if (every node? rest)
        (values #f '(()) meta rest)
        (let*-values (((meta rest) (normalize meta rest))
                      ((dts-setup meta) (extract-dts-setup meta)))
          (let ((prune-attributes (walker w/o-useless-attributes)))
            (prune-attributes (cons #f meta))
            (FE rest prune-attributes)
            (values #t dts-setup meta rest))))))

(define (labels mkblk names nodes)

  (define (label name node)
    (or (and-let* ((label (attribute-ref node 'name)))
          (if (string=? label name)
              '=
              label))
        '-))

  (let ((known (map label names nodes))
        (ok (char-set-adjoin! (char-set-intersection
                               char-set:letter+digit
                               char-set:ascii)
                              #\_ #\-))
        (acc '()))

    (define (acc! . x)
      (set! acc (cons x acc)))

    (define (get id)
      (lambda (nf)
        (and-let* ((element (car nf))
                   ((not (memq element '(set setvalue clear clearvalue))))
                   (label (attribute-ref nf 'name))
                   ;; Don't be fooled by makeinfo 4.13 and earlier.
                   ((string-every ok label)))
          (acc! label id element))))

    (FE nodes (lambda (node)
                (FE (kids node)
                    (walker (get (node-id node))))))
    (let ((sorry (every (lambda (label)
                          (eq? '- label))
                        known)))
      (if (and (null? acc)
               sorry)
          0
          (let ((blk (mkblk)))
            (blk 'act (lambda (pp)
                        (pp (cons (length acc)
                                  (if sorry
                                      '()
                                      known)))
                        (FE acc pp)))
            (blk 'bye))))))

(define (identify nodes)

  (define four (map element? '(nodename
                               nodenext
                               nodeprev
                               nodeup)))

  (define (maybe-four! node)
    (let ((tail (cdr node)))

      (define (xnode! interesting?)
        (let ((nf (cadr tail)))
          (and (interesting? nf)
               (let ((string (car (kids nf))))
                 (delq! nf tail)        ; DWR!
                 string))))

      (map xnode! four)))

  (let* ((count (length nodes))
         (ids (iota count))
         (full (map maybe-four! nodes))
         (names (map car full)))

    (define try (position (apply positioned full nodes)))

    (define (id<-name name)
      (or (try name)
          -1))

    (FE ids nodes
        (lambda (id node)
          (set! (node-id node) id)))
    (set! (position nodes) try)
    (values count
            names
            (map (lambda (loc)
                   (map id<-name loc))
                 (map cdr full)))))

(define (string<-shell-command s . args)
  (read-delimited "" (open-input-pipe (apply fs s args))))

(define (hang! ls . args)
  (append! ls args))

(define (inline-images! cur? dir)

  (define (expand filename ext)

    (define (try ext)
      (let ((full (fs "~A~A" (in-vicinity dir filename) ext)))
        (and (file-exists? full)
             full)))

    ;; Mimic Info processor: (info "(texinfo) Image Syntax")
    (or (try ext)
        (try (fs ".~A" ext))
        (try ".png")
        (try ".jpg")))

  (define (guess-mime-type filename)
    (fs "image/~A"
        (cond ((string-suffix-ci? ".png" filename) 'png)
              ((string-suffix-ci? ".jpg" filename) jpeg)
              ((string-suffix-ci? ".jpeg" filename) 'jpeg)
              (else 'unknown))))

  (define (inline! nf)
    (and=> (if cur?
               (expand (car (kids (assq 'imagefile (cdr nf))))
                       "")
               (expand (attribute-ref nf 'name)
                       (attribute-ref nf 'extension)))
           (lambda (filename)
             (hang! (cadr nf)           ; DWR! attributes
                    `(type ,(guess-mime-type filename))
                    '(encoding "base64"))
             (hang! (kids nf)           ; DWR! children
                    (string-drop-right
                     (string<-shell-command "base64 ~A" filename)
                     ;; omit final newline
                     1)))))

  ;; rv
  (walker (let ((image? (element? 'image)))
            (lambda (nf)
              (and (image? nf)
                   (inline! nf))))))

(define (two-phase-accumulator)
  (let ((acc '()))
    ;; rv
    (lambda x
      (cond ((pair? x)
             (set! acc (cons x acc))
             x)
            (else acc)))))

(define (do-it! filename)
  (let*-values (((stem snarf blk) (how-to-handle filename))
                ((cur? dts-setup meta nodes) (tuck (snarf)))
                ((count names locs) (identify nodes)))

    (define (mkblk nick)
      (lambda ()
        (blk 'new nick)))

    (FE nodes (inline-images! cur? (dirname filename)))
    (let* ((coding 'utf-8)              ; TODO
           (nblk ((mkblk 'nodes)))
           (labels-len (labels (mkblk 'labels) names nodes))
           (index (make-vector count #f))
           (flosets (floating-environments (mkblk 'flosets) cur? nodes))
           (lonely-flosets (two-phase-accumulator))
           (dts (document-term-sets (mkblk 'dts) cur? dts-setup nodes))
           (lonely-dts (two-phase-accumulator)))

      (define (dedup! nf)

        (define id<-node-name
          (let ((try (position nodes)))
            ;; id<-node-name
            (lambda (full)
              (try (if (char=? #\( (string-ref full 0))
                       (string-trim-both
                        (substring/shared full (1+ (string-index full #\)))))
                       full)))))

        (define (id<-document-term dts-name term)
          ((position (assq dts-name dts))
           (simplified term)))

        (define (id<-float type name)
          ((position (assq type flosets))
           name))

        (define (zcoord! zonk position . family)
          (and zonk (assq-remove! (cadr nf) zonk))
          (hang! (cadr nf)
                 (list 'ixcc            ; cartesian coordinate
                       (fs "(~A ~A)"
                           (simplified family)
                           position))))

        (define (coord! . coord)
          (apply zcoord! #f coord))

        (define (kids! ls)
          (set-cdr! (cdr nf) ls))

        (case (car nf)

          ((menunode)
           (and-let* ((kids (kids nf))
                      (id (id<-node-name (car kids))))
             (coord! id 'node)
             (kids! (cdr kids))))

          ((indexterm)
           (let ((name (string->symbol
                        (or (attribute-ref nf 'mergedindex)
                            (attribute-ref nf 'index)))))
             (zcoord! 'index (id<-document-term name (kids nf))
                      'dts name)
             (kids! '())))

          ((float)
           (let ((type (float-type nf)))
             (zcoord! 'name (id<-float type (float-name cur? nf))
                      'floset type)
             (FE '(floattype floatpos shortcaption)
                 (let ((rest (cdr nf)))
                   (lambda (element)
                     (assq-remove! rest element))))))

          ((ref xref pxref)
           ;; Don't touch external ‘xref’.
           (or (pair? (cdr (kids nf)))
               (and-let* ((name-nf (assq 'xrefnodename (cdr nf)))
                          (id (id<-node-name (car (kids name-nf)))))
                 (coord! id 'node)
                 (kids! (delq name-nf (kids nf))))))))

      (define (grok! name loc node)

        (define (blk!)

          (define (sz)
            (nblk 'cur))

          (let ((bef (sz)))
            (nblk 'act (lambda (pp)
                         (pp (cdr node))))
            ;; Subtract 1 to ignore the trailing newline.
            (- (sz) bef 1)))

        ((walker dedup!) node)
        (let ((len (blk!))
              (id (node-id node)))

          (define (note-summary! look known lonely)
            (and=> (look node)
                   (lambda (key)
                     (let ((lp (last-pair (or (assq key known)
                                              (lonely key 0)))))
                       (set-cdr! lp (cons id (cdr lp)))))))

          (vector-set! index id (cons* name len loc))
          (note-summary! find-listoffloats flosets lonely-flosets)
          (note-summary! (find-printindex cur?) dts lonely-dts)))

      (define (write-index!)
        (let ((blk ((mkblk 'node-index))))
          (blk 'act (lambda (pp)
                      (do ((i 0 (1+ i)))
                          ((= count i))
                        (pp (vector-ref index i)))))
          (blk 'bye)))

      (define (write-section-tree!)
        (let ((blk ((mkblk 's-tree))))
          (blk 'act (lambda (pp)
                      (pp (section-tree cur? nodes))))
          (blk 'bye)))

      (FE names locs nodes grok!)
      (let* ((index-length (write-index!))
             (s-tree-length (write-section-tree!))
             (ixin (string-append stem ".ixin"))
             (port (open-output-file ixin)))

        (define (fso s . args)
          (apply simple-format port s args))

        (nblk 'bye)
        (fso "ixin 1; -*- coding: ~A -*-~%" coding)
        (pretty-print (rescue cur? meta) port)
        (fso "~S~%" (list index-length count
                          s-tree-length labels-len
                          (append dts (lonely-dts))
                          (append flosets (lonely-flosets))))
        (close-port port)
        (blk 'finish ixin `(node-index
                            s-tree
                            ,@(if (positive? labels-len)
                                  '(labels)
                                  '())
                            ,@(if (pair? dts)
                                  '(dts)
                                  '())
                            ,@(if (pair? flosets)
                                  '(flosets)
                                  '())
                            nodes))))))

(define (main args)
  (exit (FE (cdr (command-line))
            do-it!)))

;;; mkixin ends here
