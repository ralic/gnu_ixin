#!/bin/sh
exec ${GUILE-guile} -e '(mkixin)' -s $0 "$@" # -*- scheme -*-
!#
;;; mkixin

;; Copyright (C) 2012 Thien-Thi Nguyen
;;
;; This file is part of IXIN.
;;
;; IXIN is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; IXIN is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with IXIN.  If not, see <http://www.gnu.org/licenses/>.

;;; Code:

(setlocale LC_ALL "")

(load "./z-fixed-pp.scm")

(define-module (mkixin)
  #:export (main))

(use-modules
 ((srfi srfi-1) #:select (break!
                          car+cdr
                          partition!
                          remove!
                          every
                          take drop))
 ((srfi srfi-2) #:select (and-let*))
 ((srfi srfi-11) #:select (let-values
                           let*-values))
 ((srfi srfi-13) #:select (substring/shared
                           string-drop
                           string-drop-right
                           string-trim-both
                           string-index
                           string-skip
                           string-skip-right
                           string-suffix-ci?))
 ((srfi srfi-14) #:select (char-set:whitespace))
 ((ice-9 pretty-print) #:select (pretty-print))
 ((ice-9 popen) #:select (open-input-pipe close-pipe))
 ((ice-9 rdelim) #:select (read-line write-line read-delimited)))

(define (ppp port)
  (lambda (x)
    (pretty-print x port)))

;; NF stands for "normal form 3": (ELEMENT (@ (ATTR VALUE)...) CHILD...).
;; The degenerate case:           (ELEMENT (@))

(define (attribute-try nf name proc)
  (and=> (assq-ref (cdadr nf)
                   name)
         proc))

(define (attribute-ref nf name)
  (attribute-try nf name car))

(define (symbol<-attribute-ref nf name)
  (string->symbol
   (attribute-ref nf name)))

(define (kids nf)
  (cddr nf))

(define (element? element)
  (lambda (nf)
    (eq? element (car nf))))

(define-macro (FE . args)
  (let ((proc (car (last-pair args))))
    `(for-each ,proc ,@(delq proc args))))

(define (walker proc)
  (define (walk nf)
    (cond ((pair? nf)
           (proc nf)
           (FE (kids nf) walk))))
  walk)

(define (walker/cozy proc kons)
  (define (walk up nf)
    (cond ((pair? nf)
           (proc up nf)
           (FE (kids nf)
               (let ((new-up (kons (car nf) up)))
                 (lambda (kid)
                   (walk new-up kid)))))))
  walk)

(define (at-first interesting nf proc)
  (let ((interesting? (element? interesting)))
    (call-with-current-continuation
     (lambda (return)
       ((walker (lambda (nf)
                  (and (interesting? nf)
                       (return (proc nf)))))
        nf)
       #f))))

(define (symbol/hyphen<-string s)
  (if (string-null? s)
      '-
      (string->symbol s)))

(define (find-listoffloats node)
  (at-first 'listoffloats node
            (lambda (nf)
              (symbol/hyphen<-string
               (attribute-ref nf 'type)))))

(define (find-printindex cur?)

  (define get (if cur?
                  (lambda (nf)
                    (attribute-ref nf 'value))
                  (lambda (nf)
                    (car (kids nf)))))

  (lambda (node)
    (at-first 'printindex node
              (lambda (nf)
                (string->symbol (get nf))))))

;; Express "0-based index", yet avoid the word "index"!
(define position (make-object-property))

(define (positioned alist . x)
  (let ((ht (make-hash-table)))
    (let loop ((ls alist) (id 0))
      (cond ((pair? ls)
             (hash-set! ht (caar ls) id)
             (loop (cdr ls) (1+ id)))
            (else
             (set! (position x) (lambda (k)
                                  (hash-ref ht k)))
             x)))))

(define (fs s . args)
  (apply simple-format #f s args))

(define nice-strings!
  (walker
   (lambda (nf)

     (define (initial nf)
       (let ((loc (kids nf)))
         (and (pair? loc)
              (let ((kid (car loc)))
                (if (string? kid)
                    loc
                    (initial kid))))))

     (define (final nf)
       (let ((ls (kids nf)))
         (and (pair? ls)
              (let* ((loc (last-pair ls))
                     (kid (car loc)))
                (if (string? kid)
                    loc
                    (final kid))))))

     (define (trim-ws nf)
       ;; beg
       (and-let* ((loc (initial nf))
                  (s (car loc))
                  (bad (string-skip s #\newline))
                  ((positive? bad)))
         (set-car! loc (string-drop s bad)))
       ;; end
       (and-let* ((loc (final nf))
                  (s (car loc))
                  (bad (- (string-length s)
                          (string-skip-right s char-set:whitespace)
                          1))
                  ((positive? bad)))
         (set-car! loc (string-drop-right s bad))))

     (define s/newline/space/g
       (walker (lambda (nf)
                 (or (equal? "preserve" (attribute-ref nf 'xml:space))
                     (FE (kids nf)
                         (lambda (kid)
                           (and (string? kid)
                                (let loop ((start 0))
                                  (cond ((string-index kid #\newline start)
                                         => (lambda (pos)
                                              (string-set! kid pos #\space)
                                              (loop (1+ pos)))))))))))))

     (case (car nf)
       ((para)
        (trim-ws nf)
        (s/newline/space/g nf))
       ((pre example smallexample
             lisp    smalllisp
             display smalldisplay
             format  smallformat
             verbatim quotation flushleft flushright cartouche)
        (trim-ws nf))))))

(define (how-to-handle filename)
  (values (string-drop-right filename (string-length ".sxml"))
          (lambda ()
            (let ((tree (call-with-input-file filename
                          read)))
              (nice-strings! tree)
              tree))))

(define (txi-vars-as-settings variables settings)
  (let ((fix '((txicodequoteundirected . codequoteundirected)
               (txicodequotebacktick   . codequotebacktick)
               (txideftypefnnl         . deftypefnnewline))))
    (let loop ((acc '()) (ls variables))
      (if (pair? ls)
          (loop (let ((pair (car ls)))
                  (cond ((assq-ref fix (car pair))
                         => (lambda (setting)
                              (set! settings
                                    (cons (list setting 'on)
                                          settings))
                              acc))
                        (else
                         (cons pair acc))))
                (cdr ls))
          (values                       ; 2 rv
           (reverse! acc)
           settings)))))

(define (rescue cur? meta)              ; from (S)XML, well, partially
                                        ;   obviously, Someone needs
                                        ;     to learn (S)XLST  :-/

  (let-values (((attributes rest) (car+cdr meta)))

    (define (grab-lang! nf)
      (set! rest (delq! nf rest))       ; DWR!
      (let ((s (if (pair? (kids nf))
                   (car (kids nf))
                   (attribute-ref nf 'xml:lang))))

        (define (subsym beg end)
          (string->symbol (substring s beg end)))

        ;; Obligingly unfubar makeinfo 4.13 output.
        (case (string-length s)
          ((8) (list (subsym 3 5)
                     (subsym 6 8)))
          ((5) (list (subsym 0 2)
                     (subsym 3 5)))
          ((2) (subsym 0 2))
          (else (error "unhandled lang:" s)))))

    (define (grab-xid! lang)            ; external identifiers

      (define (x! element proc)
        (or (and=> (assq-ref rest element)
                   (lambda (x)
                     (set! rest (assq-remove! rest element)) ; DWR!
                     (proc x)))
            '-))

      (define (x!string element)
        (x! element cadr))

      (define (nice x)

        (define (x!ent nf)

          (define (first-kid element)
            (at-first element nf (lambda (nf)
                                   (car (kids nf)))))

          (cons* (first-kid 'menutitle)
                 (first-kid 'menunode)
                 (at-first 'menudescription nf
                           (lambda (nf)
                             (at-first 'pre nf
                                       (lambda (nf)
                                         (map string-trim-both
                                              (kids nf))))))))

        (map x!ent (cdr x)))

      (define (x!invitations)
        (let-values (((ls new-rest) (partition! (lambda (x)
                                                  (memq (car x)
                                                        '(dircategory
                                                          direntry)))
                                                rest)))
          (set! rest new-rest)
          (and (pair? ls)
               (let loop ((acc '()) (ls ls))
                 (if (pair? ls)
                     (loop (let ((nf (car ls)))
                             (case (car nf)
                               ((dircategory)
                                (cons (list (car (kids nf)))
                                      acc))
                               ((direntry)
                                (let ((ents (nice (cdr nf))))
                                  (if (null? acc)
                                      (list (cons '- ents))
                                      (cons (append! (car acc) ents)
                                            (cdr acc)))))))
                           (cdr ls))
                     (reverse! acc))))))

      (list (x!string 'setfilename)
            lang
            (x!string 'settitle)
            (or (x!invitations) '-)))

    (define (grab-variables!)
      (let loop ((acc '()))
        (cond ((assq (if cur? 'set 'setvalue) rest)
               => (lambda (sub)
                    (set! rest (delq! sub rest)) ; DWR!
                    (loop (acons (symbol<-attribute-ref sub 'name)
                                 (kids sub)
                                 acc))))
              (else
               (reverse! acc)))))

    (define (grab-copying!)
      (let ((copying (assq 'copying rest)))
        (set! rest (delq! copying rest)) ; DWR!
        copying))

    (define (grab/dedup-copying!)
      (let-values (((copying new-rest) (break! (element? 'titlepage)
                                               rest)))
        (set! rest new-rest)            ; DWR!
        (or (null? rest)
            (let* ((len (length copying))
                   (tp (car rest))      ; titlepage
                   (body (kids tp))
                   (blen (length body)))
              (let loop ((left blen)
                         (ls body))
                (cond ((> len left))
                      ((and (equal? (car copying) (car ls))
                            (equal? copying (take ls len)))
                       (let ((tp-rest (drop ls len)))
                         (set-cdr! (cdr tp)
                                   (append (take body (- blen left))
                                           (list '(insertcopying (@)))
                                           tp-rest))))
                      (else
                       (loop (1- left)
                             (cdr ls)))))))
        (and (pair? copying)
             `(copying (@) ,@copying))))

    (define (grab-titlepage!)
      (let ((nf (assq 'titlepage rest)))
        (set! rest (delq! nf rest))
        nf))

    (define (grab-toc!)
      (let ((toc '())
            (yes (map element? '(contents
                                 shortcontents
                                 summarycontents))))
        (FE rest (walker (lambda (nf)
                           (FE yes (lambda (interesting?)
                                     (and (interesting? nf)
                                          (set! toc (cons (car nf)
                                                          toc))))))))
        (FE toc (lambda (element)
                  (set! rest (assq-remove! rest element))))
        (reverse! toc)))

    (let* ((lang (and=> (assq 'documentlanguage rest)
                        grab-lang!))
           (xid (grab-xid! (or lang '(en US))))
           (variables (grab-variables!))
           (settings (cond (lang `((documentlanguage ,lang)))
                           (else '()))) ; TODO
           (copying ((if cur?
                         grab-copying!
                         grab/dedup-copying!)))
           (titlepage (grab-titlepage!))
           (toc (grab-toc!)))

      (and (pair? rest)
           (let ((cep (current-error-port)))

             (define (fse s . args)
               (apply simple-format cep s args))

             (fse "PEBCAK-WARNING: unhandled pre-‘node’ SXML!~%")
             (FE (iota (length rest)) rest
                 (lambda (i x)
                   (fse "~A:\t~S~%" i x)))))

      ;; Magic!
      (let-values (((new-v new-s) (txi-vars-as-settings variables settings)))
        (set! variables new-v)
        (set! settings new-s))

      ;; rv
      `(,(cdr attributes)               ; omit ‘(@)’
        ,xid
        ,variables
        ,settings
        ,(or copying '-)
        ,titlepage
        ,toc))))

(define node-id (make-object-property))

(define (simplified ls)
  ;; Simplify (ATOM) => ATOM, maybe.
  (if (and (not (pair? (car ls)))
           (null? (cdr ls)))
      (car ls)
      ls))

(define (float-type nf)
  (at-first 'floattype nf
            (lambda (nf)
              (let ((ls (kids nf)))
                (if (pair? ls)
                    (symbol/hyphen<-string (car ls))
                    '-)))))

(define (float-name cur? nf)
  (if cur?
      (at-first 'floatname nf (lambda (nf)
                                (car (kids nf))))
      (attribute-ref nf 'name)))

(define (floating-environments cur? nodes)
  (let ((all '()))

    (define (plucker id)

      (lambda (nf)

        (define (w/ element proc)
          (at-first element nf proc))

        (let* ((type (float-type nf))
               (slot (or (assq type all)
                         (let ((s (list type)))
                           (set! all (cons s all))
                           s))))
          (set-cdr! slot
                    (cons (list
                           ;; name
                           (float-name cur? nf)
                           ;; short-caption
                           (or (w/ 'shortcaption
                                   (lambda (nf)
                                     (simplified (kids nf))))
                               '-)
                           id)
                          (cdr slot))))))

    (define (write! pp cur)
      (lambda (type ents)
        (let ((count (length ents))
              (ents (reverse! ents))
              (bef (cur)))
          (pp (list count))
          (FE ents pp)
          (force-output)
          (positioned ents type (- (cur) bef)))))

    (let ((float? (element? 'float)))
      (FE nodes (lambda (node)
                  (let ((pluck! (plucker (node-id node))))
                    ((walker (lambda (nf)
                               (and (float? nf)
                                    (pluck! nf))))
                     node)))))

    (if (null? all)
        all
        (let* ((port (open-output-file "TMP-W-FLOSETS"))
               (pp (ppp port))
               (counts (map (write! pp (lambda ()
                                         (ftell port)))
                            (map car all)
                            (map cdr all))))
          (close-port port)
          counts))))

(define (document-term-sets cur? setup nodes)

  (define default-font
    (let ((new (map cons
                    (map (lambda (nf)
                           (symbol<-attribute-ref nf 'value))
                         setup)
                    (map (lambda (nf)
                           (case (car nf)
                             ((defindex) 'r)
                             ((defcodeindex) 'code)))
                         setup))))
      ;; default font
      (lambda (name)
        (case name
          ;; builtin (info "(texinfo) Predefined Indices")
          ((cp) 'r)
          ((fn ky pg tp vr) 'code)
          (else (or (assq-ref new name)
                    ;; NB: Input SXML from makeinfo 4.13 does not
                    ;; include ‘def{code}index’ info; we must guess.
                    'r))))))

  (define font (make-object-property))

  (define (manager name)
    (let ((key (make-object-property))
          (default-font (default-font name))
          (ls '()))

      (define (keyed/simplify! elem id)

        (define (actual x)
          (if (pair? x)
              (string-concatenate (map actual (kids x)))
              x))

        (let ((ent (list (simplified (kids elem))
                         id)))
          (set! (font ent) (or (font elem) default-font))
          (set! (key ent) (actual elem))
          ent))

      (define (merge-duplicate-terms! ls)
        (let ((orig ls))
          (let loop ((n 1) (ls orig))
            (if (pair? (cdr ls))
                (apply loop
                       (let ((was (car ls))
                             (cur (cadr ls)))
                         (define term: car)
                         (define ids:  cdr)
                         (cond ((and (equal? (term: cur)
                                             (term: was))
                                     (eq? (font cur)
                                          (font was)))
                                (set-cdr! was (sort (append! (ids: cur)
                                                             (ids: was))
                                                    <))
                                (set-cdr! ls (cddr ls))
                                (list n ls))
                               (else
                                (list (1+ n) (cdr ls))))))
                (values n orig)))))

      (define (write! port)

        (define (cur)
          (ftell port))

        (define pp (ppp port))

        (let-values (((count ls) (merge-duplicate-terms!
                                  (sort ls (lambda (a b)
                                             (string-ci< (key a)
                                                         (key b)))))))
          (let ((before (cur)))
            (pp (list count default-font))
            (FE (map (lambda (ent)
                       (if (eq? default-font (font ent))
                           ent
                           (cons '- ent)))
                     ls)
                pp)
            (positioned ls name (- (cur) before)))))

      ;; rv
      (lambda (one two)
        (if one
            (set! ls (cons (keyed/simplify! one two)
                           ls))
            (write! two)))))

  (define (collect-indexterm! get-mgr)

    (define (pluck node)
      (let ((it? (element? 'indexterm)))
        (lambda (parent nf)
          (cond ((it? nf)
                 (and (if cur?
                          (attribute-try nf 'incode
                                         (lambda (ls)
                                           (string=? "1" (car ls))))
                          (eq? 'definitionterm parent))
                      (set! (font nf) 'code))
                 ((get-mgr (if cur?
                               (string->symbol
                                (or (attribute-try nf 'mergedindex car)
                                    (attribute-ref nf 'index)))
                               (symbol<-attribute-ref nf 'index)))
                  nf
                  (node-id node)))))))

    (lambda (node)
      ((walker/cozy (pluck node) (lambda (parent ignored)
                                   parent))
       #f
       node)))

  (let ((all '()))

    (define (get-mgr type)
      (or (assq-ref all type)
          (let ((m (manager type)))
            (set! all (acons type m all))
            m)))

    (FE nodes (collect-indexterm! get-mgr))
    (if (null? all)
        all
        (let* ((port (open-output-file "TMP-W-DTS"))
               (counts (map (lambda (mgr)
                              (mgr #f port))
                            (map cdr all))))
          (close-port port)
          counts))))

(define (section-tree cur? nodes)
  (let* ((title? (element? (if cur? 'sectiontitle 'title)))
         (lev-1 '(top chapter unnumbered appendix))
         (lev-2 '(section unnumberedsec appendixsec))
         (lev-3 '(subsection unnumberedsubsec appendixsubsec))
         (lev-4 '(subsubsection unnumberedsubsubsec appendixsubsubsec))
         (ok `(the-good-earth ,@lev-1
                              ,@lev-2
                              ,@lev-3
                              ,@lev-4))
         (ni #f)
         (last 0)
         (rv (make-vector 5 '())))

    (define (vr i)       (vector-ref rv i))
    (define (v! i value) (vector-set! rv i value))

    (define (level name)
      (cond ((memq name lev-1) 1)
            ((memq name lev-2) 2)
            ((memq name lev-3) 3)
            ((memq name lev-4) 4)
            (else 0)))

    (define (try x)
      (and (memq (car x) ok)
           (let* ((name (car x))
                  (lev (level name))
                  (rel (- lev last))
                  (ent (list (cons* ni name
                                    (let ((first (and (pair? (kids x))
                                                      (caddr x))))
                                      (and first
                                           (title? first)
                                           (kids first)))))))
             (and (negative? rel)
                  (let loop ((old last))
                    (or (= lev old)
                        ;; Flip and tuck the out-hanging leaves.
                        (let* ((branch (reverse! (vr old)))
                               (par (1- old))
                               (lucky (car (vr par))))
                          (v! old (list))
                          (set-cdr! (last-pair lucky)
                                    branch)
                          (loop par)))))
             (v! lev (if (positive? rel)
                         ;; new bud
                         (list ent)
                         ;; grow current branch
                         (cons ent (vr lev))))
             (set! last lev))))

    (let ((walk (walker try)))
      (v! 0 (list (list 'the-good-earth)))
      (FE nodes (lambda (node)
                  (set! ni (node-id node))
                  (FE (kids node) walk)))
      (walk '(the-good-earth over-my-head))
      (cdadr (vr 0)))))

(define IGNORABLE
  ;; Top-level elements of the input SXML that we can safely ignore a priori.
  '(filename
    preamble
    ;; We laboriously infer the merged DTS, for older makeinfo,
    ;; so these are superfluous.
    synindex syncodeindex
    ;; Add elements here.
    include
    bye))

(define (tuck ls)

  (define node? (element? 'node))

  (define (bef+aft ls)
    (break! node? ls))

  (define (normalize meta rest)
    (let loop ((acc '()) (ls rest))

      (define (continue subsumed todo)
        (loop (cons (append!
                     ;; a ‘node’ element:
                     ;;  (node (@) (nodename) (nodenext) (nodeprev) (nodeup))
                     (car ls)
                     ;; list of non-‘node’ elements:
                     ;;  ((top) (chapter) ...)
                     subsumed)
                    acc)
              todo))

      (define (boundary-info)
        (let*-values (((nne more) (car+cdr (cdr ls))) ; non-‘node’ element
                      ((safe hi) (bef+aft (cdr nne))))
          (values (cons (car nne) safe) ; head
                  hi
                  more)))

      (if (pair? ls)
          (let-values (((head hi more) (boundary-info)))
            ;; Does the first non-‘node’ element contain ‘node’?
            (if (pair? hi)
                ;; Yes; loop at the boundary.
                (continue (list head)
                          (append hi more))
                ;; No; find the boundary in successors, and loop there.
                (let-values (((safe-too later) (bef+aft more)))
                  (continue (cons head safe-too)
                            later))))
          (values meta (reverse! acc)))))

  (define (extract-dts-setup meta)
    (partition! (lambda (x)
                  (memq (car x) '(defindex defcodeindex)))
                meta))

  (define w/o-macro
    (let ((macro? (element? 'macro)))

      (define (zonkable? kid)
        (and (pair? kid)
             (macro? kid)))

      ;; w/o-macro
      (lambda (nf)
        (let ((rest (cdr nf)))
          (set-cdr! rest (remove! zonkable? (cdr rest)))))))

  (define (w/o-stupid-spaces-attribute nf)
    (let ((attr (cadr nf)))
      (set-cdr! attr (assq-remove! (cdr attr) 'endspaces))
      (set-cdr! attr (assq-remove! (cdr attr) 'spaces))))

  ;; do it!
  (remove! (lambda (pair)
             (memq (car pair) IGNORABLE))
           ls)
  ((walker w/o-macro) (cons #f ls))
  (let-values (((meta rest) (bef+aft ls)))
    (if (every node? rest)
        (values #f '() meta rest)
        (let*-values (((meta rest) (normalize meta rest))
                      ((dts-setup meta) (extract-dts-setup meta)))
          (let ((zonk-spaces (walker w/o-stupid-spaces-attribute)))
            (zonk-spaces meta)
            (FE rest zonk-spaces)
            (values #t dts-setup meta rest))))))

(define (identify nodes)

  (define four (map element? '(nodename
                               nodenext
                               nodeprev
                               nodeup)))

  (define (maybe-four! node)
    (let ((tail (cdr node)))

      (define (xnode! interesting?)
        (let ((nf (cadr tail)))
          (and (interesting? nf)
               (let ((string (car (kids nf))))
                 (delq! nf tail)        ; DWR!
                 string))))

      (map xnode! four)))

  (let* ((count (length nodes))
         (ids (iota count))
         (full (map maybe-four! nodes))
         (names (map car full)))

    (define try (position (apply positioned full nodes)))

    (define (id<-name name)
      (or (try name)
          -1))

    (FE ids nodes
        (lambda (id node)
          (set! (node-id node) id)))
    (set! (position nodes) try)
    (values count
            names
            (map (lambda (loc)
                   (map id<-name loc))
                 (map cdr full)))))

(define (string<-shell-command s . args)
  (read-delimited "" (open-input-pipe (apply fs s args))))

(define (hang! ls . args)
  (append! ls args))

(define (inline-images! cur? dir)

  (define (expand filename ext)

    (define (try ext)
      (let ((full (fs "~A~A" (in-vicinity dir filename) ext)))
        (and (file-exists? full)
             full)))

    ;; Mimic Info processor: (info "(texinfo) Image Syntax")
    (or (try ext)
        (try (fs ".~A" ext))
        (try ".png")
        (try ".jpg")))

  (define (guess-mime-type filename)
    (fs "image/~A"
        (cond ((string-suffix-ci? ".png" filename) 'png)
              ((string-suffix-ci? ".jpg" filename) jpeg)
              ((string-suffix-ci? ".jpeg" filename) 'jpeg)
              (else 'unknown))))

  (define (inline! nf)
    (and=> (if cur?
               (expand (car (kids (assq 'imagefile (cdr nf))))
                       "")
               (expand (attribute-ref nf 'name)
                       (attribute-ref nf 'extension)))
           (lambda (filename)
             (hang! (cadr nf)           ; DWR! attributes
                    `(type ,(guess-mime-type filename))
                    '(encoding "base64"))
             (hang! (kids nf)           ; DWR! children
                    (string-drop-right
                     (string<-shell-command "base64 ~A" filename)
                     ;; omit final newline
                     1)))))

  ;; rv
  (walker (let ((image? (element? 'image)))
            (lambda (nf)
              (and (image? nf)
                   (inline! nf))))))

(define (two-phase-accumulator)
  (let ((acc '()))
    ;; rv
    (lambda x
      (cond ((pair? x)
             (set! acc (cons x acc))
             x)
            (else acc)))))

(define (do-it! filename)
  (let*-values (((stem snarf) (how-to-handle filename))
                ((cur? dts-setup meta nodes) (tuck (cdr (snarf))))
                ((count names locs) (identify nodes)))
    (FE nodes (inline-images! cur? (dirname filename)))
    (let* ((coding 'utf-8)              ; TODO
           (pnodes (open-output-file "TMP-W-NODES"))
           (pp-nodes (ppp pnodes))
           (index (make-vector count #f))
           (top -1)
           (flosets (floating-environments cur? nodes))
           (lonely-flosets (two-phase-accumulator))
           (dts (document-term-sets cur? dts-setup nodes))
           (lonely-dts (two-phase-accumulator)))

      (define (dedup! nf)

        (define id<-node-name
          (let ((try (position nodes)))
            ;; id<-node-name
            (lambda (full)
              (try (if (char=? #\( (string-ref full 0))
                       (string-trim-both
                        (substring/shared full (1+ (string-index full #\)))))
                       full)))))

        (define (id<-document-term dts-name term)
          ((position (assq dts-name dts))
           (simplified term)))

        (define (id<-float type name)
          ((position (assq type flosets))
           name))

        (define (zcoord! zonk position . family)
          (and zonk (assq-remove! (cadr nf) zonk))
          (hang! (cadr nf)
                 (list 'ixcc            ; cartesian coordinate
                       (fs "(~A ~A)"
                           (simplified family)
                           position))))

        (define (coord! . coord)
          (apply zcoord! #f coord))

        (define (kids! ls)
          (set-cdr! (cdr nf) ls))

        (case (car nf)

          ((menunode)
           (and-let* ((kids (kids nf))
                      (id (id<-node-name (car kids))))
             (coord! id 'node)
             (kids! (cdr kids))))

          ((indexterm)
           (let ((name (string->symbol
                        (or (attribute-try nf 'mergedindex car)
                            (attribute-ref nf 'index)))))
             (zcoord! 'index (id<-document-term name (kids nf))
                      'dts name)
             (kids! '())))

          ((float)
           (let ((type (float-type nf)))
             (zcoord! 'name (id<-float type (float-name cur? nf))
                      'floset type)
             (FE '(floattype floatpos shortcaption)
                 (let ((rest (cdr nf)))
                   (lambda (element)
                     (assq-remove! rest element))))))

          ((ref xref pxref)
           ;; Don't touch external ‘xref’.
           (or (pair? (cdr (kids nf)))
               (and-let* ((name-nf (assq 'xrefnodename (cdr nf)))
                          (id (id<-node-name (car (kids name-nf)))))
                 (coord! id 'node)
                 (kids! (delq name-nf (kids nf))))))))

      (define (grok! name loc node)

        (define (stash!)

          (define (sz)
            (ftell pnodes))

          (let ((bef (sz)))
            (pp-nodes (cdr node))
            (force-output)
            ;; Subtract 1 to ignore the trailing newline.
            (- (sz) bef 1)))

        ((walker dedup!) node)
        (let ((len (stash!))
              (id (node-id node)))

          (define (note-summary! look known lonely)
            (and=> (look node)
                   (lambda (key)
                     (let ((lp (last-pair (or (assq key known)
                                              (lonely key 0)))))
                       (set-cdr! lp (cons id (cdr lp)))))))

          (and (negative? (caddr loc))
               (set! top id))
          (vector-set! index id (cons* name len loc))
          (note-summary! find-listoffloats flosets lonely-flosets)
          (note-summary! (find-printindex cur?) dts lonely-dts)))

      (define (write-index!)
        (call-with-output-file "TMP-W-INDEX"
          (lambda (port)
            (let ((pp-i (ppp port)))
              (do ((i 0 (1+ i)))
                  ((= count i))
                (pp-i (vector-ref index i))))
            (force-output)
            (ftell port))))

      (define (write-section-tree!)
        (call-with-output-file "TMP-W-S-TREE"
          (lambda (port)
            (pretty-print (section-tree cur? nodes) port)
            (force-output)
            (ftell port))))

      (FE names locs nodes grok!)
      (let* ((index-length (write-index!))
             (s-tree-length (write-section-tree!))
             (ixin (string-append stem ".ixin"))
             (port (open-output-file ixin)))

        (define (fso s . args)
          (apply simple-format port s args))

        (close-port pnodes)
        (fso "ixin 1; -*- coding: ~A -*-~%" coding)
        (pretty-print (rescue cur? meta) port)
        (fso "~S~%" (list index-length count top
                          s-tree-length
                          (append dts (lonely-dts))
                          (append flosets (lonely-flosets))))
        (close-port port)
        (let ((tail (fs "TMP-W-INDEX TMP-W-S-TREE ~A ~A TMP-W-NODES"
                        (if (pair? dts)
                            "TMP-W-DTS"
                            "")
                        (if (pair? flosets)
                            "TMP-W-FLOSETS"
                            ""))))

          (define (fsys s . args)
            (zero? (system (apply fs s args))))

          (and (fsys "cat ~A >> ~A" tail ixin)
               (fsys "rm  ~A" tail)))))))

(define (main args)
  (exit (FE (cdr (command-line))
            do-it!)))

;;; mkixin ends here
