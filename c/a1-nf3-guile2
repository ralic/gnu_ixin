#!/bin/sh
exec ${GUILE-guile} -e '(a1-nf3-guile2)' -s $0 "$@" # -*-scheme-*-
!#
;;; a1-nf3-guile2

;; Copyright (C) 2012 Thien-Thi Nguyen
;;
;; This file is part of IXIN.
;;
;; IXIN is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; IXIN is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with IXIN.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; This is supposed to do what a1-nf3-mixp does, using Guile 2
;; facilities.  Unfortunately, Guile 2.0.11 does not maintain
;; input-order for attributes -- see ‘reorder-attributes!’ (blech!).

;;; Code:

(load "./z-dtd.scm")

(setlocale LC_ALL "")

(define-module (a1-nf3-guile2)
  #:export (main)
  #:use-module ((z-dtd) #:select (find-dtd-filename))
  #:use-module ((srfi srfi-1) #:select (find split-at))
  #:use-module ((srfi srfi-11) #:select (let-values))
  #:use-module ((sxml simple) #:select (xml->sxml))
  #:use-module ((ice-9 rdelim) #:select (read-string))
  #:use-module (ice-9 regex)
  #:use-module (ice-9 pretty-print))

;; This pattern matches all entity definitions, including (unused)
;; parameter entities.
(define entity-pattern
  (make-regexp
   "<!ENTITY (% )?([^ ]+) +((SYSTEM|PUBLIC) ([^ ]+) +)?\"([^\"]+)\"( NDATA [^ >]+)? *>"))

(define (match-to-entity m)
  "Convert a regexp match record to an entity pair."
  (let ((parameter-entity? (match:substring m 1))
        (name              (string->symbol (match:substring m 2)))
        (ext-id-group      (match:substring m 3))
        (ext-id-type       (match:substring m 4))
        (ext-id            (match:substring m 5))
        (resource          (match:substring m 6)))
    (if parameter-entity?
        #f ; not supported
        (cons name resource))))

(define (parse-entities filename)
  "Open FILENAME, extract all entity pattern matches, and return entity alist."
  (let ((str (with-input-from-file filename read-string)))
    (fold-matches entity-pattern str '()
                  (lambda (match acc)
                    (let ((entity (match-to-entity match)))
                      (if entity
                          (cons entity acc)
                          acc))))))

(define (doctype-handler docname systemid internal-subset?)
  "Find DTD file to the given SYSTEMID and return parsed entities."
  (let ((dtd-file (find-dtd-filename systemid)))
    (if (not dtd-file)
        (error "Unsupported doctype:" docname systemid)
        (values #:entities (parse-entities dtd-file)
                #:namespaces '()))))

(define (reorder-attributes! tree)
  ;; Unfortunately, this proc uses heuristics derived by examining
  ;; the output w/ and w/o the futzing for hello and coreutils.
  ;; Imperfections remain; the mimicry is incomplete.  :-/
  (or (not (pair? tree))
      (if (and (pair? (cdr tree))
               (pair? (cadr tree))
               (eq? '@ (caadr tree)))
          (let* ((attrs (cadr tree))
                 (ls (cdr attrs)))
            ;; Heuristcs, blech!
            (case (length attrs)
              ;; If 2nd attr name is ‘line’, leave it alone.
              ;; Otherwise, reverse.
              ;;   wrong: (@ (spaces " ") (file "hello.info"))
              ;;   right: (@ (file "hello.info") (spaces " "))
              ((3) (or (eq? 'line (caadr ls))
                       (set-cdr! attrs (reverse ls))))
              ;; If 1st attr name is ‘spaces’, just reverse.
              ;; If any attr name is ‘spaces’, leave it alone.
              ;; Otherwise, "rotate right".
              ;;   wrong: (@ (to "cp") (line " op cp") (from "op")))
              ;;   right: (@ (from "op") (to "cp") (line " op cp")))
              ((4) (cond ((eq? 'spaces (caar ls))
                          (set-cdr! attrs (reverse ls)))
                         ((memq 'spaces (map car ls))
                          #f)
                         (else
                          (let-values (((ntail nhead) (split-at ls 2)))
                            (set-cdr! attrs (append nhead ntail)))))))
            (reorder-attributes! (cddr tree)))
          (for-each reorder-attributes! (cdr tree)))))

(define (one port)
  (let ((sxml (xml->sxml port
                         #:trim-whitespace? #t
                         #:doctype-handler doctype-handler)))
    ;; First, get rid of ‘*TOP*’ and other cruft.
    (set! sxml (find (lambda (x)
                       (and (pair? x)
                            (eq? 'texinfo (car x))))
                     sxml))
    ;; Then, reorder attributes.
    (reorder-attributes! sxml)
    (pretty-print sxml))
  (force-output))

(define (main args)
  (call-with-input-file (cadr args)
    one)
  (exit #t))

;;; a1-nf3-guile2 ends here
