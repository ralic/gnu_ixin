#!/bin/sh
exec ${GUILE-guile} -e '(retrieve)' -s $0 "$@" # -*- scheme -*-
!#
;;; retrieve

;; Copyright (C) 2012 Thien-Thi Nguyen
;;
;; This file is part of IXIN.
;;
;; IXIN is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; IXIN is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with IXIN.  If not, see <http://www.gnu.org/licenses/>.

;;; Code:

(setlocale LC_ALL "")

(load "./z-fixed-pp.scm")

(define-module (retrieve)
  #:export (main))

(use-modules
 ((srfi srfi-1) #:select (fold car+cdr))
 ((srfi srfi-2) #:select (and-let*))
 ((srfi srfi-11) #:select (let-values))
 ((ice-9 pretty-print) #:select (pretty-print))
 ((ice-9 format) #:select (format))
 ((ice-9 rw) #:select (read-string!/partial))
 ((ice-9 rdelim) #:select (read-line))
 ((ice-9 regex) #:select (string-match
                          match:substring))
 ((ice-9 popen) #:select (open-input-pipe
                          close-pipe)))

(define-macro (FE . args)
  (let ((proc (car (last-pair args))))
    `(for-each ,proc ,@(delq proc args))))

(define index-index (make-object-property))

(define (determine-coding port)
  (and-let* ((line (read-line port))
             ((not (eof-object? line)))
             (m (string-match "^; -[*]- coding: (.+) -[*]-$" line)))
    (string->symbol
     (match:substring m 1))))

(define (dts-list counts)
  (list-ref counts 4))

(define (flosets-list counts)
  (list-ref counts 5))

(define (in filename)
  (let ((p (open-input-file filename))
        (vers #f)
        (coding #f)
        (meta #f)
        (counts #f)
        (index #f)
        (labels #f)
        (flosets #f)
        (dtsi #f)
        (s-tree #f)
        (base #f))
    (or (eq? 'ixin (read p))
        (error "bad magic:" filename))
    (set! vers (read p))
    (set! coding (determine-coding p))
    (case vers
      ((1)
       (set! meta (read p))
       (set! counts (read p))
       (set! index (make-vector (cadr counts) #f))
       (do ((i 0 (1+ i)))
           ((= (cadr counts) i))
         (let ((ent (read p)))
           (set! (index-index ent) i)
           (vector-set! index i ent)))
       (set! s-tree (read p))
       (let ((label-len (cadddr counts)))
         (or (zero? label-len)
             (let-values (((n known) (car+cdr (read p))))
               (let loop ((n n) (acc '()))
                 (if (positive? n)
                     (loop (1- n) (cons (read p) acc))
                     (set! labels (cons known (reverse! acc))))))))
       (let loop ((acc '()) (ls (dts-list counts)))
         (if (pair? ls)
             (let ((dts (car ls)))

               (define (go name size . nodes)

                 (define (entries n)
                   (let more ((acc '()) (n n))
                     (if (zero? n)
                         (reverse! acc)
                         (more (cons (read p) acc)
                               (1- n)))))

                 (loop (if (positive? size)
                           (let ((desc (read p)))
                             (acons (cons name (cdr desc))
                                    (entries (car desc))
                                    acc))
                           acc)
                       (cdr ls)))

               (apply go dts))
             (set! dtsi (reverse! acc))))
       (let loop ((acc '()) (ls (flosets-list counts)))
         (if (pair? ls)
             (let ((fl (car ls)))

               (define (go type size . nodes)

                 (define (entries n)
                   (let more ((acc '()) (n n))
                     (if (zero? n)
                         (reverse! acc)
                         (more (cons (read p) acc)
                               (1- n)))))

                 (loop (if (positive? size)
                           (let ((desc (read p)))
                             (acons (cons type (cdr desc))
                                    (entries (car desc))
                                    acc))
                           acc)
                       (cdr ls)))

               (apply go fl))
             (set! flosets (reverse! acc))))
       ;; Adjust w/ ‘1+’ to include trailing newline.
       (set! base (1+ (ftell p))))
      (else
       (error "unhandled version:" vers)))

    ;; rv
    (lambda ()
      (values vers
              coding
              meta
              counts
              index
              s-tree
              labels
              dtsi
              flosets
              base
              p))))

(define (fso s . args)
  (apply format #t s args))

(define-macro (shunt proc-names . otherwise)
  ;; (put 'shunt 'scheme-indent-function 1)
  `(lambda (command . args)
     (apply (case command
              ,@(map (lambda (name)
                       `((,name) ,name))
                     proc-names)
              (else
               ,(if (null? otherwise)
                    '(error "bad command:" command)
                    `(lambda args
                       ,(car otherwise)))))
            args)))

(define (read-string!/partial/never-fewer buf port rd-offset len wr-offset)
  (let ((end (+ wr-offset len)))

    (define (smore-please start)
      (read-string!/partial buf port start end))

    (and rd-offset (seek port rd-offset SEEK_SET))
    (let loop ((this-time (smore-please wr-offset))
               (so-far 0))
      (and (< (+ so-far this-time) len)
           (loop (smore-please (+ so-far wr-offset))
                 (+ so-far this-time))))))

(define (out command . args)
  ;; rv
  (lambda (vers coding meta counts index s-tree labels dtsi flosets base port)
    (let* ((total (cadr counts))
           (alist (vector->list index))
           (plus (list->vector
                  (reverse!
                   (fold (lambda (n so-far)
                           ;; Adjust by 1 for trailing newline.
                           (cons (+ (car so-far) 1 n)
                                 so-far))
                         (list base)
                         (map cadr alist))))))

      (define (by-name name)
        (assoc name alist))

      (define (by-id id)
        (vector-ref index id))

      (define (node-data id len)
        (let ((s (make-string len #\z)))
          (read-string!/partial/never-fewer
           s port (vector-ref plus id) len 0)
          s))

      (define (--dump abbrev)
        (FE '(vers coding meta counts)
            (list vers coding meta counts)
            (lambda (name thing)
              (fso "~A:~%~Y~%" name thing)))
        (fso "node-index:~%")
        (do ((i 0 (1+ i)))
            ((= total i))
          (fso "~Y" (by-id i)))
        (newline)
        (fso "s-tree:~%~Y~%" s-tree)
        (and labels (fso "labels:~%~{~Y~}~%" labels))
        (FE (map car dtsi)
            (map cdr dtsi)
            (lambda (details dts)
              (fso "dts: ~A~%~{~Y~}~%" details dts)))
        (FE (map car flosets)
            (map cdr flosets)
            (lambda (details ents)
              (fso "floset: ~A~%~{~Y~}~%" details ents)))
        (fso "base: ~A~%" base)
        (do ((i 0 (1+ i)))
            ((= total i))
          (let* ((len (cadr (by-id i)))
                 (get (if abbrev
                          (min abbrev len)
                          len))
                 (short? (< get len))
                 (data (node-data i get))
                 (dq (string-count data #\"))
                 (op (string-count data #\())
                 (cl (string-count data #\))))
            (fso "~A:~%~A~A~A" i data
                 (if (odd? dq)
                     " …\""
                     "")
                 (if short?
                     (string-append " …" (make-string (- op cl) #\)))
                     ""))
            (and short?
                 (fso " [+ ~A]" (- len get)))
            (newline))))

      (define (dump)
        (--dump #f))

      (define (dump/abbrev n)
        (--dump (string->number n)))

      (define (dump-meta)
        (fso "~Y" meta))

      (define (dump-counts)
        (fso "~S~%" counts))

      (define (dump-index)
        (FE (iota total)
            alist
            (lambda (i ent)
              (fso "~6,D  ~Y" i ent))))

      (define (show-labels)
        (and labels
             (let-values (((raw rest) (car+cdr labels)))
               (let* ((cooked (map (lambda (label id)
                                     (list
                                      (if (eq? '= label)
                                          (car (vector-ref index id))
                                          label)
                                      id
                                      ""))
                                   raw (iota (length raw))))
                      (all (append! cooked rest))
                      (width (apply max (map string-length (map car all))))
                      (ugh (map (lambda (ent)
                                  (cons width ent))
                                all)))
                 (fso "~:{~V,A  ~4,D   ~A~%~}" ugh)))))

      (define (list-dts)
        (fso "~{~Y~}" (dts-list counts)))

      (define (dump-dts . name)

        (define (one ls)
          (FE (iota (length ls))
              ls
              (lambda (i ent)
                (fso "~6,D  ~Y" i ent))))

        (if (pair? name)
            (let* ((name (car name))
                   (ls (or (assq-ref (map cons
                                          (map caar dtsi)
                                          (map cdr dtsi))
                                     (if (string? name)
                                         (string->symbol name)
                                         name))
                           (error "no such dts:" name))))
              (one ls))
            (FE (map car dtsi)
                (map cdr dtsi)
                (lambda (details ls)
                  (fso "~A: ~A~%" (car details) (cons (length ls)
                                                      (cdr details)))
                  (one ls)))))

      (define (dump-s-tree)
        (fso "~Y" s-tree))

      (define (nd! which go)
        (cond ((and (string? which)
                    (by-name which))
               => go)
              ((false-if-exception (by-id (if (string? which)
                                              (string->number which)
                                              which)))
               => go)
              (else (error "no such node:" which))))

      (define (dump-node which)
        (nd! which (lambda (en)
                     (fso "~A~%" (node-data (index-index en)
                                            (cadr en))))))

      (define (show-node-tree en)
        (seek port (vector-ref plus (index-index en)) SEEK_SET)
        (fso "~Y" (cons 'node (read port))))

      (define (show-node which)

        (define (details en)
          (let ((id (index-index en)))
            (fso "~A: ~Y" id (car en))
            (let ((links (cddr en)))

              (define (maybe blurb get)
                (let ((id (get links)))
                  (or (negative? id)
                      (fso "\t~A: ~Y" blurb (car (by-id id))))))

              (maybe 'next car)
              (maybe 'prev cadr)
              (maybe 'up caddr))
            (show-node-tree en)))

        (nd! which details))

      (define (show-all-nodes)
        (do ((i 0 (1+ i)))
            ((= total i))
          (show-node i)))

      (define (repl end-code)
        (let ((done (string (integer->char (string->number end-code))
                            #\newline))
              (cur 0))

          (define (quit)
            (exit #t))

          (define (where)
            (fso "~Y" (list cur (by-id cur))))

          (define (rel id)
            (cddr (by-id id)))

          (define (nav)
            (fso "~Y" (map cons
                           '(next prev up)
                           (map (lambda (id)
                                  (if (negative? id)
                                      '()
                                      (list id (by-id id))))
                                (rel cur)))))

          (define (move! get)
            (let ((id (get (rel cur))))
              (if (negative? id)
                  (fso "sorry~%")
                  (begin (set! cur id)
                         (where)))))

          (define (next) (move! car))
          (define (prev) (move! cadr))
          (define (up)   (move! caddr))

          (define (goto which)
            (nd! which (lambda (en)
                         (set! cur (index-index en))
                         (where))))

          (define (show . which)
            (nd! (if (pair? which)
                     (car which)
                     cur)
                 show-node-tree))

          (define (raw . which)
            (dump-node (if (pair? which)
                           (car which)
                           cur)))

          (define (loop)
            (let* ((form (read (current-input-port)))
                   (cmd (car form))
                   (args (cdr form)))
              (apply (shunt (quit
                             where
                             nav
                             next
                             prev
                             up
                             goto
                             show
                             raw
                             dump-meta
                             dump-index
                             show-labels
                             list-dts
                             dump-dts
                             dump-s-tree))
                     cmd args)
              (display done)
              (force-output)
              (loop)))

          (loop)))

      (apply (shunt (dump
                     dump/abbrev
                     dump-meta
                     dump-counts
                     dump-index
                     show-labels
                     list-dts
                     dump-dts
                     dump-s-tree
                     dump-node
                     show-node
                     show-all-nodes
                     repl))
             (string->symbol command)
             args))))

(define (main args)
  (call-with-values (in (cadr args))
    (apply out (if (pair? (cddr args))
                   (cddr args)
                   (list "dump/abbrev" "128"))))
  (exit #t))

;;; retrieve ends here
