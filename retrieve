#!/bin/sh
exec ${GUILE-guile} -e '(retrieve)' -s $0 "$@" # -*- scheme -*-
!#
;;; retrieve

;; Copyright (C) 2012 Thien-Thi Nguyen
;;
;; This file is part of IXIN.
;;
;; IXIN is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; IXIN is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with IXIN.  If not, see <http://www.gnu.org/licenses/>.

;;; Code:

(setlocale LC_ALL "")

(load "./z-fixed-pp.scm")

(define-module (retrieve)
  #:export (main))

(use-modules
 ((srfi srfi-1) #:select (fold))
 ((srfi srfi-11) #:select (let-values))
 ((ice-9 pretty-print) #:select (pretty-print))
 ((ice-9 format) #:select (format))
 ((ice-9 rw) #:select (read-string!/partial))
 ((ice-9 rdelim) #:select (read-line))
 ((ice-9 popen) #:select (open-input-pipe
                          close-pipe)))

(define-macro (FE . args)
  (let ((proc (car (last-pair args))))
    `(for-each ,proc ,@(delq proc args))))

(define index-index (make-object-property))

(define (in filename)
  (let ((p (open-input-file filename))
        (vers #f)
        (meta #f)
        (counts #f)
        (index #f)
        (base #f))
    (or (eq? 'ixin (read p))
        (error "bad magic:" filename))
    (set! vers (read p))
    (case vers
      ((1)
       (set! meta (read p))
       (set! counts (read p))
       (set! base (+ 1 (car counts) (ftell p)))
       (set! index (make-vector (cadr counts) #f))
       (do ((i 0 (1+ i)))
           ((= (cadr counts) i))
         (let ((ent (read p)))
           (set! (index-index ent) i)
           (vector-set! index i ent)))
       ;; Adjust w/ ‘1+’ to include trailing newline.
       (set! base (1+ (ftell p))))
      (else
       (error "unhandled version:" vers)))

    ;; rv
    (lambda ()
      (values vers
              meta
              counts
              index
              base
              p))))

(define (fso s . args)
  (apply format #t s args))

(define-macro (shunt proc-names . otherwise)
  ;; (put 'shunt 'scheme-indent-function 1)
  `(lambda (command . args)
     (apply (case command
              ,@(map (lambda (name)
                       `((,name) ,name))
                     proc-names)
              (else
               ,(if (null? otherwise)
                    '(error "bad command:" command)
                    `(lambda args
                       ,(car otherwise)))))
            args)))

(define (read-string!/partial/never-fewer buf port rd-offset len wr-offset)
  (let ((end (+ wr-offset len)))

    (define (smore-please start)
      (read-string!/partial buf port start end))

    (and rd-offset (seek port rd-offset SEEK_SET))
    (let loop ((this-time (smore-please wr-offset))
               (so-far 0))
      (and (< (+ so-far this-time) len)
           (loop (smore-please (+ so-far wr-offset))
                 (+ so-far this-time))))))

(define (out command . args)
  ;; rv
  (lambda (vers meta counts index base port)
    (let* ((total (cadr counts))
           (alist (vector->list index))
           (plus (list->vector
                  (reverse!
                   (fold (lambda (n so-far)
                           ;; Adjust by 1 for trailing newline.
                           (cons (+ (car so-far) 1 n)
                                 so-far))
                         (list base)
                         (map cadr alist))))))

      (define (by-name name)
        (assoc name alist))

      (define (by-id id)
        (vector-ref index id))

      (define (node-data id len)
        (let ((s (make-string len #\z)))
          (read-string!/partial/never-fewer
           s port (vector-ref plus id) len 0)
          s))

      (define (--dump abbrev)
        (FE '(vers meta counts)
            (list vers meta counts)
            (lambda (name thing)
              (fso "~A:~%~Y~%" name thing)))
        (fso "index:~%")
        (do ((i 0 (1+ i)))
            ((= total i))
          (fso "~Y" (by-id i)))
        (fso "~%base: ~A~%" base)
        (do ((i 0 (1+ i)))
            ((= total i))
          (let ((len (cadr (by-id i))))
            (fso "data-~A: ~S" i
                 (node-data i (or abbrev len)))
            (and abbrev
                 (fso " [+ ~A]" (- len abbrev)))
            (newline))))

      (define (dump)
        (--dump #f))

      (define (dump/abbrev n)
        (--dump (string->number n)))

      (define (dump-meta)
        (fso "~Y" meta))

      (define (dump-counts)
        (fso "~S~%" counts))

      (define (dump-index)
        (FE (iota total)
            alist
            (lambda (i ent)
              (fso "~6,D  ~Y" i ent))))

      (define (nd! which go)
        (cond ((and (string? which)
                    (by-name which))
               => go)
              ((false-if-exception (by-id (if (string? which)
                                              (string->number which)
                                              which)))
               => go)
              (else (error "no such node:" which))))

      (define (dump-node which)
        (nd! which (lambda (en)
                     (fso "~A~%" (node-data (index-index en)
                                            (cadr en))))))

      (define (show-node-tree en)
        (seek port (vector-ref plus (index-index en)) SEEK_SET)
        (fso "~Y" (read port)))

      (define (show-node which)

        (define (details en)
          (let ((id (index-index en)))
            (fso "~A: ~Y" id (car en))
            (let ((links (cddr en)))

              (define (maybe blurb get)
                (let ((id (get links)))
                  (or (negative? id)
                      (fso "\t~A: ~Y" blurb (car (by-id id))))))

              (maybe 'next car)
              (maybe 'prev cadr)
              (maybe 'up caddr))
            (show-node-tree en)))

        (nd! which details))

      (define (show-all-nodes)
        (do ((i 0 (1+ i)))
            ((= total i))
          (show-node i)))

      (define (repl end-code)
        (let ((done (string (integer->char (string->number end-code))
                            #\newline))
              (cur 0))

          (define (quit)
            (exit #t))

          (define (where)
            (fso "~Y" (list cur (by-id cur))))

          (define (rel id)
            (cddr (by-id id)))

          (define (nav)
            (fso "~Y" (map cons
                           '(next prev up)
                           (map (lambda (id)
                                  (if (negative? id)
                                      '()
                                      (list id (by-id id))))
                                (rel cur)))))

          (define (move! get)
            (let ((id (get (rel cur))))
              (if (negative? id)
                  (fso "sorry~%")
                  (begin (set! cur id)
                         (where)))))

          (define (next) (move! car))
          (define (prev) (move! cadr))
          (define (up)   (move! caddr))

          (define (goto which)
            (nd! which (lambda (en)
                         (set! cur (index-index en))
                         (where))))

          (define (show . which)
            (nd! (if (pair? which)
                     (car which)
                     cur)
                 show-node-tree))

          (define (raw . which)
            (dump-node (if (pair? which)
                           (car which)
                           cur)))

          (define (loop)
            (let* ((line (read-line (current-input-port)))
                   (sp (string-index line #\space))
                   (cmd (string->symbol (if sp
                                            (string-take line sp)
                                            line)))
                   (args (if sp
                             (list (string-trim-both (string-drop line sp)))
                             '())))
              (apply (shunt (quit
                             where
                             nav
                             next
                             prev
                             up
                             goto
                             show
                             raw
                             dump-meta
                             dump-index))
                     cmd args)
              (display done)
              (force-output)
              (loop)))

          (loop)))

      (apply (shunt (dump
                     dump/abbrev
                     dump-meta
                     dump-counts
                     dump-index
                     dump-node
                     show-node
                     show-all-nodes
                     repl))
             (string->symbol command)
             args))))

(define (main args)
  (call-with-values (in (cadr args))
    (apply out (if (pair? (cddr args))
                   (cddr args)
                   (list "dump/abbrev" "42"))))
  (exit #t))

;;; retrieve ends here
