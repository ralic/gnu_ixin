#!/bin/sh
exec ${GUILE-guile} -e '(a2ixin)' -s $0 "$@" # -*- scheme -*-
!#
;;; a2ixin

;; Copyright (C) 2012 Thien-Thi Nguyen
;;
;; This file is part of IXIN.
;;
;; IXIN is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; IXIN is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with IXIN.  If not, see <http://www.gnu.org/licenses/>.

;;; Code:

(setlocale LC_ALL "")

(load "./z-fixed-pp.scm")

(define-module (a2ixin)
  #:export (main))

(use-modules
 ((srfi srfi-1) #:select (break!))
 ((srfi srfi-11) #:select (let*-values))
 ((srfi srfi-13) #:select (string-suffix?
                           string-drop-right))
 ((ice-9 pretty-print) #:select (pretty-print))
 ((ice-9 popen) #:select (open-input-pipe
                          open-output-pipe
                          close-pipe))
 ((ice-9 rdelim) #:select (read-line write-line)))

(define-macro (FE . args)
  (let ((proc (car (last-pair args))))
    `(for-each ,proc ,@(delq proc args))))

(define (crunch x)

  (define (sz)
    (stat:size (stat "TMP-W-NODES")))

  (let* ((bef (sz))
         (p (open-output-pipe
             "{ gzip -q -n -c --best - | base64 -w 0 ; echo ; } >> TMP-W-NODES")))
    (pretty-print x p)
    (close-pipe p)
    ;; Subtract 1 to ignore the trailing newline.
    (- (sz) bef 1)))

(define (xnode! element)
  (lambda (node)
    (let ((rest (cdr node)))
      (and=> (assq element rest)
             (lambda (sub)
               (let ((rv (caddr sub)))
                 (set-cdr! node (delq! sub rest)) ; DWR!
                 rv))))))

(define (find-printindex node)
  (call-with-current-continuation
   (lambda (return)
     (let repeat ((node node))
       (cond ((string? node)
              #f)
             ((null? node)
              #f)
             ((eq? 'printindex (car node))
              (return (string->symbol (caddr node))))
             (else
              (FE (cddr node) repeat)
              #f))))))

(define (fs s . args)
  (apply simple-format #f s args))

(define (how-to-handle filename)

  (define (w/o ext)
    (string-drop-right filename (string-length ext)))

  (if (string-suffix? ".sxml" filename)
      (values (w/o ".sxml")
              (lambda ()
                (call-with-input-file filename
                  read)))
      (values (w/o ".xml")
              (lambda ()
                (let* ((p (open-input-pipe
                           (fs "~A/a1-nf3-~A ~S"
                               (dirname (car (command-line)))
                               (if #f
                                   'guile2 ; TODO
                                   'mixp)
                               filename)))
                       (form (read p)))
                  (close-pipe p)
                  form)))))

(define (do-it! filename)
  (let*-values (((stem snarf) (how-to-handle filename))
                ((meta nodes) (break! (lambda (x)
                                        (eq? 'node (car x)))
                                      (cdr (snarf)))))
    (call-with-output-file "TMP-W-NODES"
      identity)
    (let* ((coding 'utf-8)              ; TODO
           (pidx (open-output-file "TMP-W-INDEX"))
           (count (length nodes))
           (ids (iota count))
           (names (map (xnode! 'nodename)
                       nodes))
           (top -1)
           (tli '()))                   ; "two-letter" indices

      (define id<-name
        (let ((alist (map cons names ids)))
          ;; id<-name
          (lambda (name)
            (or (assoc-ref alist name)
                -1))))

      (define (grok! name node id)

        (define (deref get)
          (id<-name (get node)))

        (and=> (find-printindex node)
               (lambda (type)
                 (let ((was (or (assq-ref tli type)
                                '())))
                   (set! tli (assq-set! tli type (cons id was))))))
        ;; Do ‘xnode!’ stuff before ‘crunch’; they are destructive!
        (let* ((loc (map deref (map xnode! '(nodenext
                                             nodeprev
                                             nodeup))))
               (len (crunch node)))
          (and (negative? (caddr loc))
               (set! top id))
          (pretty-print (cons* name len loc)
                        pidx)))

      (FE names nodes ids grok!)
      (let* ((index-length (ftell pidx))
             (ixin (string-append stem ".ixin"))
             (port (open-output-file ixin)))

        (define (fso s . args)
          (apply simple-format port s args))

        (close-port pidx)
        (fso "ixin 1; -*- coding: ~A -*-~%" coding)
        (pretty-print meta port)
        (fso "~S~%" (list index-length count top tli))
        (close-port port)
        (let ((tail "TMP-W-INDEX TMP-W-NODES"))

          (define (fsys s . args)
            (zero? (system (apply fs s args))))

          (and (fsys "cat ~A >> ~A" tail ixin)
               (fsys "rm  ~A" tail)))))))

(define (main args)
  (exit (do-it! (cadr (command-line)))))

;;; a2ixin ends here
