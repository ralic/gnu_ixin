#!/bin/sh
exec ${GUILE-guile} -e '(a2ixin)' -s $0 "$@" # -*- scheme -*-
!#
;;; a2ixin

;; Copyright (C) 2012 Thien-Thi Nguyen
;;
;; This file is part of IXIN.
;;
;; IXIN is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; IXIN is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with IXIN.  If not, see <http://www.gnu.org/licenses/>.

;;; Code:

(setlocale LC_ALL "")

(load "./z-fixed-pp.scm")

(define-module (a2ixin)
  #:export (main))

(use-modules
 ((srfi srfi-1) #:select (break!
                          car+cdr
                          take drop))
 ((srfi srfi-11) #:select (let-values
                           let*-values))
 ((srfi srfi-13) #:select (string-suffix?
                           string-drop-right))
 ((ice-9 pretty-print) #:select (pretty-print))
 ((ice-9 popen) #:select (open-input-pipe
                          open-output-pipe
                          close-pipe))
 ((ice-9 rdelim) #:select (read-line write-line)))

(define (ppp port)
  (lambda (x)
    (pretty-print x port)))

(define-macro (FE . args)
  (let ((proc (car (last-pair args))))
    `(for-each ,proc ,@(delq proc args))))

(define (xnode! element)
  (lambda (node)
    (let ((rest (cdr node)))
      (and=> (assq element rest)
             (lambda (sub)
               (let ((rv (caddr sub)))
                 (set-cdr! node (delq! sub rest)) ; DWR!
                 rv))))))

(define (element? element)
  (lambda (form)
    (eq? element (car form))))

(define (find-printindex node)
  (define printindex? (element? 'printindex))
  (call-with-current-continuation
   (lambda (return)
     (let repeat ((node node))
       (cond ((string? node)
              #f)
             ((null? node)
              #f)
             ((printindex? node)
              (return (string->symbol (caddr node))))
             (else
              (FE (cddr node) repeat)
              #f))))))

(define (fs s . args)
  (apply simple-format #f s args))

(define (how-to-handle filename)

  (define (w/o ext)
    (string-drop-right filename (string-length ext)))

  (if (string-suffix? ".sxml" filename)
      (values (w/o ".sxml")
              (lambda ()
                (call-with-input-file filename
                  read)))
      (values (w/o ".xml")
              (lambda ()
                (let* ((p (open-input-pipe
                           (fs "~A/a1-nf3-~A ~S"
                               (dirname (car (command-line)))
                               (if #f
                                   'guile2 ; TODO
                                   'mixp)
                               filename)))
                       (form (read p)))
                  (close-pipe p)
                  form)))))

(define (rescue meta)                   ; from (S)XML, well, partially
                                        ;   obviously, Someone needs
                                        ;     to learn (S)XLST  :-/

  (let-values (((attributes rest) (car+cdr meta)))

    (define (grab-xid! element)         ; external identifiers
      (or (and=> (assq-ref rest element)
                 (lambda (x)
                   (set! rest (assq-remove! rest element)) ; DWR!
                   (cadr x)))
          'none))

    (define (grab-variables!)
      (let loop ((acc '()))
        (cond ((assq 'setvalue rest)
               => (lambda (sub)
                    (set! rest (delq! sub rest)) ; DWR!
                    (loop (acons (string->symbol
                                  (car (assq-ref (cdadr sub) 'name)))
                                 (cddr sub)
                                 acc))))
              (else
               (reverse! acc)))))

    (define (grab/dedup-copying!)
      (let-values (((copying new-rest) (break! (element? 'titlepage)
                                               rest)))
        (set! rest new-rest)            ; DWR!
        (or (null? rest)
            (let* ((len (length copying))
                   (tp (car rest))      ; titlepage
                   (body (cddr tp))
                   (blen (length body)))
              (let loop ((left blen)
                         (ls body))
                (cond ((> len left))
                      ((and (equal? (car copying) (car ls))
                            (equal? copying (take ls len)))
                       (let* ((tp-rest (drop ls len))
                              (new-tp (append (take body (- blen left))
                                              (list "@insertcopying")
                                              tp-rest))
                              (attr (cadr tp))
                              (new-attr `(@ (copying "copying")
                                            ,@(cdr attr))))
                         (set-cdr! tp (cons new-attr new-tp))))
                      (else
                       (loop (1- left)
                             (cdr ls)))))))
        `(copying (@) ,@copying)))

    (let* ((xid (map grab-xid! '(setfilename
                                 settitle
                                 dircategory)))
           (variables (grab-variables!))
           (settings '())               ; TODO
           (copying (grab/dedup-copying!)))

      ;; rv
      `(,(cdr attributes)               ; omit ‘(@)’
        ,xid
        ,variables
        ,settings
        ,copying
        ,@rest))))

(define (do-it! filename)
  (let*-values (((stem snarf) (how-to-handle filename))
                ((meta nodes) (break! (element? 'node)
                                      (cdr (snarf)))))
    (let* ((coding 'utf-8)              ; TODO
           (pnodes (open-output-file "TMP-W-NODES"))
           (pp-nodes (ppp pnodes))
           (count (length nodes))
           (index (make-vector count #f))
           (ids (iota count))
           (names (map (xnode! 'nodename)
                       nodes))
           (top -1)
           (tli '()))                   ; "two-letter" indices

      (define id<-name
        (let ((alist (map cons names ids)))
          ;; id<-name
          (lambda (name)
            (or (assoc-ref alist name)
                -1))))

      (define (grok! name node id)

        (define (deref get)
          (id<-name (get node)))

        (define (stash!)

          (define (sz)
            (ftell pnodes))

          (let ((bef (sz)))
            (pp-nodes node)
            (force-output)
            ;; Subtract 1 to ignore the trailing newline.
            (- (sz) bef 1)))

        (and=> (find-printindex node)
               (lambda (type)
                 (let ((was (or (assq-ref tli type)
                                '())))
                   (set! tli (assq-set! tli type (cons id was))))))
        ;; Do ‘xnode!’ stuff before ‘stash!’; they are destructive!
        (let* ((loc (map deref (map xnode! '(nodenext
                                             nodeprev
                                             nodeup))))
               (len (stash!)))
          (and (negative? (caddr loc))
               (set! top id))
          (vector-set! index id (cons* name len loc))))

      (define (write-index!)
        (call-with-output-file "TMP-W-INDEX"
          (lambda (port)
            (let ((pp-i (ppp port)))
              (do ((i 0 (1+ i)))
                  ((= count i))
                (pp-i (vector-ref index i))))
            (force-output)
            (ftell port))))

      (FE names nodes ids grok!)
      (let* ((index-length (write-index!))
             (ixin (string-append stem ".ixin"))
             (port (open-output-file ixin)))

        (define (fso s . args)
          (apply simple-format port s args))

        (close-port pnodes)
        (fso "ixin 1; -*- coding: ~A -*-~%" coding)
        (pretty-print (rescue meta) port)
        (fso "~S~%" (list index-length count top tli))
        (close-port port)
        (let ((tail "TMP-W-INDEX TMP-W-NODES"))

          (define (fsys s . args)
            (zero? (system (apply fs s args))))

          (and (fsys "cat ~A >> ~A" tail ixin)
               (fsys "rm  ~A" tail)))))))

(define (main args)
  (exit (FE (cdr (command-line))
            do-it!)))

;;; a2ixin ends here
